[
  {
    "question": "1] The use of pragma in the given contract snippet",
    "context": "```\npragma solidity ^0.6.0;\n\ncontract test {\n   // Assume other required functionality is correctly implemented\n   // Assume this contract can work correctly without modifications across 0.6.x/0.7.x/0.8.x compiler versions\n}\n```",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Is incorrect and will cause a compilation error"
      },
      {
        "choice": "B",
        "answer": "Allows testing with 0.6.11 but accidental deployment with buggy 0.6.5"
      },
      {
        "choice": "C",
        "answer": "Is illustrative of risks from using a much older Solidity version (assume current version is 0.8.9)"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C"
    ],
    "race": "RACE-0.md"
  },
  {
    "question": "2] The given contract snippet has",
    "context": "```\npragma solidity 0.8.4;\n\ncontract test {\n\n   // Assume other required functionality is correctly implemented\n\n   function kill() public {\n      selfdestruct(payable(0x0));\n   }\n}\n```",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Unprotected call to *selfdestruct* allowing anyone to destroy this contract"
      },
      {
        "choice": "B",
        "answer": "Dangerous use of zero address leading to burning of contract balance"
      },
      {
        "choice": "C",
        "answer": "A compiler error because of the use of the *kill* reserved keyword"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B"
    ],
    "race": "RACE-0.md"
  },
  {
    "question": "3] The given contract snippet has",
    "context": "```\npragma solidity 0.8.4;\n\ncontract test {\n\n    // Assume other required functionality is correctly implemented\n\n    modifier onlyAdmin() {\n        // Assume this is correctly implemented\n        _;\n    }\n\n    function transferFunds(address payable recipient, uint amount) public {\n        recipient.transfer(amount);\n   }\n}\n```",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Missing use of *onlyAdmin* modifier on *transferFunds*"
      },
      {
        "choice": "B",
        "answer": "Missing return value check on *transfer*"
      },
      {
        "choice": "C",
        "answer": "Unprotected withdrawal of funds"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "C"
    ],
    "race": "RACE-0.md"
  },
  {
    "question": "4] In the given contract snippet",
    "context": "pragma solidity 0.8.4;\n```\ncontract test {\n\n    // Assume other required functionality is correctly implemented\n\n    mapping (uint256 => address) addresses;\n    bool check;\n\n    modifier onlyIf() {\n        if (check) {\n            _;\n        }\n    }\n\n    function setAddress(uint id, address addr) public {\n        addresses[id] = addr;\n    }\n\n    function getAddress(uint id) public onlyIf returns (address) {\n        return addresses[id];\n    }\n}\n```",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "*getAddress* returns the expected addresses if *check* is true"
      },
      {
        "choice": "B",
        "answer": "*getAddress* returns zero address if *check* is false"
      },
      {
        "choice": "C",
        "answer": "*getAddress* reverts if *check* is false"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B"
    ],
    "race": "RACE-0.md"
  },
  {
    "question": "5] The security concern(s) in the given contract snippet is/are",
    "context": "```\npragma solidity 0.8.4;\n\ncontract test {\n\n    // Assume other required functionality is correctly implemented\n\n    modifier onlyAdmin {\n     // Assume this is correctly implemented\n        _;\n    }\n\n    function delegate (address addr) external {  addr.delegatecall(abi.encodeWithSignature(\"setDelay(uint256)\"));\n    }\n}\n```",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Potential controlled *delegatecall* risk"
      },
      {
        "choice": "B",
        "answer": "*delegatecall* return value is not checked"
      },
      {
        "choice": "C",
        "answer": "*delegate()* may be missing *onlyAdmin* modifier"
      },
      {
        "choice": "D",
        "answer": "*delegate()* does not check for contract existence at *addr* \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C",
      "D"
    ],
    "race": "RACE-0.md"
  },
  {
    "question": "6] The vulnerability/vulnerabilities present in the given contract snippet is/are",
    "context": "```\npragma solidity 0.7.0;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n// which works with 0.7.0\n\ncontract test {\n\n // Assume other required functionality is correctly implemented\n // For e.g. users have deposited balances in the contract\n // Assume nonReentrant modifier is always applied\n\n    mapping (address => uint256) balances;\n\n    function withdraw(uint256 amount) external nonReentrant {\n        msg.sender.call{value: amount}(\"\");\n        balances[msg.sender] -= amount;\n    }\n}\n```",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Reentrancy"
      },
      {
        "choice": "B",
        "answer": "Integer underflow leading to wrapping"
      },
      {
        "choice": "C",
        "answer": "Missing check on user balance in *withdraw()*"
      },
      {
        "choice": "D",
        "answer": "All of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C or A",
      "B",
      "C or A",
      "B",
      "C",
      "D or D"
    ],
    "race": "RACE-0.md"
  },
  {
    "question": "7] The security concern(s) in the given contract snippet is/are",
    "context": "```\npragma solidity 0.8.4;\n\ncontract test {\n\n // Assume other required functionality is correctly implemented\n\n    uint256 private constant secret = 123;\n\n    function diceRoll() external view returns (uint256) {\n        return (((block.timestamp * secret) % 6) + 1);\n    }\n}\n```",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "*diceRoll()* visibility should be *public* instead of *external*"
      },
      {
        "choice": "B",
        "answer": "The *private* variable secret is not really hidden from users"
      },
      {
        "choice": "C",
        "answer": "*block.timestamp* is an insecure source of randomness"
      },
      {
        "choice": "D",
        "answer": "Integer overflow \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C"
    ],
    "race": "RACE-0.md"
  },
  {
    "question": "8] The security concern(s) in the given contract snippet is/are",
    "context": "```\npragma solidity 0.8.4;\n\ncontract test {\n\n    // Assume other required functionality is correctly implemented\n    // Contract admin set to deployer in constructor (not shown)\n    address admin;\n\n    modifier onlyAdmin {\n        require(tx.origin == admin);\n        _;\n    }\n\n    function emergencyWithdraw() external payable onlyAdmin {\n        msg.sender.transfer(address(this).balance);\n    }\n}\n```",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Incorrect use of *transfer()* instead of using *send()*"
      },
      {
        "choice": "B",
        "answer": "Potential man-in-the-middle attack on *admin* address authentication"
      },
      {
        "choice": "C",
        "answer": "Assumption on contract balance might cause a revert"
      },
      {
        "choice": "D",
        "answer": "Missing event for critical *emergencyWithdraw()* function \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "D"
    ],
    "race": "RACE-0.md"
  },
  {
    "question": "9] The given contract snippet is vulnerable because of",
    "context": "```\npragma solidity 0.8.4;\n\ncontract test {\n\n    // Assume other required functionality is correctly implemented\n\n    uint256 private constant MAX_FUND_RAISE = 100 ether;\n    mapping (address => uint256) contributions;\n\n    function contribute() external payable {\n        require(address(this).balance != MAX_FUND_RAISE);\n        contributions[msg.sender] += msg.value;\n    }\n}\n```",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Integer overflow leading to wrapping"
      },
      {
        "choice": "B",
        "answer": "Overly permissive function visibility of *contribute()*"
      },
      {
        "choice": "C",
        "answer": "Incorrect use of *msg.sender*"
      },
      {
        "choice": "D",
        "answer": "Use of strict equality (!=) may break the *MAX_FUND_RAISE* constraint \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-0.md"
  },
  {
    "question": "10] In the given contract snippet, the require check will",
    "context": "```\npragma solidity 0.8.4;\n\ncontract test {\n\n    // Assume other required functionality is correctly implemented\n\n    function callMe (address target) external {\n        (bool success, ) = target.call(\"\");\n        require(success);\n    }\n}\n```",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Pass only if target is an existing contract address"
      },
      {
        "choice": "B",
        "answer": "Pass for a non-existent contract address"
      },
      {
        "choice": "C",
        "answer": "Pass always"
      },
      {
        "choice": "D",
        "answer": "Fail always \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-0.md"
  },
  {
    "question": "11] The security concern(s) in the given contract snippet is/are",
    "context": "```\npragma solidity 0.8.4;\n\ncontract test {\n\n    // Assume other required functionality is correctly implemented\n    // Assume admin is set correctly to contract deployer in constructor\n    address admin;\n\n    function setAdmin (address _newAdmin) external {\n        admin = _newAdmin;\n    }\n}\n```",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Missing access control on critical function"
      },
      {
        "choice": "B",
        "answer": "Missing zero-address validation"
      },
      {
        "choice": "C",
        "answer": "Single-step change of critical address"
      },
      {
        "choice": "D",
        "answer": "Missing event for critical function \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C",
      "D"
    ],
    "race": "RACE-0.md"
  },
  {
    "question": "12] The security concern(s) in the given contract snippet is/are",
    "context": "```\npragma solidity 0.8.4;\n\ncontract test {\n\n    // Assume other required functionality is correctly implemented\n\n    address admin;\n    address payable pool;\n\n   constructor(address _admin) {\n        admin = _admin;\n    }\n\n    modifier onlyAdmin {\n        require(msg.sender == admin);\n        _;\n    }\n\n    function setPoolAddress(address payable _pool) external onlyAdmin {\n        pool = _pool;\n    }\n\n    function addLiquidity() payable external {\n        pool.transfer(msg.value);\n    }\n}\n```",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Uninitialized pool storage variable which assumes *setPoolAddress()* will be called before *addLiquidity()*"
      },
      {
        "choice": "B",
        "answer": "Incorrect use of modifier *onlyAdmin* on *setPoolAddress()*"
      },
      {
        "choice": "C",
        "answer": "Missing zero-address validation for *_pool* in *setPoolAddress()*"
      },
      {
        "choice": "D",
        "answer": "Transaction order dependence risk from *admin* front-running with pool address change \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "C",
      "D"
    ],
    "race": "RACE-0.md"
  },
  {
    "question": "13] The security concern(s) in the given proxy-based implementation contract snippet is/are",
    "context": "```\npragma solidity 0.8.4;\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/proxy/utils/Initializable.sol\";\n\ncontract test is Initializable {\n\n    // Assume other required functionality is correctly implemented\n\n    address admin;\n    uint256 rewards = 10;\n\n    modifier onlyAdmin {\n        require(msg.sender == admin);\n        _;\n    }\n\n    function initialize (address _admin) external {\n        require(_admin != address(0));\n        admin = _admin;\n    }\n\n    function setRewards(uint256 _rewards) external onlyAdmin {\n        rewards = _rewards;\n    }\n}\n```",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Imported contracts are not upgradeable"
      },
      {
        "choice": "B",
        "answer": "Multiple *initialize()* calls possible which allows anyone to reset the *admin*"
      },
      {
        "choice": "C",
        "answer": "*rewards* will be 0 in the proxy contract before *setRewards()* is called by it"
      },
      {
        "choice": "D",
        "answer": "All the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C"
    ],
    "race": "RACE-0.md"
  },
  {
    "question": "14] The security concern(s) in the given contract snippet is/are",
    "context": "```\npragma solidity 0.8.4;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\n\ncontract test {\n\n    // Assume other required functionality is correctly implemented\n\n    address admin;\n    address token;\n\n    constructor(address _admin, address _token) {\n        require(_admin != address(0));\n        require(_token != address(0));\n        admin = _admin;\n        token = _token;\n    }\n\n    modifier onlyAdmin {\n        require(msg.sender == admin);\n        _;\n    }\n\n    function payRewards(address[] calldata recipients, uint256[] calldata amounts) external onlyAdmin {\n        for (uint i; i < recipients.length; i++) {\n            IERC20(token).transfer(recipients[i], amounts[i]);\n        }\n    }\n}\n```",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Potential out-of-gas exceptions due to unbounded external calls within loop"
      },
      {
        "choice": "B",
        "answer": "ERC20 *approve()* race condition"
      },
      {
        "choice": "C",
        "answer": "Unchecked return value of *transfer()* (assuming it returns a boolean/other value and does not revert on failure)"
      },
      {
        "choice": "D",
        "answer": "Potential reverts due to mismatched lengths of *recipients* and *amounts* arrays \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "C",
      "D"
    ],
    "race": "RACE-0.md"
  },
  {
    "question": "15] The vulnerability/vulnerabilities present in the given contract snippet is/are",
    "context": "```\npragma solidity 0.8.4;\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol\";\n\ncontract test {\n\n // Assume other required functionality is correctly implemented\n // For e.g. users have deposited balances in the contract\n\n    mapping (address => uint256) balances;\n\n    function withdrawBalance() external {\n        msg.sender.call{value: balances[msg.sender]}(\"\");\n        balances[msg.sender] = 0;\n    }\n}\n```",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Reentrancy"
      },
      {
        "choice": "B",
        "answer": "Integer overflow leading to wrapping"
      },
      {
        "choice": "C",
        "answer": "Integer underflow leading to wrapping"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "race": "RACE-0.md"
  },
  {
    "question": "16] The security concern(s) in the given contract snippet is/are",
    "context": "```\npragma solidity 0.8.4;\n\ncontract test {\n// Assume other required functionality is correctly implemented\n// Assume that hash is the hash of a message computed elsewhere in contract\n// Assume that the contract does not make use of chainID or nonces in its logic\n\nfunction verify(address signer, bytes32 memory hash, bytes32 sigR, bytes32 sigS, uint8 sigV) internal view returns (bool) {\n   return signer == ecrecover(hash, sigV, sigR, sigS);\n}\n```",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Signature malleability risk of *ecrecover*"
      },
      {
        "choice": "B",
        "answer": "Missing use of nonce in message hash may allow replay attacks across transactions"
      },
      {
        "choice": "C",
        "answer": "Missing use of *chainID* in message hash may allow replay attacks across chains"
      },
      {
        "choice": "D",
        "answer": "Missing zero-address check for *ecrecover* return value may allow invalid signatures \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C",
      "D"
    ],
    "race": "RACE-0.md"
  },
  {
    "question": "1] The _InSecureumToken_ contract strictly follows the specification of",
    "context": " The _InSecureumToken_ contract implements a token contract which allows users to buy tokens by depositing Ether (at a certain conversion ratio), and transfer tokens.\n```\npragma solidity 0.7.0;\n\ncontract InSecureumToken {\n\nmapping(address => uint) private balances;\n\nuint public decimals = 10**18; // decimals of the token\nuint public totalSupply; // total supply\nuint MAX_SUPPLY = 100 ether; // Maximum total supply\n\nevent Mint(address indexed destination, uint amount);\n\nfunction transfer(address to, uint amount) public {\n   // save the balance in local variables\n   // so that we can re-use them multiple times\n   // without paying for SLOAD on every access\n   uint balance_from = balances[msg.sender];\n   uint balance_to = balances[to];\n   require(balance_from >= amount);\n   balances[msg.sender] = balance_from - amount;\n   balances[to] = safeAdd(balance_to, amount);\n}\n\n\n/// @notice Allow users to buy token. 1 ether = 10 tokens\n/// @dev Users can send more ether than token to be bought, to donate a fee to the protocol team.\nfunction buy(uint desired_tokens) public payable {\n   // Check if enough ether has been sent\n   uint required_wei_sent = (desired_tokens / 10) * decimals;\n   require(msg.value >= required_wei_sent);\n\n   // Mint the tokens\n   totalSupply = safeAdd(totalSupply, desired_tokens);\n   balances[msg.sender] = safeAdd(balances[msg.sender], desired_tokens);\n   emit Mint(msg.sender, desired_tokens);\n}\n\n\n/// @notice Add two values. Revert if overflow\nfunction safeAdd(uint a, uint b) pure internal returns(uint) {\n   if (a + b < a) {\n      revert();\n   }\n   return a + b;\n}\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "ERC20"
      },
      {
        "choice": "B",
        "answer": "ERC777"
      },
      {
        "choice": "C",
        "answer": "ERC721"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-1.md"
  },
  {
    "question": "2] To avoid lock of funds, the following feature(s) MUST be implemented before contract deployment",
    "context": " The _InSecureumToken_ contract implements a token contract which allows users to buy tokens by depositing Ether (at a certain conversion ratio), and transfer tokens.\n```\npragma solidity 0.7.0;\n\ncontract InSecureumToken {\n\nmapping(address => uint) private balances;\n\nuint public decimals = 10**18; // decimals of the token\nuint public totalSupply; // total supply\nuint MAX_SUPPLY = 100 ether; // Maximum total supply\n\nevent Mint(address indexed destination, uint amount);\n\nfunction transfer(address to, uint amount) public {\n   // save the balance in local variables\n   // so that we can re-use them multiple times\n   // without paying for SLOAD on every access\n   uint balance_from = balances[msg.sender];\n   uint balance_to = balances[to];\n   require(balance_from >= amount);\n   balances[msg.sender] = balance_from - amount;\n   balances[to] = safeAdd(balance_to, amount);\n}\n\n\n/// @notice Allow users to buy token. 1 ether = 10 tokens\n/// @dev Users can send more ether than token to be bought, to donate a fee to the protocol team.\nfunction buy(uint desired_tokens) public payable {\n   // Check if enough ether has been sent\n   uint required_wei_sent = (desired_tokens / 10) * decimals;\n   require(msg.value >= required_wei_sent);\n\n   // Mint the tokens\n   totalSupply = safeAdd(totalSupply, desired_tokens);\n   balances[msg.sender] = safeAdd(balances[msg.sender], desired_tokens);\n   emit Mint(msg.sender, desired_tokens);\n}\n\n\n/// @notice Add two values. Revert if overflow\nfunction safeAdd(uint a, uint b) pure internal returns(uint) {\n   if (a + b < a) {\n      revert();\n   }\n   return a + b;\n}\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "A _transferFrom()_ function"
      },
      {
        "choice": "B",
        "answer": "A _burn()_ function"
      },
      {
        "choice": "C",
        "answer": "A way to withdraw/exchange/use Ether from the contract"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-1.md"
  },
  {
    "question": "3] Which of the following assertion(s) is/are true (without affecting the security posture of the contract)?",
    "context": " The _InSecureumToken_ contract implements a token contract which allows users to buy tokens by depositing Ether (at a certain conversion ratio), and transfer tokens.\n```\npragma solidity 0.7.0;\n\ncontract InSecureumToken {\n\nmapping(address => uint) private balances;\n\nuint public decimals = 10**18; // decimals of the token\nuint public totalSupply; // total supply\nuint MAX_SUPPLY = 100 ether; // Maximum total supply\n\nevent Mint(address indexed destination, uint amount);\n\nfunction transfer(address to, uint amount) public {\n   // save the balance in local variables\n   // so that we can re-use them multiple times\n   // without paying for SLOAD on every access\n   uint balance_from = balances[msg.sender];\n   uint balance_to = balances[to];\n   require(balance_from >= amount);\n   balances[msg.sender] = balance_from - amount;\n   balances[to] = safeAdd(balance_to, amount);\n}\n\n\n/// @notice Allow users to buy token. 1 ether = 10 tokens\n/// @dev Users can send more ether than token to be bought, to donate a fee to the protocol team.\nfunction buy(uint desired_tokens) public payable {\n   // Check if enough ether has been sent\n   uint required_wei_sent = (desired_tokens / 10) * decimals;\n   require(msg.value >= required_wei_sent);\n\n   // Mint the tokens\n   totalSupply = safeAdd(totalSupply, desired_tokens);\n   balances[msg.sender] = safeAdd(balances[msg.sender], desired_tokens);\n   emit Mint(msg.sender, desired_tokens);\n}\n\n\n/// @notice Add two values. Revert if overflow\nfunction safeAdd(uint a, uint b) pure internal returns(uint) {\n   if (a + b < a) {\n      revert();\n   }\n   return a + b;\n}\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "_buy()_ does not need payable keyword"
      },
      {
        "choice": "B",
        "answer": "_balances_ must be private"
      },
      {
        "choice": "C",
        "answer": "_transfer()_ can be external"
      },
      {
        "choice": "D",
        "answer": "_safeAdd()_ can be public \n \n \n"
      }
    ],
    "correctAnswers": [
      "C",
      "D"
    ],
    "race": "RACE-1.md"
  },
  {
    "question": "4] The total supply is limited by",
    "context": " The _InSecureumToken_ contract implements a token contract which allows users to buy tokens by depositing Ether (at a certain conversion ratio), and transfer tokens.\n```\npragma solidity 0.7.0;\n\ncontract InSecureumToken {\n\nmapping(address => uint) private balances;\n\nuint public decimals = 10**18; // decimals of the token\nuint public totalSupply; // total supply\nuint MAX_SUPPLY = 100 ether; // Maximum total supply\n\nevent Mint(address indexed destination, uint amount);\n\nfunction transfer(address to, uint amount) public {\n   // save the balance in local variables\n   // so that we can re-use them multiple times\n   // without paying for SLOAD on every access\n   uint balance_from = balances[msg.sender];\n   uint balance_to = balances[to];\n   require(balance_from >= amount);\n   balances[msg.sender] = balance_from - amount;\n   balances[to] = safeAdd(balance_to, amount);\n}\n\n\n/// @notice Allow users to buy token. 1 ether = 10 tokens\n/// @dev Users can send more ether than token to be bought, to donate a fee to the protocol team.\nfunction buy(uint desired_tokens) public payable {\n   // Check if enough ether has been sent\n   uint required_wei_sent = (desired_tokens / 10) * decimals;\n   require(msg.value >= required_wei_sent);\n\n   // Mint the tokens\n   totalSupply = safeAdd(totalSupply, desired_tokens);\n   balances[msg.sender] = safeAdd(balances[msg.sender], desired_tokens);\n   emit Mint(msg.sender, desired_tokens);\n}\n\n\n/// @notice Add two values. Revert if overflow\nfunction safeAdd(uint a, uint b) pure internal returns(uint) {\n   if (a + b < a) {\n      revert();\n   }\n   return a + b;\n}\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "`10**18`"
      },
      {
        "choice": "B",
        "answer": "`100 * 10**18`"
      },
      {
        "choice": "C",
        "answer": "`100`"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-1.md"
  },
  {
    "question": "5] The following issue(s) is/are present in the codebase",
    "context": " The _InSecureumToken_ contract implements a token contract which allows users to buy tokens by depositing Ether (at a certain conversion ratio), and transfer tokens.\n```\npragma solidity 0.7.0;\n\ncontract InSecureumToken {\n\nmapping(address => uint) private balances;\n\nuint public decimals = 10**18; // decimals of the token\nuint public totalSupply; // total supply\nuint MAX_SUPPLY = 100 ether; // Maximum total supply\n\nevent Mint(address indexed destination, uint amount);\n\nfunction transfer(address to, uint amount) public {\n   // save the balance in local variables\n   // so that we can re-use them multiple times\n   // without paying for SLOAD on every access\n   uint balance_from = balances[msg.sender];\n   uint balance_to = balances[to];\n   require(balance_from >= amount);\n   balances[msg.sender] = balance_from - amount;\n   balances[to] = safeAdd(balance_to, amount);\n}\n\n\n/// @notice Allow users to buy token. 1 ether = 10 tokens\n/// @dev Users can send more ether than token to be bought, to donate a fee to the protocol team.\nfunction buy(uint desired_tokens) public payable {\n   // Check if enough ether has been sent\n   uint required_wei_sent = (desired_tokens / 10) * decimals;\n   require(msg.value >= required_wei_sent);\n\n   // Mint the tokens\n   totalSupply = safeAdd(totalSupply, desired_tokens);\n   balances[msg.sender] = safeAdd(balances[msg.sender], desired_tokens);\n   emit Mint(msg.sender, desired_tokens);\n}\n\n\n/// @notice Add two values. Revert if overflow\nfunction safeAdd(uint a, uint b) pure internal returns(uint) {\n   if (a + b < a) {\n      revert();\n   }\n   return a + b;\n}\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "An integer underflow allows one to drain Ether"
      },
      {
        "choice": "B",
        "answer": "Unsafe rounding allows one to receive new tokens for free"
      },
      {
        "choice": "C",
        "answer": "A division by zero allows one to trap/freeze the system"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-1.md"
  },
  {
    "question": "6] The following issue(s) is/are present in the codebase",
    "context": " The _InSecureumToken_ contract implements a token contract which allows users to buy tokens by depositing Ether (at a certain conversion ratio), and transfer tokens.\n```\npragma solidity 0.7.0;\n\ncontract InSecureumToken {\n\nmapping(address => uint) private balances;\n\nuint public decimals = 10**18; // decimals of the token\nuint public totalSupply; // total supply\nuint MAX_SUPPLY = 100 ether; // Maximum total supply\n\nevent Mint(address indexed destination, uint amount);\n\nfunction transfer(address to, uint amount) public {\n   // save the balance in local variables\n   // so that we can re-use them multiple times\n   // without paying for SLOAD on every access\n   uint balance_from = balances[msg.sender];\n   uint balance_to = balances[to];\n   require(balance_from >= amount);\n   balances[msg.sender] = balance_from - amount;\n   balances[to] = safeAdd(balance_to, amount);\n}\n\n\n/// @notice Allow users to buy token. 1 ether = 10 tokens\n/// @dev Users can send more ether than token to be bought, to donate a fee to the protocol team.\nfunction buy(uint desired_tokens) public payable {\n   // Check if enough ether has been sent\n   uint required_wei_sent = (desired_tokens / 10) * decimals;\n   require(msg.value >= required_wei_sent);\n\n   // Mint the tokens\n   totalSupply = safeAdd(totalSupply, desired_tokens);\n   balances[msg.sender] = safeAdd(balances[msg.sender], desired_tokens);\n   emit Mint(msg.sender, desired_tokens);\n}\n\n\n/// @notice Add two values. Revert if overflow\nfunction safeAdd(uint a, uint b) pure internal returns(uint) {\n   if (a + b < a) {\n      revert();\n   }\n   return a + b;\n}\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "A front-running allows one to pay less than expected for tokens"
      },
      {
        "choice": "B",
        "answer": "A lack of access control allows one to receive tokens for free"
      },
      {
        "choice": "C",
        "answer": "Incorrect balance update allows one to receive new tokens for free"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-1.md"
  },
  {
    "question": "7] The following issue(s) is/are present in the codebase",
    "context": " The _InSecureumToken_ contract implements a token contract which allows users to buy tokens by depositing Ether (at a certain conversion ratio), and transfer tokens.\n```\npragma solidity 0.7.0;\n\ncontract InSecureumToken {\n\nmapping(address => uint) private balances;\n\nuint public decimals = 10**18; // decimals of the token\nuint public totalSupply; // total supply\nuint MAX_SUPPLY = 100 ether; // Maximum total supply\n\nevent Mint(address indexed destination, uint amount);\n\nfunction transfer(address to, uint amount) public {\n   // save the balance in local variables\n   // so that we can re-use them multiple times\n   // without paying for SLOAD on every access\n   uint balance_from = balances[msg.sender];\n   uint balance_to = balances[to];\n   require(balance_from >= amount);\n   balances[msg.sender] = balance_from - amount;\n   balances[to] = safeAdd(balance_to, amount);\n}\n\n\n/// @notice Allow users to buy token. 1 ether = 10 tokens\n/// @dev Users can send more ether than token to be bought, to donate a fee to the protocol team.\nfunction buy(uint desired_tokens) public payable {\n   // Check if enough ether has been sent\n   uint required_wei_sent = (desired_tokens / 10) * decimals;\n   require(msg.value >= required_wei_sent);\n\n   // Mint the tokens\n   totalSupply = safeAdd(totalSupply, desired_tokens);\n   balances[msg.sender] = safeAdd(balances[msg.sender], desired_tokens);\n   emit Mint(msg.sender, desired_tokens);\n}\n\n\n/// @notice Add two values. Revert if overflow\nfunction safeAdd(uint a, uint b) pure internal returns(uint) {\n   if (a + b < a) {\n      revert();\n   }\n   return a + b;\n}\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "A reentrancy allows one to drain Ether"
      },
      {
        "choice": "B",
        "answer": "A reentrancy allows one to drain the tokens"
      },
      {
        "choice": "C",
        "answer": "A reentrancy allows one to receive new tokens for free"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-1.md"
  },
  {
    "question": "8] The following issue(s) is/are present in the codebase",
    "context": " The _InSecureumToken_ contract implements a token contract which allows users to buy tokens by depositing Ether (at a certain conversion ratio), and transfer tokens.\n```\npragma solidity 0.7.0;\n\ncontract InSecureumToken {\n\nmapping(address => uint) private balances;\n\nuint public decimals = 10**18; // decimals of the token\nuint public totalSupply; // total supply\nuint MAX_SUPPLY = 100 ether; // Maximum total supply\n\nevent Mint(address indexed destination, uint amount);\n\nfunction transfer(address to, uint amount) public {\n   // save the balance in local variables\n   // so that we can re-use them multiple times\n   // without paying for SLOAD on every access\n   uint balance_from = balances[msg.sender];\n   uint balance_to = balances[to];\n   require(balance_from >= amount);\n   balances[msg.sender] = balance_from - amount;\n   balances[to] = safeAdd(balance_to, amount);\n}\n\n\n/// @notice Allow users to buy token. 1 ether = 10 tokens\n/// @dev Users can send more ether than token to be bought, to donate a fee to the protocol team.\nfunction buy(uint desired_tokens) public payable {\n   // Check if enough ether has been sent\n   uint required_wei_sent = (desired_tokens / 10) * decimals;\n   require(msg.value >= required_wei_sent);\n\n   // Mint the tokens\n   totalSupply = safeAdd(totalSupply, desired_tokens);\n   balances[msg.sender] = safeAdd(balances[msg.sender], desired_tokens);\n   emit Mint(msg.sender, desired_tokens);\n}\n\n\n/// @notice Add two values. Revert if overflow\nfunction safeAdd(uint a, uint b) pure internal returns(uint) {\n   if (a + b < a) {\n      revert();\n   }\n   return a + b;\n}\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "An integer overflow allows one to drain Ether"
      },
      {
        "choice": "B",
        "answer": "An integer overflow allows one to receive new tokens for free"
      },
      {
        "choice": "C",
        "answer": "An integer overflow allows one to trap/freeze the system"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "D or B or C or B",
      "C"
    ],
    "race": "RACE-1.md"
  },
  {
    "question": "1] Which statements are true in `Test1()`?",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TestContract is Ownable {\n   \n    function Test1(uint n) external pure returns(uint) {\n        return n + abi.decode(msg.data[msg.data.length-64:], (uint));\n    }\n\n    function Test2(uint n) public view returns(uint) {\n        bytes memory fcall = abi.encodeCall(TestContract.Test1,(n));\n        bytes memory xtr = abi.encodePacked(uint(4),uint(5));\n        bytes memory all = bytes.concat(fcall,xtr);\n        (bool success, bytes memory data) = address(this).staticcall(all);\n        return abi.decode(data,(uint));\n    } \n\n    type Nonce is uint256;\n    struct Book { Nonce nonce;}\n    \n    function NextBookNonce(Book memory x) public pure {\n       x.nonce = Nonce.wrap(Nonce.unwrap(x.nonce) + 3);\n    }\n\n    function Test3(uint n) public pure returns (uint) {\n      Book memory bookIndex;\n      bookIndex.nonce = Nonce.wrap(7);\n      for (uint i=0;i<n;i++) {\n         NextBookNonce(bookIndex);\n      }   \n      return Nonce.unwrap(bookIndex.nonce);\n    }\n\n    error ZeroAddress();\n    error ZeroAmount();\n    uint constant ZeroAddressFlag = 1;\n    uint constant ZeroAmountFlag = 2;\n\n    function process(address[] memory a, uint[] memory amount) public pure returns (uint){\n        uint error;\n        uint total;\n        for (uint i=0;i<a.length;i++) {\n            if (a[i] == address(0)) error |= ZeroAddressFlag;\n            if (amount[i] == 0) error |= ZeroAmountFlag;\n            total += amount[i];\n        }\n        if (error == ZeroAddressFlag) revert ZeroAddress();\n        if (error == ZeroAmountFlag)  revert ZeroAmount();\n        return total;\n    }\n\n    function Test4(uint n) public pure returns (uint) {\n        address[] memory a = new address[](n+1);\n        for (uint i=0;i<=n;i++) {\n            a[i] = address(uint160(i));\n        }\n        uint[] memory amount = new uint[](n+1);\n        for (uint i=0;i<=n;i++) {\n            amount[i] = i;\n        }    \n        return process(a,amount);\n    }\n\n    uint public totalMinted;\n    uint constant maxMinted = 100;\n    event minted(uint totalMinted,uint currentMint);\n\n    modifier checkInvariants() {\n        require(!paused, \"Paused\");\n        _;\n        invariantCheck();\n        require(!paused, \"Paused\");\n    }\n    \n    function invariantCheck() public {\n        if (totalMinted > maxMinted) // this may never happen\n            pause();\n    }\n\n    bool public paused;\n    function pause() public {  \n        paused = true;\n    }\n    function unpause() public onlyOwner {\n        paused = false;\n    }\n\n    function Test5( uint n) public checkInvariants(){\n        totalMinted += n;\n        emit minted(n,totalMinted);\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The function does not use all supplied extra data"
      },
      {
        "choice": "B",
        "answer": "The function can revert due to an underflow"
      },
      {
        "choice": "C",
        "answer": "The function can revert due to an overflow"
      },
      {
        "choice": "D",
        "answer": "The function accesses memory which it should not \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C"
    ],
    "race": "RACE-10.md"
  },
  {
    "question": "2] Which statements are true in `Test2()`?",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TestContract is Ownable {\n   \n    function Test1(uint n) external pure returns(uint) {\n        return n + abi.decode(msg.data[msg.data.length-64:], (uint));\n    }\n\n    function Test2(uint n) public view returns(uint) {\n        bytes memory fcall = abi.encodeCall(TestContract.Test1,(n));\n        bytes memory xtr = abi.encodePacked(uint(4),uint(5));\n        bytes memory all = bytes.concat(fcall,xtr);\n        (bool success, bytes memory data) = address(this).staticcall(all);\n        return abi.decode(data,(uint));\n    } \n\n    type Nonce is uint256;\n    struct Book { Nonce nonce;}\n    \n    function NextBookNonce(Book memory x) public pure {\n       x.nonce = Nonce.wrap(Nonce.unwrap(x.nonce) + 3);\n    }\n\n    function Test3(uint n) public pure returns (uint) {\n      Book memory bookIndex;\n      bookIndex.nonce = Nonce.wrap(7);\n      for (uint i=0;i<n;i++) {\n         NextBookNonce(bookIndex);\n      }   \n      return Nonce.unwrap(bookIndex.nonce);\n    }\n\n    error ZeroAddress();\n    error ZeroAmount();\n    uint constant ZeroAddressFlag = 1;\n    uint constant ZeroAmountFlag = 2;\n\n    function process(address[] memory a, uint[] memory amount) public pure returns (uint){\n        uint error;\n        uint total;\n        for (uint i=0;i<a.length;i++) {\n            if (a[i] == address(0)) error |= ZeroAddressFlag;\n            if (amount[i] == 0) error |= ZeroAmountFlag;\n            total += amount[i];\n        }\n        if (error == ZeroAddressFlag) revert ZeroAddress();\n        if (error == ZeroAmountFlag)  revert ZeroAmount();\n        return total;\n    }\n\n    function Test4(uint n) public pure returns (uint) {\n        address[] memory a = new address[](n+1);\n        for (uint i=0;i<=n;i++) {\n            a[i] = address(uint160(i));\n        }\n        uint[] memory amount = new uint[](n+1);\n        for (uint i=0;i<=n;i++) {\n            amount[i] = i;\n        }    \n        return process(a,amount);\n    }\n\n    uint public totalMinted;\n    uint constant maxMinted = 100;\n    event minted(uint totalMinted,uint currentMint);\n\n    modifier checkInvariants() {\n        require(!paused, \"Paused\");\n        _;\n        invariantCheck();\n        require(!paused, \"Paused\");\n    }\n    \n    function invariantCheck() public {\n        if (totalMinted > maxMinted) // this may never happen\n            pause();\n    }\n\n    bool public paused;\n    function pause() public {  \n        paused = true;\n    }\n    function unpause() public onlyOwner {\n        paused = false;\n    }\n\n    function Test5( uint n) public checkInvariants(){\n        totalMinted += n;\n        emit minted(n,totalMinted);\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Result of `encodePacked` is deterministic"
      },
      {
        "choice": "B",
        "answer": "`abi.decode` always succeeds"
      },
      {
        "choice": "C",
        "answer": "It calls function `Test1()` without any problem"
      },
      {
        "choice": "D",
        "answer": "It should use `uint256` instead of `uint` \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "C"
    ],
    "race": "RACE-10.md"
  },
  {
    "question": "3] Which statements are true in `NextBookNonce()`?",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TestContract is Ownable {\n   \n    function Test1(uint n) external pure returns(uint) {\n        return n + abi.decode(msg.data[msg.data.length-64:], (uint));\n    }\n\n    function Test2(uint n) public view returns(uint) {\n        bytes memory fcall = abi.encodeCall(TestContract.Test1,(n));\n        bytes memory xtr = abi.encodePacked(uint(4),uint(5));\n        bytes memory all = bytes.concat(fcall,xtr);\n        (bool success, bytes memory data) = address(this).staticcall(all);\n        return abi.decode(data,(uint));\n    } \n\n    type Nonce is uint256;\n    struct Book { Nonce nonce;}\n    \n    function NextBookNonce(Book memory x) public pure {\n       x.nonce = Nonce.wrap(Nonce.unwrap(x.nonce) + 3);\n    }\n\n    function Test3(uint n) public pure returns (uint) {\n      Book memory bookIndex;\n      bookIndex.nonce = Nonce.wrap(7);\n      for (uint i=0;i<n;i++) {\n         NextBookNonce(bookIndex);\n      }   \n      return Nonce.unwrap(bookIndex.nonce);\n    }\n\n    error ZeroAddress();\n    error ZeroAmount();\n    uint constant ZeroAddressFlag = 1;\n    uint constant ZeroAmountFlag = 2;\n\n    function process(address[] memory a, uint[] memory amount) public pure returns (uint){\n        uint error;\n        uint total;\n        for (uint i=0;i<a.length;i++) {\n            if (a[i] == address(0)) error |= ZeroAddressFlag;\n            if (amount[i] == 0) error |= ZeroAmountFlag;\n            total += amount[i];\n        }\n        if (error == ZeroAddressFlag) revert ZeroAddress();\n        if (error == ZeroAmountFlag)  revert ZeroAmount();\n        return total;\n    }\n\n    function Test4(uint n) public pure returns (uint) {\n        address[] memory a = new address[](n+1);\n        for (uint i=0;i<=n;i++) {\n            a[i] = address(uint160(i));\n        }\n        uint[] memory amount = new uint[](n+1);\n        for (uint i=0;i<=n;i++) {\n            amount[i] = i;\n        }    \n        return process(a,amount);\n    }\n\n    uint public totalMinted;\n    uint constant maxMinted = 100;\n    event minted(uint totalMinted,uint currentMint);\n\n    modifier checkInvariants() {\n        require(!paused, \"Paused\");\n        _;\n        invariantCheck();\n        require(!paused, \"Paused\");\n    }\n    \n    function invariantCheck() public {\n        if (totalMinted > maxMinted) // this may never happen\n            pause();\n    }\n\n    bool public paused;\n    function pause() public {  \n        paused = true;\n    }\n    function unpause() public onlyOwner {\n        paused = false;\n    }\n\n    function Test5( uint n) public checkInvariants(){\n        totalMinted += n;\n        emit minted(n,totalMinted);\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "`wrap` and `unwrap` cost additional gas"
      },
      {
        "choice": "B",
        "answer": "It is safe to use `unchecked`"
      },
      {
        "choice": "C",
        "answer": "There is something suspicious about the increment value"
      },
      {
        "choice": "D",
        "answer": "It could have used `x.nonce++` \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C"
    ],
    "race": "RACE-10.md"
  },
  {
    "question": "4] Which statements are true in `Test3()`?",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TestContract is Ownable {\n   \n    function Test1(uint n) external pure returns(uint) {\n        return n + abi.decode(msg.data[msg.data.length-64:], (uint));\n    }\n\n    function Test2(uint n) public view returns(uint) {\n        bytes memory fcall = abi.encodeCall(TestContract.Test1,(n));\n        bytes memory xtr = abi.encodePacked(uint(4),uint(5));\n        bytes memory all = bytes.concat(fcall,xtr);\n        (bool success, bytes memory data) = address(this).staticcall(all);\n        return abi.decode(data,(uint));\n    } \n\n    type Nonce is uint256;\n    struct Book { Nonce nonce;}\n    \n    function NextBookNonce(Book memory x) public pure {\n       x.nonce = Nonce.wrap(Nonce.unwrap(x.nonce) + 3);\n    }\n\n    function Test3(uint n) public pure returns (uint) {\n      Book memory bookIndex;\n      bookIndex.nonce = Nonce.wrap(7);\n      for (uint i=0;i<n;i++) {\n         NextBookNonce(bookIndex);\n      }   \n      return Nonce.unwrap(bookIndex.nonce);\n    }\n\n    error ZeroAddress();\n    error ZeroAmount();\n    uint constant ZeroAddressFlag = 1;\n    uint constant ZeroAmountFlag = 2;\n\n    function process(address[] memory a, uint[] memory amount) public pure returns (uint){\n        uint error;\n        uint total;\n        for (uint i=0;i<a.length;i++) {\n            if (a[i] == address(0)) error |= ZeroAddressFlag;\n            if (amount[i] == 0) error |= ZeroAmountFlag;\n            total += amount[i];\n        }\n        if (error == ZeroAddressFlag) revert ZeroAddress();\n        if (error == ZeroAmountFlag)  revert ZeroAmount();\n        return total;\n    }\n\n    function Test4(uint n) public pure returns (uint) {\n        address[] memory a = new address[](n+1);\n        for (uint i=0;i<=n;i++) {\n            a[i] = address(uint160(i));\n        }\n        uint[] memory amount = new uint[](n+1);\n        for (uint i=0;i<=n;i++) {\n            amount[i] = i;\n        }    \n        return process(a,amount);\n    }\n\n    uint public totalMinted;\n    uint constant maxMinted = 100;\n    event minted(uint totalMinted,uint currentMint);\n\n    modifier checkInvariants() {\n        require(!paused, \"Paused\");\n        _;\n        invariantCheck();\n        require(!paused, \"Paused\");\n    }\n    \n    function invariantCheck() public {\n        if (totalMinted > maxMinted) // this may never happen\n            pause();\n    }\n\n    bool public paused;\n    function pause() public {  \n        paused = true;\n    }\n    function unpause() public onlyOwner {\n        paused = false;\n    }\n\n    function Test5( uint n) public checkInvariants(){\n        totalMinted += n;\n        emit minted(n,totalMinted);\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "``bookIndex.nonce`` is incremented in the loop"
      },
      {
        "choice": "B",
        "answer": "``bookIndex.nonce`` cannot be incremented because `NextBookNonce` is `pure`"
      },
      {
        "choice": "C",
        "answer": "``i++`` can be made `unchecked`"
      },
      {
        "choice": "D",
        "answer": "``memory`` can be changed to `storage` without any other changes \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "C"
    ],
    "race": "RACE-10.md"
  },
  {
    "question": "5] Which statements are true In `Test4()`?",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TestContract is Ownable {\n   \n    function Test1(uint n) external pure returns(uint) {\n        return n + abi.decode(msg.data[msg.data.length-64:], (uint));\n    }\n\n    function Test2(uint n) public view returns(uint) {\n        bytes memory fcall = abi.encodeCall(TestContract.Test1,(n));\n        bytes memory xtr = abi.encodePacked(uint(4),uint(5));\n        bytes memory all = bytes.concat(fcall,xtr);\n        (bool success, bytes memory data) = address(this).staticcall(all);\n        return abi.decode(data,(uint));\n    } \n\n    type Nonce is uint256;\n    struct Book { Nonce nonce;}\n    \n    function NextBookNonce(Book memory x) public pure {\n       x.nonce = Nonce.wrap(Nonce.unwrap(x.nonce) + 3);\n    }\n\n    function Test3(uint n) public pure returns (uint) {\n      Book memory bookIndex;\n      bookIndex.nonce = Nonce.wrap(7);\n      for (uint i=0;i<n;i++) {\n         NextBookNonce(bookIndex);\n      }   \n      return Nonce.unwrap(bookIndex.nonce);\n    }\n\n    error ZeroAddress();\n    error ZeroAmount();\n    uint constant ZeroAddressFlag = 1;\n    uint constant ZeroAmountFlag = 2;\n\n    function process(address[] memory a, uint[] memory amount) public pure returns (uint){\n        uint error;\n        uint total;\n        for (uint i=0;i<a.length;i++) {\n            if (a[i] == address(0)) error |= ZeroAddressFlag;\n            if (amount[i] == 0) error |= ZeroAmountFlag;\n            total += amount[i];\n        }\n        if (error == ZeroAddressFlag) revert ZeroAddress();\n        if (error == ZeroAmountFlag)  revert ZeroAmount();\n        return total;\n    }\n\n    function Test4(uint n) public pure returns (uint) {\n        address[] memory a = new address[](n+1);\n        for (uint i=0;i<=n;i++) {\n            a[i] = address(uint160(i));\n        }\n        uint[] memory amount = new uint[](n+1);\n        for (uint i=0;i<=n;i++) {\n            amount[i] = i;\n        }    \n        return process(a,amount);\n    }\n\n    uint public totalMinted;\n    uint constant maxMinted = 100;\n    event minted(uint totalMinted,uint currentMint);\n\n    modifier checkInvariants() {\n        require(!paused, \"Paused\");\n        _;\n        invariantCheck();\n        require(!paused, \"Paused\");\n    }\n    \n    function invariantCheck() public {\n        if (totalMinted > maxMinted) // this may never happen\n            pause();\n    }\n\n    bool public paused;\n    function pause() public {  \n        paused = true;\n    }\n    function unpause() public onlyOwner {\n        paused = false;\n    }\n\n    function Test5( uint n) public checkInvariants(){\n        totalMinted += n;\n        emit minted(n,totalMinted);\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The function always reverts with ``ZeroAddress()``"
      },
      {
        "choice": "B",
        "answer": "The function always reverts with ``ZeroAmount()``"
      },
      {
        "choice": "C",
        "answer": "The function never reverts with ``ZeroAddress()``"
      },
      {
        "choice": "D",
        "answer": "The function never reverts with ``ZeroAmount()`` \n \n \n"
      }
    ],
    "correctAnswers": [
      "C",
      "D"
    ],
    "race": "RACE-10.md"
  },
  {
    "question": "6] Which statements are true in `Test5()`?",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TestContract is Ownable {\n   \n    function Test1(uint n) external pure returns(uint) {\n        return n + abi.decode(msg.data[msg.data.length-64:], (uint));\n    }\n\n    function Test2(uint n) public view returns(uint) {\n        bytes memory fcall = abi.encodeCall(TestContract.Test1,(n));\n        bytes memory xtr = abi.encodePacked(uint(4),uint(5));\n        bytes memory all = bytes.concat(fcall,xtr);\n        (bool success, bytes memory data) = address(this).staticcall(all);\n        return abi.decode(data,(uint));\n    } \n\n    type Nonce is uint256;\n    struct Book { Nonce nonce;}\n    \n    function NextBookNonce(Book memory x) public pure {\n       x.nonce = Nonce.wrap(Nonce.unwrap(x.nonce) + 3);\n    }\n\n    function Test3(uint n) public pure returns (uint) {\n      Book memory bookIndex;\n      bookIndex.nonce = Nonce.wrap(7);\n      for (uint i=0;i<n;i++) {\n         NextBookNonce(bookIndex);\n      }   \n      return Nonce.unwrap(bookIndex.nonce);\n    }\n\n    error ZeroAddress();\n    error ZeroAmount();\n    uint constant ZeroAddressFlag = 1;\n    uint constant ZeroAmountFlag = 2;\n\n    function process(address[] memory a, uint[] memory amount) public pure returns (uint){\n        uint error;\n        uint total;\n        for (uint i=0;i<a.length;i++) {\n            if (a[i] == address(0)) error |= ZeroAddressFlag;\n            if (amount[i] == 0) error |= ZeroAmountFlag;\n            total += amount[i];\n        }\n        if (error == ZeroAddressFlag) revert ZeroAddress();\n        if (error == ZeroAmountFlag)  revert ZeroAmount();\n        return total;\n    }\n\n    function Test4(uint n) public pure returns (uint) {\n        address[] memory a = new address[](n+1);\n        for (uint i=0;i<=n;i++) {\n            a[i] = address(uint160(i));\n        }\n        uint[] memory amount = new uint[](n+1);\n        for (uint i=0;i<=n;i++) {\n            amount[i] = i;\n        }    \n        return process(a,amount);\n    }\n\n    uint public totalMinted;\n    uint constant maxMinted = 100;\n    event minted(uint totalMinted,uint currentMint);\n\n    modifier checkInvariants() {\n        require(!paused, \"Paused\");\n        _;\n        invariantCheck();\n        require(!paused, \"Paused\");\n    }\n    \n    function invariantCheck() public {\n        if (totalMinted > maxMinted) // this may never happen\n            pause();\n    }\n\n    bool public paused;\n    function pause() public {  \n        paused = true;\n    }\n    function unpause() public onlyOwner {\n        paused = false;\n    }\n\n    function Test5( uint n) public checkInvariants(){\n        totalMinted += n;\n        emit minted(n,totalMinted);\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "modifier ``checkInvariants`` will pause the contract if too much is minted"
      },
      {
        "choice": "B",
        "answer": "modifier ``checkInvariants`` will never pause the contract"
      },
      {
        "choice": "C",
        "answer": "modifier ``checkInvariants`` will always pause the contract"
      },
      {
        "choice": "D",
        "answer": "There are more efficient ways to handle the require \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "D"
    ],
    "race": "RACE-10.md"
  },
  {
    "question": "7] Which statements are true about the owner?",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TestContract is Ownable {\n   \n    function Test1(uint n) external pure returns(uint) {\n        return n + abi.decode(msg.data[msg.data.length-64:], (uint));\n    }\n\n    function Test2(uint n) public view returns(uint) {\n        bytes memory fcall = abi.encodeCall(TestContract.Test1,(n));\n        bytes memory xtr = abi.encodePacked(uint(4),uint(5));\n        bytes memory all = bytes.concat(fcall,xtr);\n        (bool success, bytes memory data) = address(this).staticcall(all);\n        return abi.decode(data,(uint));\n    } \n\n    type Nonce is uint256;\n    struct Book { Nonce nonce;}\n    \n    function NextBookNonce(Book memory x) public pure {\n       x.nonce = Nonce.wrap(Nonce.unwrap(x.nonce) + 3);\n    }\n\n    function Test3(uint n) public pure returns (uint) {\n      Book memory bookIndex;\n      bookIndex.nonce = Nonce.wrap(7);\n      for (uint i=0;i<n;i++) {\n         NextBookNonce(bookIndex);\n      }   \n      return Nonce.unwrap(bookIndex.nonce);\n    }\n\n    error ZeroAddress();\n    error ZeroAmount();\n    uint constant ZeroAddressFlag = 1;\n    uint constant ZeroAmountFlag = 2;\n\n    function process(address[] memory a, uint[] memory amount) public pure returns (uint){\n        uint error;\n        uint total;\n        for (uint i=0;i<a.length;i++) {\n            if (a[i] == address(0)) error |= ZeroAddressFlag;\n            if (amount[i] == 0) error |= ZeroAmountFlag;\n            total += amount[i];\n        }\n        if (error == ZeroAddressFlag) revert ZeroAddress();\n        if (error == ZeroAmountFlag)  revert ZeroAmount();\n        return total;\n    }\n\n    function Test4(uint n) public pure returns (uint) {\n        address[] memory a = new address[](n+1);\n        for (uint i=0;i<=n;i++) {\n            a[i] = address(uint160(i));\n        }\n        uint[] memory amount = new uint[](n+1);\n        for (uint i=0;i<=n;i++) {\n            amount[i] = i;\n        }    \n        return process(a,amount);\n    }\n\n    uint public totalMinted;\n    uint constant maxMinted = 100;\n    event minted(uint totalMinted,uint currentMint);\n\n    modifier checkInvariants() {\n        require(!paused, \"Paused\");\n        _;\n        invariantCheck();\n        require(!paused, \"Paused\");\n    }\n    \n    function invariantCheck() public {\n        if (totalMinted > maxMinted) // this may never happen\n            pause();\n    }\n\n    bool public paused;\n    function pause() public {  \n        paused = true;\n    }\n    function unpause() public onlyOwner {\n        paused = false;\n    }\n\n    function Test5( uint n) public checkInvariants(){\n        totalMinted += n;\n        emit minted(n,totalMinted);\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The owner is initialized"
      },
      {
        "choice": "B",
        "answer": "The owner is not initialized"
      },
      {
        "choice": "C",
        "answer": "The owner cannot be changed"
      },
      {
        "choice": "D",
        "answer": "The owner can be changed \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "D"
    ],
    "race": "RACE-10.md"
  },
  {
    "question": "8] Which statements are true In `Test5()` and related functions?",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TestContract is Ownable {\n   \n    function Test1(uint n) external pure returns(uint) {\n        return n + abi.decode(msg.data[msg.data.length-64:], (uint));\n    }\n\n    function Test2(uint n) public view returns(uint) {\n        bytes memory fcall = abi.encodeCall(TestContract.Test1,(n));\n        bytes memory xtr = abi.encodePacked(uint(4),uint(5));\n        bytes memory all = bytes.concat(fcall,xtr);\n        (bool success, bytes memory data) = address(this).staticcall(all);\n        return abi.decode(data,(uint));\n    } \n\n    type Nonce is uint256;\n    struct Book { Nonce nonce;}\n    \n    function NextBookNonce(Book memory x) public pure {\n       x.nonce = Nonce.wrap(Nonce.unwrap(x.nonce) + 3);\n    }\n\n    function Test3(uint n) public pure returns (uint) {\n      Book memory bookIndex;\n      bookIndex.nonce = Nonce.wrap(7);\n      for (uint i=0;i<n;i++) {\n         NextBookNonce(bookIndex);\n      }   \n      return Nonce.unwrap(bookIndex.nonce);\n    }\n\n    error ZeroAddress();\n    error ZeroAmount();\n    uint constant ZeroAddressFlag = 1;\n    uint constant ZeroAmountFlag = 2;\n\n    function process(address[] memory a, uint[] memory amount) public pure returns (uint){\n        uint error;\n        uint total;\n        for (uint i=0;i<a.length;i++) {\n            if (a[i] == address(0)) error |= ZeroAddressFlag;\n            if (amount[i] == 0) error |= ZeroAmountFlag;\n            total += amount[i];\n        }\n        if (error == ZeroAddressFlag) revert ZeroAddress();\n        if (error == ZeroAmountFlag)  revert ZeroAmount();\n        return total;\n    }\n\n    function Test4(uint n) public pure returns (uint) {\n        address[] memory a = new address[](n+1);\n        for (uint i=0;i<=n;i++) {\n            a[i] = address(uint160(i));\n        }\n        uint[] memory amount = new uint[](n+1);\n        for (uint i=0;i<=n;i++) {\n            amount[i] = i;\n        }    \n        return process(a,amount);\n    }\n\n    uint public totalMinted;\n    uint constant maxMinted = 100;\n    event minted(uint totalMinted,uint currentMint);\n\n    modifier checkInvariants() {\n        require(!paused, \"Paused\");\n        _;\n        invariantCheck();\n        require(!paused, \"Paused\");\n    }\n    \n    function invariantCheck() public {\n        if (totalMinted > maxMinted) // this may never happen\n            pause();\n    }\n\n    bool public paused;\n    function pause() public {  \n        paused = true;\n    }\n    function unpause() public onlyOwner {\n        paused = false;\n    }\n\n    function Test5( uint n) public checkInvariants(){\n        totalMinted += n;\n        emit minted(n,totalMinted);\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "``pause`` is unsafe"
      },
      {
        "choice": "B",
        "answer": "``unpause`` is unsafe"
      },
      {
        "choice": "C",
        "answer": "The ``emit`` is done right"
      },
      {
        "choice": "D",
        "answer": "The ``emit`` is done wrong \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "D"
    ],
    "race": "RACE-10.md"
  },
  {
    "question": "2] Which mitigations are applicable to `withdraw()`?",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ncontract Staking {\n\n    using SafeERC20 for IERC20;\n\n    bool internal _paused;\n    address internal _operator;\n    address internal _governance;\n    address internal _token;\n    uint256 internal _minDepositLockTime;\n\n    mapping(address => uint256) _userBalances;\n    mapping(address => uint256) _userLastDeposit;\n\n    event Deposit(\n        address indexed user,\n        uint256 amount\n    );\n\n    event Withdraw(\n        address indexed user,\n        uint256 amount\n    );\n\n    constructor(address operator, address governance, address token, uint256 minDepositLockTime) {\n        _operator = operator;\n        _governance = governance;\n        _token = token;\n        _minDepositLockTime = minDepositLockTime;\n    }\n\n    function depositFor(address user, uint256 amount) external {\n        _userBalances[user] += amount;\n        _userLastDeposit[user] = block.timestamp;\n        \n        IERC20(_token).safeTransferFrom(user, address(this), amount);\n        \n        emit Deposit(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(!_paused, 'paused');\n        require(block.timestamp >= _userLastDeposit[msg.sender] + _minDepositLockTime, 'too early');\n\n        IERC20(_token).safeTransferFrom(address(this), msg.sender, amount);\n\n        if (_userBalances[msg.sender] >= amount) {\n            _userBalances[msg.sender] -= amount;\n        } else {\n            _userBalances[msg.sender] = 0;\n        }\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function pause() external {\n        // operator or gov\n        require(msg.sender == _operator && msg.sender == _governance, 'unauthorized');\n        \n        _paused = true;\n    }\n\n    function unpause() external {\n        // only gov\n        require(msg.sender == _governance, 'unauthorized');\n\n        _paused = false;\n    }\n    \n    function changeGovernance(address governance) external {\n        _governance = governance;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Transferred amount should be minimum of `amount` and `_userBalances[msg.sender]`"
      },
      {
        "choice": "B",
        "answer": "Move if/else block before `safeTransferFrom`"
      },
      {
        "choice": "C",
        "answer": "Require `amount` to be <= users balance deposited earlier"
      },
      {
        "choice": "D",
        "answer": "Remove if/else block and add `_userBalances[msg.sender] -= amount` before `safeTransferFrom` \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "C",
      "D"
    ],
    "race": "RACE-11.md"
  },
  {
    "question": "3] The security concern(s) in `pause()` is/are:",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ncontract Staking {\n\n    using SafeERC20 for IERC20;\n\n    bool internal _paused;\n    address internal _operator;\n    address internal _governance;\n    address internal _token;\n    uint256 internal _minDepositLockTime;\n\n    mapping(address => uint256) _userBalances;\n    mapping(address => uint256) _userLastDeposit;\n\n    event Deposit(\n        address indexed user,\n        uint256 amount\n    );\n\n    event Withdraw(\n        address indexed user,\n        uint256 amount\n    );\n\n    constructor(address operator, address governance, address token, uint256 minDepositLockTime) {\n        _operator = operator;\n        _governance = governance;\n        _token = token;\n        _minDepositLockTime = minDepositLockTime;\n    }\n\n    function depositFor(address user, uint256 amount) external {\n        _userBalances[user] += amount;\n        _userLastDeposit[user] = block.timestamp;\n        \n        IERC20(_token).safeTransferFrom(user, address(this), amount);\n        \n        emit Deposit(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(!_paused, 'paused');\n        require(block.timestamp >= _userLastDeposit[msg.sender] + _minDepositLockTime, 'too early');\n\n        IERC20(_token).safeTransferFrom(address(this), msg.sender, amount);\n\n        if (_userBalances[msg.sender] >= amount) {\n            _userBalances[msg.sender] -= amount;\n        } else {\n            _userBalances[msg.sender] = 0;\n        }\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function pause() external {\n        // operator or gov\n        require(msg.sender == _operator && msg.sender == _governance, 'unauthorized');\n        \n        _paused = true;\n    }\n\n    function unpause() external {\n        // only gov\n        require(msg.sender == _governance, 'unauthorized');\n\n        _paused = false;\n    }\n    \n    function changeGovernance(address governance) external {\n        _governance = governance;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Does not emit an event"
      },
      {
        "choice": "B",
        "answer": "Access control is not strict enough"
      },
      {
        "choice": "C",
        "answer": "Will always revert"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "race": "RACE-11.md"
  },
  {
    "question": "4] Which statement(s) is/are true for `unpause()`?",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ncontract Staking {\n\n    using SafeERC20 for IERC20;\n\n    bool internal _paused;\n    address internal _operator;\n    address internal _governance;\n    address internal _token;\n    uint256 internal _minDepositLockTime;\n\n    mapping(address => uint256) _userBalances;\n    mapping(address => uint256) _userLastDeposit;\n\n    event Deposit(\n        address indexed user,\n        uint256 amount\n    );\n\n    event Withdraw(\n        address indexed user,\n        uint256 amount\n    );\n\n    constructor(address operator, address governance, address token, uint256 minDepositLockTime) {\n        _operator = operator;\n        _governance = governance;\n        _token = token;\n        _minDepositLockTime = minDepositLockTime;\n    }\n\n    function depositFor(address user, uint256 amount) external {\n        _userBalances[user] += amount;\n        _userLastDeposit[user] = block.timestamp;\n        \n        IERC20(_token).safeTransferFrom(user, address(this), amount);\n        \n        emit Deposit(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(!_paused, 'paused');\n        require(block.timestamp >= _userLastDeposit[msg.sender] + _minDepositLockTime, 'too early');\n\n        IERC20(_token).safeTransferFrom(address(this), msg.sender, amount);\n\n        if (_userBalances[msg.sender] >= amount) {\n            _userBalances[msg.sender] -= amount;\n        } else {\n            _userBalances[msg.sender] = 0;\n        }\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function pause() external {\n        // operator or gov\n        require(msg.sender == _operator && msg.sender == _governance, 'unauthorized');\n        \n        _paused = true;\n    }\n\n    function unpause() external {\n        // only gov\n        require(msg.sender == _governance, 'unauthorized');\n\n        _paused = false;\n    }\n    \n    function changeGovernance(address governance) external {\n        _governance = governance;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Will unpause deposits and withdrawals"
      },
      {
        "choice": "B",
        "answer": "Will unpause withdrawals only"
      },
      {
        "choice": "C",
        "answer": "Anyone can successfully call the function"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C"
    ],
    "race": "RACE-11.md"
  },
  {
    "question": "5] Which statement(s) is/are true in `depositFor()`?",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ncontract Staking {\n\n    using SafeERC20 for IERC20;\n\n    bool internal _paused;\n    address internal _operator;\n    address internal _governance;\n    address internal _token;\n    uint256 internal _minDepositLockTime;\n\n    mapping(address => uint256) _userBalances;\n    mapping(address => uint256) _userLastDeposit;\n\n    event Deposit(\n        address indexed user,\n        uint256 amount\n    );\n\n    event Withdraw(\n        address indexed user,\n        uint256 amount\n    );\n\n    constructor(address operator, address governance, address token, uint256 minDepositLockTime) {\n        _operator = operator;\n        _governance = governance;\n        _token = token;\n        _minDepositLockTime = minDepositLockTime;\n    }\n\n    function depositFor(address user, uint256 amount) external {\n        _userBalances[user] += amount;\n        _userLastDeposit[user] = block.timestamp;\n        \n        IERC20(_token).safeTransferFrom(user, address(this), amount);\n        \n        emit Deposit(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(!_paused, 'paused');\n        require(block.timestamp >= _userLastDeposit[msg.sender] + _minDepositLockTime, 'too early');\n\n        IERC20(_token).safeTransferFrom(address(this), msg.sender, amount);\n\n        if (_userBalances[msg.sender] >= amount) {\n            _userBalances[msg.sender] -= amount;\n        } else {\n            _userBalances[msg.sender] = 0;\n        }\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function pause() external {\n        // operator or gov\n        require(msg.sender == _operator && msg.sender == _governance, 'unauthorized');\n        \n        _paused = true;\n    }\n\n    function unpause() external {\n        // only gov\n        require(msg.sender == _governance, 'unauthorized');\n\n        _paused = false;\n    }\n    \n    function changeGovernance(address governance) external {\n        _governance = governance;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Can be executed when contract is paused"
      },
      {
        "choice": "B",
        "answer": "Allows a user to deposit for another user"
      },
      {
        "choice": "C",
        "answer": "Allows a user to fund the deposit for another user"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B"
    ],
    "race": "RACE-11.md"
  },
  {
    "question": "6] The issue(s) in `depositFor()` is/are:",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ncontract Staking {\n\n    using SafeERC20 for IERC20;\n\n    bool internal _paused;\n    address internal _operator;\n    address internal _governance;\n    address internal _token;\n    uint256 internal _minDepositLockTime;\n\n    mapping(address => uint256) _userBalances;\n    mapping(address => uint256) _userLastDeposit;\n\n    event Deposit(\n        address indexed user,\n        uint256 amount\n    );\n\n    event Withdraw(\n        address indexed user,\n        uint256 amount\n    );\n\n    constructor(address operator, address governance, address token, uint256 minDepositLockTime) {\n        _operator = operator;\n        _governance = governance;\n        _token = token;\n        _minDepositLockTime = minDepositLockTime;\n    }\n\n    function depositFor(address user, uint256 amount) external {\n        _userBalances[user] += amount;\n        _userLastDeposit[user] = block.timestamp;\n        \n        IERC20(_token).safeTransferFrom(user, address(this), amount);\n        \n        emit Deposit(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(!_paused, 'paused');\n        require(block.timestamp >= _userLastDeposit[msg.sender] + _minDepositLockTime, 'too early');\n\n        IERC20(_token).safeTransferFrom(address(this), msg.sender, amount);\n\n        if (_userBalances[msg.sender] >= amount) {\n            _userBalances[msg.sender] -= amount;\n        } else {\n            _userBalances[msg.sender] = 0;\n        }\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function pause() external {\n        // operator or gov\n        require(msg.sender == _operator && msg.sender == _governance, 'unauthorized');\n        \n        _paused = true;\n    }\n\n    function unpause() external {\n        // only gov\n        require(msg.sender == _governance, 'unauthorized');\n\n        _paused = false;\n    }\n    \n    function changeGovernance(address governance) external {\n        _governance = governance;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Cannot be paused for emergency"
      },
      {
        "choice": "B",
        "answer": "Exploitable re-entrancy attack"
      },
      {
        "choice": "C",
        "answer": "User withdrawals can be delayed indefinitely via DoS attack"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "C"
    ],
    "race": "RACE-11.md"
  },
  {
    "question": "7] Which of the following statement(s) is/are true?",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ncontract Staking {\n\n    using SafeERC20 for IERC20;\n\n    bool internal _paused;\n    address internal _operator;\n    address internal _governance;\n    address internal _token;\n    uint256 internal _minDepositLockTime;\n\n    mapping(address => uint256) _userBalances;\n    mapping(address => uint256) _userLastDeposit;\n\n    event Deposit(\n        address indexed user,\n        uint256 amount\n    );\n\n    event Withdraw(\n        address indexed user,\n        uint256 amount\n    );\n\n    constructor(address operator, address governance, address token, uint256 minDepositLockTime) {\n        _operator = operator;\n        _governance = governance;\n        _token = token;\n        _minDepositLockTime = minDepositLockTime;\n    }\n\n    function depositFor(address user, uint256 amount) external {\n        _userBalances[user] += amount;\n        _userLastDeposit[user] = block.timestamp;\n        \n        IERC20(_token).safeTransferFrom(user, address(this), amount);\n        \n        emit Deposit(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(!_paused, 'paused');\n        require(block.timestamp >= _userLastDeposit[msg.sender] + _minDepositLockTime, 'too early');\n\n        IERC20(_token).safeTransferFrom(address(this), msg.sender, amount);\n\n        if (_userBalances[msg.sender] >= amount) {\n            _userBalances[msg.sender] -= amount;\n        } else {\n            _userBalances[msg.sender] = 0;\n        }\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function pause() external {\n        // operator or gov\n        require(msg.sender == _operator && msg.sender == _governance, 'unauthorized');\n        \n        _paused = true;\n    }\n\n    function unpause() external {\n        // only gov\n        require(msg.sender == _governance, 'unauthorized');\n\n        _paused = false;\n    }\n    \n    function changeGovernance(address governance) external {\n        _governance = governance;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "`Withdraw` event is emitted with incorrect amount"
      },
      {
        "choice": "B",
        "answer": "`Withdraw` event is emitted with correct user"
      },
      {
        "choice": "C",
        "answer": "`Deposit` event is always emitted incorrectly"
      },
      {
        "choice": "D",
        "answer": "`Deposit` event is emitted with incorrect user \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "D"
    ],
    "race": "RACE-11.md"
  },
  {
    "question": "8] Potential gas optimization(s) is/are:",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ncontract Staking {\n\n    using SafeERC20 for IERC20;\n\n    bool internal _paused;\n    address internal _operator;\n    address internal _governance;\n    address internal _token;\n    uint256 internal _minDepositLockTime;\n\n    mapping(address => uint256) _userBalances;\n    mapping(address => uint256) _userLastDeposit;\n\n    event Deposit(\n        address indexed user,\n        uint256 amount\n    );\n\n    event Withdraw(\n        address indexed user,\n        uint256 amount\n    );\n\n    constructor(address operator, address governance, address token, uint256 minDepositLockTime) {\n        _operator = operator;\n        _governance = governance;\n        _token = token;\n        _minDepositLockTime = minDepositLockTime;\n    }\n\n    function depositFor(address user, uint256 amount) external {\n        _userBalances[user] += amount;\n        _userLastDeposit[user] = block.timestamp;\n        \n        IERC20(_token).safeTransferFrom(user, address(this), amount);\n        \n        emit Deposit(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(!_paused, 'paused');\n        require(block.timestamp >= _userLastDeposit[msg.sender] + _minDepositLockTime, 'too early');\n\n        IERC20(_token).safeTransferFrom(address(this), msg.sender, amount);\n\n        if (_userBalances[msg.sender] >= amount) {\n            _userBalances[msg.sender] -= amount;\n        } else {\n            _userBalances[msg.sender] = 0;\n        }\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function pause() external {\n        // operator or gov\n        require(msg.sender == _operator && msg.sender == _governance, 'unauthorized');\n        \n        _paused = true;\n    }\n\n    function unpause() external {\n        // only gov\n        require(msg.sender == _governance, 'unauthorized');\n\n        _paused = false;\n    }\n    \n    function changeGovernance(address governance) external {\n        _governance = governance;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Use `immutable` for all variables assigned in constructor"
      },
      {
        "choice": "B",
        "answer": "Use `immutable` for `_token`, `_operator` and `_minDepositLockTime`"
      },
      {
        "choice": "C",
        "answer": "Use `unchecked`"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C"
    ],
    "race": "RACE-11.md"
  },
  {
    "question": "2] What would a caller with `MIGRATOR_ROLE` permission be capable of?",
    "context": "**Note**: All 8 questions in this RACE are based on the below contracts. This is the same contracts you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract TokenV1 is ERC20, AccessControl {\n    bytes32 MIGRATOR_ROLE = keccak256(\"MIGRATOR_ROLE\");\n\n    constructor() ERC20(\"Token\", \"TKN\") {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // Spec wasn't clear about what 'admin functions' need to be capable of.\n    // Well, this should do the trick.\n    fallback() external {\n        if (hasRole(MIGRATOR_ROLE, msg.sender)) {\n            (bool success, bytes memory data) = msg.sender.delegatecall(msg.data);\n            require(success, \"MIGRATION CALL FAILED\");\n            assembly {\n                return(add(data, 32), mload(data))\n            }\n        }\n    }\n}\n\ninterface IEERC20 is IERC20, IERC20Permit {}\ncontract Vault {\n    address public UNDERLYING;\n    mapping(address => uint256) public balances;\n\n    constructor(address token)  {\n        UNDERLYING = token;\n    }\n\n    function deposit(uint256 amount) external {\n        IEERC20(UNDERLYING).transferFrom(msg.sender, address(this), amount);\n        balances[msg.sender] += amount;\n    }\n\n    function depositWithPermit(address target, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s, address to) external {\n        IEERC20(UNDERLYING).permit(target, address(this), amount, deadline, v, r, s);\n        IEERC20(UNDERLYING).transferFrom(target, address(this), amount);\n        balances[to] += amount;\n    }\n\n    function withdraw(uint256 amount) external {\n        IEERC20(UNDERLYING).transfer(msg.sender, amount);\n        balances[msg.sender] -= amount;\n    }\n\n    function sweep(address token) external {\n        require(UNDERLYING != token, \"can't sweep underlying\");\n        IEERC20(token).transfer(msg.sender, IEERC20(token).balanceOf(address(this)));\n    }\n}\n\n/* ... some time later ... */\n\n// Adding permit() while maintaining old token balances.\ncontract TokenV2 {\n    address private immutable TOKEN_V1;\n    address private immutable PERMIT_MODULE;\n\n    constructor(address _tokenV1)  {\n        TOKEN_V1 = _tokenV1;\n        PERMIT_MODULE = address(new PermitModule());\n    }\n\n    // Abusing migrations as proxy.\n    fallback() external {\n        (\n            bool success,\n            bytes memory data\n        ) = (address(this) != TOKEN_V1)\n          ? TOKEN_V1.call(abi.encodePacked(hex\"00000000\", msg.data, msg.sender))\n          : PERMIT_MODULE.delegatecall(msg.data[4:]);\n        require(success, \"FORWARDING CALL FAILED\");\n        assembly {\n            return(add(data, 32), mload(data))\n        }\n    }\n}\ncontract PermitModule is TokenV1, ERC20Permit {\n    constructor() TokenV1() ERC20Permit(\"Token\") {}\n    function _msgSender() internal view virtual override returns (address) {\n        if (address(this).code.length == 0) return super._msgSender(); // normal context during construction\n        return address(uint160(bytes20(msg.data[msg.data.length-20:msg.data.length])));\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Manipulating TokenV1's storage"
      },
      {
        "choice": "B",
        "answer": "Deleting TokenV1's stored bytecode"
      },
      {
        "choice": "C",
        "answer": "Changing TokenV1's stored bytecode to something different"
      },
      {
        "choice": "D",
        "answer": "With the current code it's not possible for anyone to have `MIGRATOR_ROLE` permission \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B"
    ],
    "race": "RACE-12.md"
  },
  {
    "question": "3] Vault initialized with TokenV1 as underlying",
    "context": "**Note**: All 8 questions in this RACE are based on the below contracts. This is the same contracts you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract TokenV1 is ERC20, AccessControl {\n    bytes32 MIGRATOR_ROLE = keccak256(\"MIGRATOR_ROLE\");\n\n    constructor() ERC20(\"Token\", \"TKN\") {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // Spec wasn't clear about what 'admin functions' need to be capable of.\n    // Well, this should do the trick.\n    fallback() external {\n        if (hasRole(MIGRATOR_ROLE, msg.sender)) {\n            (bool success, bytes memory data) = msg.sender.delegatecall(msg.data);\n            require(success, \"MIGRATION CALL FAILED\");\n            assembly {\n                return(add(data, 32), mload(data))\n            }\n        }\n    }\n}\n\ninterface IEERC20 is IERC20, IERC20Permit {}\ncontract Vault {\n    address public UNDERLYING;\n    mapping(address => uint256) public balances;\n\n    constructor(address token)  {\n        UNDERLYING = token;\n    }\n\n    function deposit(uint256 amount) external {\n        IEERC20(UNDERLYING).transferFrom(msg.sender, address(this), amount);\n        balances[msg.sender] += amount;\n    }\n\n    function depositWithPermit(address target, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s, address to) external {\n        IEERC20(UNDERLYING).permit(target, address(this), amount, deadline, v, r, s);\n        IEERC20(UNDERLYING).transferFrom(target, address(this), amount);\n        balances[to] += amount;\n    }\n\n    function withdraw(uint256 amount) external {\n        IEERC20(UNDERLYING).transfer(msg.sender, amount);\n        balances[msg.sender] -= amount;\n    }\n\n    function sweep(address token) external {\n        require(UNDERLYING != token, \"can't sweep underlying\");\n        IEERC20(token).transfer(msg.sender, IEERC20(token).balanceOf(address(this)));\n    }\n}\n\n/* ... some time later ... */\n\n// Adding permit() while maintaining old token balances.\ncontract TokenV2 {\n    address private immutable TOKEN_V1;\n    address private immutable PERMIT_MODULE;\n\n    constructor(address _tokenV1)  {\n        TOKEN_V1 = _tokenV1;\n        PERMIT_MODULE = address(new PermitModule());\n    }\n\n    // Abusing migrations as proxy.\n    fallback() external {\n        (\n            bool success,\n            bytes memory data\n        ) = (address(this) != TOKEN_V1)\n          ? TOKEN_V1.call(abi.encodePacked(hex\"00000000\", msg.data, msg.sender))\n          : PERMIT_MODULE.delegatecall(msg.data[4:]);\n        require(success, \"FORWARDING CALL FAILED\");\n        assembly {\n            return(add(data, 32), mload(data))\n        }\n    }\n}\ncontract PermitModule is TokenV1, ERC20Permit {\n    constructor() TokenV1() ERC20Permit(\"Token\") {}\n    function _msgSender() internal view virtual override returns (address) {\n        if (address(this).code.length == 0) return super._msgSender(); // normal context during construction\n        return address(uint160(bytes20(msg.data[msg.data.length-20:msg.data.length])));\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Can be drained by re-entering during withdrawal (B): Can be drained during withdrawal due to an integer underflow\n (C): Allows stealing approved tokens due to a phantom (i.e. missing) function\n (D): None of the above\n \n \n \n"
      },
      {
        "choice": "B",
        "answer": "Can be drained during withdrawal due to an integer underflow (C): Allows stealing approved tokens due to a phantom (i.e. missing) function\n (D): None of the above\n \n \n \n"
      },
      {
        "choice": "C",
        "answer": "Allows stealing approved tokens due to a phantom (i.e. missing) function (D): None of the above\n \n \n \n"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-12.md"
  },
  {
    "question": "4] If Vault were to use `safeTransferFrom` instead of `transferFrom` then",
    "context": "**Note**: All 8 questions in this RACE are based on the below contracts. This is the same contracts you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract TokenV1 is ERC20, AccessControl {\n    bytes32 MIGRATOR_ROLE = keccak256(\"MIGRATOR_ROLE\");\n\n    constructor() ERC20(\"Token\", \"TKN\") {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // Spec wasn't clear about what 'admin functions' need to be capable of.\n    // Well, this should do the trick.\n    fallback() external {\n        if (hasRole(MIGRATOR_ROLE, msg.sender)) {\n            (bool success, bytes memory data) = msg.sender.delegatecall(msg.data);\n            require(success, \"MIGRATION CALL FAILED\");\n            assembly {\n                return(add(data, 32), mload(data))\n            }\n        }\n    }\n}\n\ninterface IEERC20 is IERC20, IERC20Permit {}\ncontract Vault {\n    address public UNDERLYING;\n    mapping(address => uint256) public balances;\n\n    constructor(address token)  {\n        UNDERLYING = token;\n    }\n\n    function deposit(uint256 amount) external {\n        IEERC20(UNDERLYING).transferFrom(msg.sender, address(this), amount);\n        balances[msg.sender] += amount;\n    }\n\n    function depositWithPermit(address target, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s, address to) external {\n        IEERC20(UNDERLYING).permit(target, address(this), amount, deadline, v, r, s);\n        IEERC20(UNDERLYING).transferFrom(target, address(this), amount);\n        balances[to] += amount;\n    }\n\n    function withdraw(uint256 amount) external {\n        IEERC20(UNDERLYING).transfer(msg.sender, amount);\n        balances[msg.sender] -= amount;\n    }\n\n    function sweep(address token) external {\n        require(UNDERLYING != token, \"can't sweep underlying\");\n        IEERC20(token).transfer(msg.sender, IEERC20(token).balanceOf(address(this)));\n    }\n}\n\n/* ... some time later ... */\n\n// Adding permit() while maintaining old token balances.\ncontract TokenV2 {\n    address private immutable TOKEN_V1;\n    address private immutable PERMIT_MODULE;\n\n    constructor(address _tokenV1)  {\n        TOKEN_V1 = _tokenV1;\n        PERMIT_MODULE = address(new PermitModule());\n    }\n\n    // Abusing migrations as proxy.\n    fallback() external {\n        (\n            bool success,\n            bytes memory data\n        ) = (address(this) != TOKEN_V1)\n          ? TOKEN_V1.call(abi.encodePacked(hex\"00000000\", msg.data, msg.sender))\n          : PERMIT_MODULE.delegatecall(msg.data[4:]);\n        require(success, \"FORWARDING CALL FAILED\");\n        assembly {\n            return(add(data, 32), mload(data))\n        }\n    }\n}\ncontract PermitModule is TokenV1, ERC20Permit {\n    constructor() TokenV1() ERC20Permit(\"Token\") {}\n    function _msgSender() internal view virtual override returns (address) {\n        if (address(this).code.length == 0) return super._msgSender(); // normal context during construction\n        return address(uint160(bytes20(msg.data[msg.data.length-20:msg.data.length])));\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "It would be able to safely support tokens that don't revert on error"
      },
      {
        "choice": "B",
        "answer": "It would ensure that tokens are only sent to contracts that support handling them"
      },
      {
        "choice": "C",
        "answer": "It would introduce a re-entrancy vulnerability due to receive hooks"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "race": "RACE-12.md"
  },
  {
    "question": "5] Who would need the `MIGRATOR_ROLE` for TokenV2 to function as intended?",
    "context": "**Note**: All 8 questions in this RACE are based on the below contracts. This is the same contracts you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract TokenV1 is ERC20, AccessControl {\n    bytes32 MIGRATOR_ROLE = keccak256(\"MIGRATOR_ROLE\");\n\n    constructor() ERC20(\"Token\", \"TKN\") {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // Spec wasn't clear about what 'admin functions' need to be capable of.\n    // Well, this should do the trick.\n    fallback() external {\n        if (hasRole(MIGRATOR_ROLE, msg.sender)) {\n            (bool success, bytes memory data) = msg.sender.delegatecall(msg.data);\n            require(success, \"MIGRATION CALL FAILED\");\n            assembly {\n                return(add(data, 32), mload(data))\n            }\n        }\n    }\n}\n\ninterface IEERC20 is IERC20, IERC20Permit {}\ncontract Vault {\n    address public UNDERLYING;\n    mapping(address => uint256) public balances;\n\n    constructor(address token)  {\n        UNDERLYING = token;\n    }\n\n    function deposit(uint256 amount) external {\n        IEERC20(UNDERLYING).transferFrom(msg.sender, address(this), amount);\n        balances[msg.sender] += amount;\n    }\n\n    function depositWithPermit(address target, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s, address to) external {\n        IEERC20(UNDERLYING).permit(target, address(this), amount, deadline, v, r, s);\n        IEERC20(UNDERLYING).transferFrom(target, address(this), amount);\n        balances[to] += amount;\n    }\n\n    function withdraw(uint256 amount) external {\n        IEERC20(UNDERLYING).transfer(msg.sender, amount);\n        balances[msg.sender] -= amount;\n    }\n\n    function sweep(address token) external {\n        require(UNDERLYING != token, \"can't sweep underlying\");\n        IEERC20(token).transfer(msg.sender, IEERC20(token).balanceOf(address(this)));\n    }\n}\n\n/* ... some time later ... */\n\n// Adding permit() while maintaining old token balances.\ncontract TokenV2 {\n    address private immutable TOKEN_V1;\n    address private immutable PERMIT_MODULE;\n\n    constructor(address _tokenV1)  {\n        TOKEN_V1 = _tokenV1;\n        PERMIT_MODULE = address(new PermitModule());\n    }\n\n    // Abusing migrations as proxy.\n    fallback() external {\n        (\n            bool success,\n            bytes memory data\n        ) = (address(this) != TOKEN_V1)\n          ? TOKEN_V1.call(abi.encodePacked(hex\"00000000\", msg.data, msg.sender))\n          : PERMIT_MODULE.delegatecall(msg.data[4:]);\n        require(success, \"FORWARDING CALL FAILED\");\n        assembly {\n            return(add(data, 32), mload(data))\n        }\n    }\n}\ncontract PermitModule is TokenV1, ERC20Permit {\n    constructor() TokenV1() ERC20Permit(\"Token\") {}\n    function _msgSender() internal view virtual override returns (address) {\n        if (address(this).code.length == 0) return super._msgSender(); // normal context during construction\n        return address(uint160(bytes20(msg.data[msg.data.length-20:msg.data.length])));\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The deployer of the TokenV2 contract (B): The TokenV1 contract\n (C): The TokenV2 contract\n (D): The PermitModule contract\n \n \n \n"
      },
      {
        "choice": "B",
        "answer": "The TokenV1 contract (C): The TokenV2 contract\n (D): The PermitModule contract\n \n \n \n"
      },
      {
        "choice": "C",
        "answer": "The TokenV2 contract (D): The PermitModule contract\n \n \n \n"
      },
      {
        "choice": "D",
        "answer": "The PermitModule contract \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-12.md"
  },
  {
    "question": "6] With TokenV2 deployed, a Vault initialized with TokenV1 as underlying",
    "context": "**Note**: All 8 questions in this RACE are based on the below contracts. This is the same contracts you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract TokenV1 is ERC20, AccessControl {\n    bytes32 MIGRATOR_ROLE = keccak256(\"MIGRATOR_ROLE\");\n\n    constructor() ERC20(\"Token\", \"TKN\") {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // Spec wasn't clear about what 'admin functions' need to be capable of.\n    // Well, this should do the trick.\n    fallback() external {\n        if (hasRole(MIGRATOR_ROLE, msg.sender)) {\n            (bool success, bytes memory data) = msg.sender.delegatecall(msg.data);\n            require(success, \"MIGRATION CALL FAILED\");\n            assembly {\n                return(add(data, 32), mload(data))\n            }\n        }\n    }\n}\n\ninterface IEERC20 is IERC20, IERC20Permit {}\ncontract Vault {\n    address public UNDERLYING;\n    mapping(address => uint256) public balances;\n\n    constructor(address token)  {\n        UNDERLYING = token;\n    }\n\n    function deposit(uint256 amount) external {\n        IEERC20(UNDERLYING).transferFrom(msg.sender, address(this), amount);\n        balances[msg.sender] += amount;\n    }\n\n    function depositWithPermit(address target, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s, address to) external {\n        IEERC20(UNDERLYING).permit(target, address(this), amount, deadline, v, r, s);\n        IEERC20(UNDERLYING).transferFrom(target, address(this), amount);\n        balances[to] += amount;\n    }\n\n    function withdraw(uint256 amount) external {\n        IEERC20(UNDERLYING).transfer(msg.sender, amount);\n        balances[msg.sender] -= amount;\n    }\n\n    function sweep(address token) external {\n        require(UNDERLYING != token, \"can't sweep underlying\");\n        IEERC20(token).transfer(msg.sender, IEERC20(token).balanceOf(address(this)));\n    }\n}\n\n/* ... some time later ... */\n\n// Adding permit() while maintaining old token balances.\ncontract TokenV2 {\n    address private immutable TOKEN_V1;\n    address private immutable PERMIT_MODULE;\n\n    constructor(address _tokenV1)  {\n        TOKEN_V1 = _tokenV1;\n        PERMIT_MODULE = address(new PermitModule());\n    }\n\n    // Abusing migrations as proxy.\n    fallback() external {\n        (\n            bool success,\n            bytes memory data\n        ) = (address(this) != TOKEN_V1)\n          ? TOKEN_V1.call(abi.encodePacked(hex\"00000000\", msg.data, msg.sender))\n          : PERMIT_MODULE.delegatecall(msg.data[4:]);\n        require(success, \"FORWARDING CALL FAILED\");\n        assembly {\n            return(add(data, 32), mload(data))\n        }\n    }\n}\ncontract PermitModule is TokenV1, ERC20Permit {\n    constructor() TokenV1() ERC20Permit(\"Token\") {}\n    function _msgSender() internal view virtual override returns (address) {\n        if (address(this).code.length == 0) return super._msgSender(); // normal context during construction\n        return address(uint160(bytes20(msg.data[msg.data.length-20:msg.data.length])));\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Is no longer vulnerable in the `depositWithPermit()` function (B): Becomes more vulnerable due to a Double-Entry-Point\n (C): Stops functioning because TokenV1 has been replaced\n (D): None of the above\n \n \n \n"
      },
      {
        "choice": "B",
        "answer": "Becomes more vulnerable due to a Double-Entry-Point (C): Stops functioning because TokenV1 has been replaced\n (D): None of the above\n \n \n \n"
      },
      {
        "choice": "C",
        "answer": "Stops functioning because TokenV1 has been replaced (D): None of the above\n \n \n \n"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-12.md"
  },
  {
    "question": "7] Vault initialized with TokenV2 as underlying",
    "context": "**Note**: All 8 questions in this RACE are based on the below contracts. This is the same contracts you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract TokenV1 is ERC20, AccessControl {\n    bytes32 MIGRATOR_ROLE = keccak256(\"MIGRATOR_ROLE\");\n\n    constructor() ERC20(\"Token\", \"TKN\") {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // Spec wasn't clear about what 'admin functions' need to be capable of.\n    // Well, this should do the trick.\n    fallback() external {\n        if (hasRole(MIGRATOR_ROLE, msg.sender)) {\n            (bool success, bytes memory data) = msg.sender.delegatecall(msg.data);\n            require(success, \"MIGRATION CALL FAILED\");\n            assembly {\n                return(add(data, 32), mload(data))\n            }\n        }\n    }\n}\n\ninterface IEERC20 is IERC20, IERC20Permit {}\ncontract Vault {\n    address public UNDERLYING;\n    mapping(address => uint256) public balances;\n\n    constructor(address token)  {\n        UNDERLYING = token;\n    }\n\n    function deposit(uint256 amount) external {\n        IEERC20(UNDERLYING).transferFrom(msg.sender, address(this), amount);\n        balances[msg.sender] += amount;\n    }\n\n    function depositWithPermit(address target, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s, address to) external {\n        IEERC20(UNDERLYING).permit(target, address(this), amount, deadline, v, r, s);\n        IEERC20(UNDERLYING).transferFrom(target, address(this), amount);\n        balances[to] += amount;\n    }\n\n    function withdraw(uint256 amount) external {\n        IEERC20(UNDERLYING).transfer(msg.sender, amount);\n        balances[msg.sender] -= amount;\n    }\n\n    function sweep(address token) external {\n        require(UNDERLYING != token, \"can't sweep underlying\");\n        IEERC20(token).transfer(msg.sender, IEERC20(token).balanceOf(address(this)));\n    }\n}\n\n/* ... some time later ... */\n\n// Adding permit() while maintaining old token balances.\ncontract TokenV2 {\n    address private immutable TOKEN_V1;\n    address private immutable PERMIT_MODULE;\n\n    constructor(address _tokenV1)  {\n        TOKEN_V1 = _tokenV1;\n        PERMIT_MODULE = address(new PermitModule());\n    }\n\n    // Abusing migrations as proxy.\n    fallback() external {\n        (\n            bool success,\n            bytes memory data\n        ) = (address(this) != TOKEN_V1)\n          ? TOKEN_V1.call(abi.encodePacked(hex\"00000000\", msg.data, msg.sender))\n          : PERMIT_MODULE.delegatecall(msg.data[4:]);\n        require(success, \"FORWARDING CALL FAILED\");\n        assembly {\n            return(add(data, 32), mload(data))\n        }\n    }\n}\ncontract PermitModule is TokenV1, ERC20Permit {\n    constructor() TokenV1() ERC20Permit(\"Token\") {}\n    function _msgSender() internal view virtual override returns (address) {\n        if (address(this).code.length == 0) return super._msgSender(); // normal context during construction\n        return address(uint160(bytes20(msg.data[msg.data.length-20:msg.data.length])));\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Can be drained by re-entering during withdrawal"
      },
      {
        "choice": "B",
        "answer": "Can be drained during withdrawal due to a integer underflow"
      },
      {
        "choice": "C",
        "answer": "Is not vulnerable in the `depositWithPermit()` function"
      },
      {
        "choice": "D",
        "answer": "Is vulnerable due to a Double-Entry-Point \n \n \n"
      }
    ],
    "correctAnswers": [
      "C",
      "D"
    ],
    "race": "RACE-12.md"
  },
  {
    "question": "8] The PermitModule contract",
    "context": "**Note**: All 8 questions in this RACE are based on the below contracts. This is the same contracts you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```solidity\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract TokenV1 is ERC20, AccessControl {\n    bytes32 MIGRATOR_ROLE = keccak256(\"MIGRATOR_ROLE\");\n\n    constructor() ERC20(\"Token\", \"TKN\") {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // Spec wasn't clear about what 'admin functions' need to be capable of.\n    // Well, this should do the trick.\n    fallback() external {\n        if (hasRole(MIGRATOR_ROLE, msg.sender)) {\n            (bool success, bytes memory data) = msg.sender.delegatecall(msg.data);\n            require(success, \"MIGRATION CALL FAILED\");\n            assembly {\n                return(add(data, 32), mload(data))\n            }\n        }\n    }\n}\n\ninterface IEERC20 is IERC20, IERC20Permit {}\ncontract Vault {\n    address public UNDERLYING;\n    mapping(address => uint256) public balances;\n\n    constructor(address token)  {\n        UNDERLYING = token;\n    }\n\n    function deposit(uint256 amount) external {\n        IEERC20(UNDERLYING).transferFrom(msg.sender, address(this), amount);\n        balances[msg.sender] += amount;\n    }\n\n    function depositWithPermit(address target, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s, address to) external {\n        IEERC20(UNDERLYING).permit(target, address(this), amount, deadline, v, r, s);\n        IEERC20(UNDERLYING).transferFrom(target, address(this), amount);\n        balances[to] += amount;\n    }\n\n    function withdraw(uint256 amount) external {\n        IEERC20(UNDERLYING).transfer(msg.sender, amount);\n        balances[msg.sender] -= amount;\n    }\n\n    function sweep(address token) external {\n        require(UNDERLYING != token, \"can't sweep underlying\");\n        IEERC20(token).transfer(msg.sender, IEERC20(token).balanceOf(address(this)));\n    }\n}\n\n/* ... some time later ... */\n\n// Adding permit() while maintaining old token balances.\ncontract TokenV2 {\n    address private immutable TOKEN_V1;\n    address private immutable PERMIT_MODULE;\n\n    constructor(address _tokenV1)  {\n        TOKEN_V1 = _tokenV1;\n        PERMIT_MODULE = address(new PermitModule());\n    }\n\n    // Abusing migrations as proxy.\n    fallback() external {\n        (\n            bool success,\n            bytes memory data\n        ) = (address(this) != TOKEN_V1)\n          ? TOKEN_V1.call(abi.encodePacked(hex\"00000000\", msg.data, msg.sender))\n          : PERMIT_MODULE.delegatecall(msg.data[4:]);\n        require(success, \"FORWARDING CALL FAILED\");\n        assembly {\n            return(add(data, 32), mload(data))\n        }\n    }\n}\ncontract PermitModule is TokenV1, ERC20Permit {\n    constructor() TokenV1() ERC20Permit(\"Token\") {}\n    function _msgSender() internal view virtual override returns (address) {\n        if (address(this).code.length == 0) return super._msgSender(); // normal context during construction\n        return address(uint160(bytes20(msg.data[msg.data.length-20:msg.data.length])));\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Acts as a proxy (B): Acts as an implementation\n (C): Allows anyone to manipulate TokenV2's balances\n (D): Can be self-destructed by anyone\n \n \n \n"
      },
      {
        "choice": "B",
        "answer": "Acts as an implementation (C): Allows anyone to manipulate TokenV2's balances\n (D): Can be self-destructed by anyone\n \n \n \n"
      },
      {
        "choice": "C",
        "answer": "Allows anyone to manipulate TokenV2's balances (D): Can be self-destructed by anyone\n \n \n \n"
      },
      {
        "choice": "D",
        "answer": "Can be self-destructed by anyone \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "D"
    ],
    "race": "RACE-12.md"
  },
  {
    "question": "1] In `transferFrom()`, `unchecked` is __not__ used in the allowance subtraction:\\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\n/// CallbackERC20 is based on Solmate's ERC20.\n/// It adds the extra feature that address can register callbacks,\n/// which are called when that address is a recipient or sender\n/// of a transfer.\n/// Addresses can also revoke callbacks.\ncontract CallbackERC20 {\n   event Transfer(address indexed from, address indexed to, uint256 amount);\n\n   event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n   /*//////////////////////////////////////////////////////////////\n                           METADATA STORAGE\n   //////////////////////////////////////////////////////////////*/\n\n   // Optimized version vs string\n   function name() external pure returns (string memory) {\n       // Returns \"Callback\"\n       assembly {\n           mstore(0, 0x20)\n           mstore(0x28, 0x0843616c6c6261636b)\n           return(0, 0x60)\n       }\n   }\n\n   // Optimized version vs string\n   function symbol() external pure returns (string memory) {\n       // Returns \"CERC\"\n       assembly {\n           mstore(0, 0x20)\n           mstore(0x24, 0x0443455243)\n           return(0, 0x60)\n       }\n   }\n\n   uint8 public constant decimals = 18;\n\n   /*//////////////////////////////////////////////////////////////\n                             ERC20 STORAGE\n   //////////////////////////////////////////////////////////////*/\n\n   uint256 public totalSupply;\n\n   mapping(address => uint256) public balanceOf;\n\n   mapping(address => mapping(address => uint256)) public allowance;\n\n   /*//////////////////////////////////////////////////////////////\n                              CALLBACK\n   //////////////////////////////////////////////////////////////*/\n\n   mapping(address => function (address, address, uint) external) public callbacks;\n\n   /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n   //////////////////////////////////////////////////////////////*/\n\n   constructor() {\n       // Owner starts with a little fortune they can distribute.\n       _mint(msg.sender, 1_000_000);\n   }\n\n   /*//////////////////////////////////////////////////////////////\n                             CALLBACK LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n  function registerCallback(function (address, address, uint) external callback) external {\n      callbacks[msg.sender] = callback;\n  }\n\n  function unregisterCallback() external {\n      delete callbacks[msg.sender];\n  }\n\n\n   /*//////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n   function approve(address spender, uint256 amount) public virtual returns (bool) {\n       allowance[msg.sender][spender] = amount;\n\n       emit Approval(msg.sender, spender, amount);\n\n       return true;\n   }\n\n   function transfer(address to, uint256 amount) public virtual returns (bool) {\n       balanceOf[msg.sender] -= amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       notify(msg.sender, msg.sender, to, amount);\n       notify(to, msg.sender, to, amount);\n\n       emit Transfer(msg.sender, to, amount);\n\n       return true;\n   }\n\n   function transferFrom(\n       address from,\n       address to,\n       uint256 amount\n   ) public virtual returns (bool) {\n       uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n       if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n       balanceOf[from] -= amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       notify(from, from, to, amount);\n       notify(to, from, to, amount);\n\n       emit Transfer(from, to, amount);\n\n       return true;\n   }\n\n   function notify(address who, address from, address to, uint amt) internal {\n       if (callbacks[who].address != address(0)) {\n           callbacks[who](from, to, amt);\n       }\n   }\n\n   /*//////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n   function _mint(address to, uint256 amount) internal virtual {\n       totalSupply += amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       emit Transfer(address(0), to, amount);\n   }\n\n   function _burn(address from, uint256 amount) internal virtual {\n       balanceOf[from] -= amount;\n\n       // Cannot underflow because a user's balance\n       // will never be larger than the total supply.\n       unchecked {\n           totalSupply -= amount;\n       }\n\n       emit Transfer(from, address(0), amount);\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "To save gas\\"
      },
      {
        "choice": "B",
        "answer": "To avoid unauthorized transfers\\"
      },
      {
        "choice": "C",
        "answer": "To avoid reentrancy\\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-13.md"
  },
  {
    "question": "2] In `transfer()` and `transferFrom()`, the use of `unchecked` would __not__ be desired:\\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\n/// CallbackERC20 is based on Solmate's ERC20.\n/// It adds the extra feature that address can register callbacks,\n/// which are called when that address is a recipient or sender\n/// of a transfer.\n/// Addresses can also revoke callbacks.\ncontract CallbackERC20 {\n   event Transfer(address indexed from, address indexed to, uint256 amount);\n\n   event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n   /*//////////////////////////////////////////////////////////////\n                           METADATA STORAGE\n   //////////////////////////////////////////////////////////////*/\n\n   // Optimized version vs string\n   function name() external pure returns (string memory) {\n       // Returns \"Callback\"\n       assembly {\n           mstore(0, 0x20)\n           mstore(0x28, 0x0843616c6c6261636b)\n           return(0, 0x60)\n       }\n   }\n\n   // Optimized version vs string\n   function symbol() external pure returns (string memory) {\n       // Returns \"CERC\"\n       assembly {\n           mstore(0, 0x20)\n           mstore(0x24, 0x0443455243)\n           return(0, 0x60)\n       }\n   }\n\n   uint8 public constant decimals = 18;\n\n   /*//////////////////////////////////////////////////////////////\n                             ERC20 STORAGE\n   //////////////////////////////////////////////////////////////*/\n\n   uint256 public totalSupply;\n\n   mapping(address => uint256) public balanceOf;\n\n   mapping(address => mapping(address => uint256)) public allowance;\n\n   /*//////////////////////////////////////////////////////////////\n                              CALLBACK\n   //////////////////////////////////////////////////////////////*/\n\n   mapping(address => function (address, address, uint) external) public callbacks;\n\n   /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n   //////////////////////////////////////////////////////////////*/\n\n   constructor() {\n       // Owner starts with a little fortune they can distribute.\n       _mint(msg.sender, 1_000_000);\n   }\n\n   /*//////////////////////////////////////////////////////////////\n                             CALLBACK LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n  function registerCallback(function (address, address, uint) external callback) external {\n      callbacks[msg.sender] = callback;\n  }\n\n  function unregisterCallback() external {\n      delete callbacks[msg.sender];\n  }\n\n\n   /*//////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n   function approve(address spender, uint256 amount) public virtual returns (bool) {\n       allowance[msg.sender][spender] = amount;\n\n       emit Approval(msg.sender, spender, amount);\n\n       return true;\n   }\n\n   function transfer(address to, uint256 amount) public virtual returns (bool) {\n       balanceOf[msg.sender] -= amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       notify(msg.sender, msg.sender, to, amount);\n       notify(to, msg.sender, to, amount);\n\n       emit Transfer(msg.sender, to, amount);\n\n       return true;\n   }\n\n   function transferFrom(\n       address from,\n       address to,\n       uint256 amount\n   ) public virtual returns (bool) {\n       uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n       if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n       balanceOf[from] -= amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       notify(from, from, to, amount);\n       notify(to, from, to, amount);\n\n       emit Transfer(from, to, amount);\n\n       return true;\n   }\n\n   function notify(address who, address from, address to, uint amt) internal {\n       if (callbacks[who].address != address(0)) {\n           callbacks[who](from, to, amt);\n       }\n   }\n\n   /*//////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n   function _mint(address to, uint256 amount) internal virtual {\n       totalSupply += amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       emit Transfer(address(0), to, amount);\n   }\n\n   function _burn(address from, uint256 amount) internal virtual {\n       balanceOf[from] -= amount;\n\n       // Cannot underflow because a user's balance\n       // will never be larger than the total supply.\n       unchecked {\n           totalSupply -= amount;\n       }\n\n       emit Transfer(from, address(0), amount);\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "When the token uses large number of decimals\\"
      },
      {
        "choice": "B",
        "answer": "When the token uses small number of decimals\\"
      },
      {
        "choice": "C",
        "answer": "At all times\\"
      },
      {
        "choice": "D",
        "answer": "At no times \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-13.md"
  },
  {
    "question": "3] In `name()` and `symbol()`, the returned values are incorrect because:\\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\n/// CallbackERC20 is based on Solmate's ERC20.\n/// It adds the extra feature that address can register callbacks,\n/// which are called when that address is a recipient or sender\n/// of a transfer.\n/// Addresses can also revoke callbacks.\ncontract CallbackERC20 {\n   event Transfer(address indexed from, address indexed to, uint256 amount);\n\n   event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n   /*//////////////////////////////////////////////////////////////\n                           METADATA STORAGE\n   //////////////////////////////////////////////////////////////*/\n\n   // Optimized version vs string\n   function name() external pure returns (string memory) {\n       // Returns \"Callback\"\n       assembly {\n           mstore(0, 0x20)\n           mstore(0x28, 0x0843616c6c6261636b)\n           return(0, 0x60)\n       }\n   }\n\n   // Optimized version vs string\n   function symbol() external pure returns (string memory) {\n       // Returns \"CERC\"\n       assembly {\n           mstore(0, 0x20)\n           mstore(0x24, 0x0443455243)\n           return(0, 0x60)\n       }\n   }\n\n   uint8 public constant decimals = 18;\n\n   /*//////////////////////////////////////////////////////////////\n                             ERC20 STORAGE\n   //////////////////////////////////////////////////////////////*/\n\n   uint256 public totalSupply;\n\n   mapping(address => uint256) public balanceOf;\n\n   mapping(address => mapping(address => uint256)) public allowance;\n\n   /*//////////////////////////////////////////////////////////////\n                              CALLBACK\n   //////////////////////////////////////////////////////////////*/\n\n   mapping(address => function (address, address, uint) external) public callbacks;\n\n   /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n   //////////////////////////////////////////////////////////////*/\n\n   constructor() {\n       // Owner starts with a little fortune they can distribute.\n       _mint(msg.sender, 1_000_000);\n   }\n\n   /*//////////////////////////////////////////////////////////////\n                             CALLBACK LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n  function registerCallback(function (address, address, uint) external callback) external {\n      callbacks[msg.sender] = callback;\n  }\n\n  function unregisterCallback() external {\n      delete callbacks[msg.sender];\n  }\n\n\n   /*//////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n   function approve(address spender, uint256 amount) public virtual returns (bool) {\n       allowance[msg.sender][spender] = amount;\n\n       emit Approval(msg.sender, spender, amount);\n\n       return true;\n   }\n\n   function transfer(address to, uint256 amount) public virtual returns (bool) {\n       balanceOf[msg.sender] -= amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       notify(msg.sender, msg.sender, to, amount);\n       notify(to, msg.sender, to, amount);\n\n       emit Transfer(msg.sender, to, amount);\n\n       return true;\n   }\n\n   function transferFrom(\n       address from,\n       address to,\n       uint256 amount\n   ) public virtual returns (bool) {\n       uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n       if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n       balanceOf[from] -= amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       notify(from, from, to, amount);\n       notify(to, from, to, amount);\n\n       emit Transfer(from, to, amount);\n\n       return true;\n   }\n\n   function notify(address who, address from, address to, uint amt) internal {\n       if (callbacks[who].address != address(0)) {\n           callbacks[who](from, to, amt);\n       }\n   }\n\n   /*//////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n   function _mint(address to, uint256 amount) internal virtual {\n       totalSupply += amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       emit Transfer(address(0), to, amount);\n   }\n\n   function _burn(address from, uint256 amount) internal virtual {\n       balanceOf[from] -= amount;\n\n       // Cannot underflow because a user's balance\n       // will never be larger than the total supply.\n       unchecked {\n           totalSupply -= amount;\n       }\n\n       emit Transfer(from, address(0), amount);\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The string encoding is too short\\"
      },
      {
        "choice": "B",
        "answer": "Inline assembly `return` does not leave the function\\"
      },
      {
        "choice": "C",
        "answer": "`MSTORE` does not fill all bytes until 0x5f and function may return junk at the end\\"
      },
      {
        "choice": "D",
        "answer": "The code always reverts \n \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-13.md"
  },
  {
    "question": "4] To correct `name()`, one could make the following change(s):\\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\n/// CallbackERC20 is based on Solmate's ERC20.\n/// It adds the extra feature that address can register callbacks,\n/// which are called when that address is a recipient or sender\n/// of a transfer.\n/// Addresses can also revoke callbacks.\ncontract CallbackERC20 {\n   event Transfer(address indexed from, address indexed to, uint256 amount);\n\n   event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n   /*//////////////////////////////////////////////////////////////\n                           METADATA STORAGE\n   //////////////////////////////////////////////////////////////*/\n\n   // Optimized version vs string\n   function name() external pure returns (string memory) {\n       // Returns \"Callback\"\n       assembly {\n           mstore(0, 0x20)\n           mstore(0x28, 0x0843616c6c6261636b)\n           return(0, 0x60)\n       }\n   }\n\n   // Optimized version vs string\n   function symbol() external pure returns (string memory) {\n       // Returns \"CERC\"\n       assembly {\n           mstore(0, 0x20)\n           mstore(0x24, 0x0443455243)\n           return(0, 0x60)\n       }\n   }\n\n   uint8 public constant decimals = 18;\n\n   /*//////////////////////////////////////////////////////////////\n                             ERC20 STORAGE\n   //////////////////////////////////////////////////////////////*/\n\n   uint256 public totalSupply;\n\n   mapping(address => uint256) public balanceOf;\n\n   mapping(address => mapping(address => uint256)) public allowance;\n\n   /*//////////////////////////////////////////////////////////////\n                              CALLBACK\n   //////////////////////////////////////////////////////////////*/\n\n   mapping(address => function (address, address, uint) external) public callbacks;\n\n   /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n   //////////////////////////////////////////////////////////////*/\n\n   constructor() {\n       // Owner starts with a little fortune they can distribute.\n       _mint(msg.sender, 1_000_000);\n   }\n\n   /*//////////////////////////////////////////////////////////////\n                             CALLBACK LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n  function registerCallback(function (address, address, uint) external callback) external {\n      callbacks[msg.sender] = callback;\n  }\n\n  function unregisterCallback() external {\n      delete callbacks[msg.sender];\n  }\n\n\n   /*//////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n   function approve(address spender, uint256 amount) public virtual returns (bool) {\n       allowance[msg.sender][spender] = amount;\n\n       emit Approval(msg.sender, spender, amount);\n\n       return true;\n   }\n\n   function transfer(address to, uint256 amount) public virtual returns (bool) {\n       balanceOf[msg.sender] -= amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       notify(msg.sender, msg.sender, to, amount);\n       notify(to, msg.sender, to, amount);\n\n       emit Transfer(msg.sender, to, amount);\n\n       return true;\n   }\n\n   function transferFrom(\n       address from,\n       address to,\n       uint256 amount\n   ) public virtual returns (bool) {\n       uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n       if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n       balanceOf[from] -= amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       notify(from, from, to, amount);\n       notify(to, from, to, amount);\n\n       emit Transfer(from, to, amount);\n\n       return true;\n   }\n\n   function notify(address who, address from, address to, uint amt) internal {\n       if (callbacks[who].address != address(0)) {\n           callbacks[who](from, to, amt);\n       }\n   }\n\n   /*//////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n   function _mint(address to, uint256 amount) internal virtual {\n       totalSupply += amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       emit Transfer(address(0), to, amount);\n   }\n\n   function _burn(address from, uint256 amount) internal virtual {\n       balanceOf[from] -= amount;\n\n       // Cannot underflow because a user's balance\n       // will never be larger than the total supply.\n       unchecked {\n           totalSupply -= amount;\n       }\n\n       emit Transfer(from, address(0), amount);\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "```assembly { mstore(0x20, 0x20)\n mstore(0x48, 0x0843616c6c6261636b)\n return(0x20, 0x60)\n }```\\\n"
      },
      {
        "choice": "B",
        "answer": "```function name() external pure returns (string memory n) { n = \"Callback\"; }```\\"
      },
      {
        "choice": "C",
        "answer": "```return \"Callback\";```\\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C"
    ],
    "race": "RACE-13.md"
  },
  {
    "question": "5] The concern(s) with the check in `notify()` is/are:\\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\n/// CallbackERC20 is based on Solmate's ERC20.\n/// It adds the extra feature that address can register callbacks,\n/// which are called when that address is a recipient or sender\n/// of a transfer.\n/// Addresses can also revoke callbacks.\ncontract CallbackERC20 {\n   event Transfer(address indexed from, address indexed to, uint256 amount);\n\n   event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n   /*//////////////////////////////////////////////////////////////\n                           METADATA STORAGE\n   //////////////////////////////////////////////////////////////*/\n\n   // Optimized version vs string\n   function name() external pure returns (string memory) {\n       // Returns \"Callback\"\n       assembly {\n           mstore(0, 0x20)\n           mstore(0x28, 0x0843616c6c6261636b)\n           return(0, 0x60)\n       }\n   }\n\n   // Optimized version vs string\n   function symbol() external pure returns (string memory) {\n       // Returns \"CERC\"\n       assembly {\n           mstore(0, 0x20)\n           mstore(0x24, 0x0443455243)\n           return(0, 0x60)\n       }\n   }\n\n   uint8 public constant decimals = 18;\n\n   /*//////////////////////////////////////////////////////////////\n                             ERC20 STORAGE\n   //////////////////////////////////////////////////////////////*/\n\n   uint256 public totalSupply;\n\n   mapping(address => uint256) public balanceOf;\n\n   mapping(address => mapping(address => uint256)) public allowance;\n\n   /*//////////////////////////////////////////////////////////////\n                              CALLBACK\n   //////////////////////////////////////////////////////////////*/\n\n   mapping(address => function (address, address, uint) external) public callbacks;\n\n   /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n   //////////////////////////////////////////////////////////////*/\n\n   constructor() {\n       // Owner starts with a little fortune they can distribute.\n       _mint(msg.sender, 1_000_000);\n   }\n\n   /*//////////////////////////////////////////////////////////////\n                             CALLBACK LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n  function registerCallback(function (address, address, uint) external callback) external {\n      callbacks[msg.sender] = callback;\n  }\n\n  function unregisterCallback() external {\n      delete callbacks[msg.sender];\n  }\n\n\n   /*//////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n   function approve(address spender, uint256 amount) public virtual returns (bool) {\n       allowance[msg.sender][spender] = amount;\n\n       emit Approval(msg.sender, spender, amount);\n\n       return true;\n   }\n\n   function transfer(address to, uint256 amount) public virtual returns (bool) {\n       balanceOf[msg.sender] -= amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       notify(msg.sender, msg.sender, to, amount);\n       notify(to, msg.sender, to, amount);\n\n       emit Transfer(msg.sender, to, amount);\n\n       return true;\n   }\n\n   function transferFrom(\n       address from,\n       address to,\n       uint256 amount\n   ) public virtual returns (bool) {\n       uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n       if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n       balanceOf[from] -= amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       notify(from, from, to, amount);\n       notify(to, from, to, amount);\n\n       emit Transfer(from, to, amount);\n\n       return true;\n   }\n\n   function notify(address who, address from, address to, uint amt) internal {\n       if (callbacks[who].address != address(0)) {\n           callbacks[who](from, to, amt);\n       }\n   }\n\n   /*//////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n   function _mint(address to, uint256 amount) internal virtual {\n       totalSupply += amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       emit Transfer(address(0), to, amount);\n   }\n\n   function _burn(address from, uint256 amount) internal virtual {\n       balanceOf[from] -= amount;\n\n       // Cannot underflow because a user's balance\n       // will never be larger than the total supply.\n       unchecked {\n           totalSupply -= amount;\n       }\n\n       emit Transfer(from, address(0), amount);\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Selector 0x00000000 is the `fallback` function\\"
      },
      {
        "choice": "B",
        "answer": "Selector 0x00000000 is the `receive` function\\"
      },
      {
        "choice": "C",
        "answer": "Selector 0x00000000 is possible in which case a valid callback would not be called\\"
      },
      {
        "choice": "D",
        "answer": "Selector can never be 0x00000000, so the check is useless \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-13.md"
  },
  {
    "question": "6] The concern(s) with the call in `notify()` is/are:\\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\n/// CallbackERC20 is based on Solmate's ERC20.\n/// It adds the extra feature that address can register callbacks,\n/// which are called when that address is a recipient or sender\n/// of a transfer.\n/// Addresses can also revoke callbacks.\ncontract CallbackERC20 {\n   event Transfer(address indexed from, address indexed to, uint256 amount);\n\n   event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n   /*//////////////////////////////////////////////////////////////\n                           METADATA STORAGE\n   //////////////////////////////////////////////////////////////*/\n\n   // Optimized version vs string\n   function name() external pure returns (string memory) {\n       // Returns \"Callback\"\n       assembly {\n           mstore(0, 0x20)\n           mstore(0x28, 0x0843616c6c6261636b)\n           return(0, 0x60)\n       }\n   }\n\n   // Optimized version vs string\n   function symbol() external pure returns (string memory) {\n       // Returns \"CERC\"\n       assembly {\n           mstore(0, 0x20)\n           mstore(0x24, 0x0443455243)\n           return(0, 0x60)\n       }\n   }\n\n   uint8 public constant decimals = 18;\n\n   /*//////////////////////////////////////////////////////////////\n                             ERC20 STORAGE\n   //////////////////////////////////////////////////////////////*/\n\n   uint256 public totalSupply;\n\n   mapping(address => uint256) public balanceOf;\n\n   mapping(address => mapping(address => uint256)) public allowance;\n\n   /*//////////////////////////////////////////////////////////////\n                              CALLBACK\n   //////////////////////////////////////////////////////////////*/\n\n   mapping(address => function (address, address, uint) external) public callbacks;\n\n   /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n   //////////////////////////////////////////////////////////////*/\n\n   constructor() {\n       // Owner starts with a little fortune they can distribute.\n       _mint(msg.sender, 1_000_000);\n   }\n\n   /*//////////////////////////////////////////////////////////////\n                             CALLBACK LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n  function registerCallback(function (address, address, uint) external callback) external {\n      callbacks[msg.sender] = callback;\n  }\n\n  function unregisterCallback() external {\n      delete callbacks[msg.sender];\n  }\n\n\n   /*//////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n   function approve(address spender, uint256 amount) public virtual returns (bool) {\n       allowance[msg.sender][spender] = amount;\n\n       emit Approval(msg.sender, spender, amount);\n\n       return true;\n   }\n\n   function transfer(address to, uint256 amount) public virtual returns (bool) {\n       balanceOf[msg.sender] -= amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       notify(msg.sender, msg.sender, to, amount);\n       notify(to, msg.sender, to, amount);\n\n       emit Transfer(msg.sender, to, amount);\n\n       return true;\n   }\n\n   function transferFrom(\n       address from,\n       address to,\n       uint256 amount\n   ) public virtual returns (bool) {\n       uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n       if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n       balanceOf[from] -= amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       notify(from, from, to, amount);\n       notify(to, from, to, amount);\n\n       emit Transfer(from, to, amount);\n\n       return true;\n   }\n\n   function notify(address who, address from, address to, uint amt) internal {\n       if (callbacks[who].address != address(0)) {\n           callbacks[who](from, to, amt);\n       }\n   }\n\n   /*//////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n   function _mint(address to, uint256 amount) internal virtual {\n       totalSupply += amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       emit Transfer(address(0), to, amount);\n   }\n\n   function _burn(address from, uint256 amount) internal virtual {\n       balanceOf[from] -= amount;\n\n       // Cannot underflow because a user's balance\n       // will never be larger than the total supply.\n       unchecked {\n           totalSupply -= amount;\n       }\n\n       emit Transfer(from, address(0), amount);\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The call always reverts\\"
      },
      {
        "choice": "B",
        "answer": "The passed function pointer is internal and therefore not accessible via an external call\\"
      },
      {
        "choice": "C",
        "answer": "One should always use `try/catch` in external calls\\"
      },
      {
        "choice": "D",
        "answer": "The called contract may not have the called function selector thus falling through to `fallback` or reverting the transfer \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-13.md"
  },
  {
    "question": "7] Potential change(s) to `notify()` to mitigate further security concern(s) is/are:\\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\n/// CallbackERC20 is based on Solmate's ERC20.\n/// It adds the extra feature that address can register callbacks,\n/// which are called when that address is a recipient or sender\n/// of a transfer.\n/// Addresses can also revoke callbacks.\ncontract CallbackERC20 {\n   event Transfer(address indexed from, address indexed to, uint256 amount);\n\n   event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n   /*//////////////////////////////////////////////////////////////\n                           METADATA STORAGE\n   //////////////////////////////////////////////////////////////*/\n\n   // Optimized version vs string\n   function name() external pure returns (string memory) {\n       // Returns \"Callback\"\n       assembly {\n           mstore(0, 0x20)\n           mstore(0x28, 0x0843616c6c6261636b)\n           return(0, 0x60)\n       }\n   }\n\n   // Optimized version vs string\n   function symbol() external pure returns (string memory) {\n       // Returns \"CERC\"\n       assembly {\n           mstore(0, 0x20)\n           mstore(0x24, 0x0443455243)\n           return(0, 0x60)\n       }\n   }\n\n   uint8 public constant decimals = 18;\n\n   /*//////////////////////////////////////////////////////////////\n                             ERC20 STORAGE\n   //////////////////////////////////////////////////////////////*/\n\n   uint256 public totalSupply;\n\n   mapping(address => uint256) public balanceOf;\n\n   mapping(address => mapping(address => uint256)) public allowance;\n\n   /*//////////////////////////////////////////////////////////////\n                              CALLBACK\n   //////////////////////////////////////////////////////////////*/\n\n   mapping(address => function (address, address, uint) external) public callbacks;\n\n   /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n   //////////////////////////////////////////////////////////////*/\n\n   constructor() {\n       // Owner starts with a little fortune they can distribute.\n       _mint(msg.sender, 1_000_000);\n   }\n\n   /*//////////////////////////////////////////////////////////////\n                             CALLBACK LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n  function registerCallback(function (address, address, uint) external callback) external {\n      callbacks[msg.sender] = callback;\n  }\n\n  function unregisterCallback() external {\n      delete callbacks[msg.sender];\n  }\n\n\n   /*//////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n   function approve(address spender, uint256 amount) public virtual returns (bool) {\n       allowance[msg.sender][spender] = amount;\n\n       emit Approval(msg.sender, spender, amount);\n\n       return true;\n   }\n\n   function transfer(address to, uint256 amount) public virtual returns (bool) {\n       balanceOf[msg.sender] -= amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       notify(msg.sender, msg.sender, to, amount);\n       notify(to, msg.sender, to, amount);\n\n       emit Transfer(msg.sender, to, amount);\n\n       return true;\n   }\n\n   function transferFrom(\n       address from,\n       address to,\n       uint256 amount\n   ) public virtual returns (bool) {\n       uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n       if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n       balanceOf[from] -= amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       notify(from, from, to, amount);\n       notify(to, from, to, amount);\n\n       emit Transfer(from, to, amount);\n\n       return true;\n   }\n\n   function notify(address who, address from, address to, uint amt) internal {\n       if (callbacks[who].address != address(0)) {\n           callbacks[who](from, to, amt);\n       }\n   }\n\n   /*//////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n   function _mint(address to, uint256 amount) internal virtual {\n       totalSupply += amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       emit Transfer(address(0), to, amount);\n   }\n\n   function _burn(address from, uint256 amount) internal virtual {\n       balanceOf[from] -= amount;\n\n       // Cannot underflow because a user's balance\n       // will never be larger than the total supply.\n       unchecked {\n           totalSupply -= amount;\n       }\n\n       emit Transfer(from, address(0), amount);\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Enforce the callback call to use `delegatecall`\\"
      },
      {
        "choice": "B",
        "answer": "Enforce the callback call to use `staticcall`\\"
      },
      {
        "choice": "C",
        "answer": "Send Ether to the called contract\\"
      },
      {
        "choice": "D",
        "answer": "Make the call in inline assembly \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-13.md"
  },
  {
    "question": "8] How can the contract be exploited for loss-of-funds via notify callback reentrancy?\\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\n/// CallbackERC20 is based on Solmate's ERC20.\n/// It adds the extra feature that address can register callbacks,\n/// which are called when that address is a recipient or sender\n/// of a transfer.\n/// Addresses can also revoke callbacks.\ncontract CallbackERC20 {\n   event Transfer(address indexed from, address indexed to, uint256 amount);\n\n   event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n   /*//////////////////////////////////////////////////////////////\n                           METADATA STORAGE\n   //////////////////////////////////////////////////////////////*/\n\n   // Optimized version vs string\n   function name() external pure returns (string memory) {\n       // Returns \"Callback\"\n       assembly {\n           mstore(0, 0x20)\n           mstore(0x28, 0x0843616c6c6261636b)\n           return(0, 0x60)\n       }\n   }\n\n   // Optimized version vs string\n   function symbol() external pure returns (string memory) {\n       // Returns \"CERC\"\n       assembly {\n           mstore(0, 0x20)\n           mstore(0x24, 0x0443455243)\n           return(0, 0x60)\n       }\n   }\n\n   uint8 public constant decimals = 18;\n\n   /*//////////////////////////////////////////////////////////////\n                             ERC20 STORAGE\n   //////////////////////////////////////////////////////////////*/\n\n   uint256 public totalSupply;\n\n   mapping(address => uint256) public balanceOf;\n\n   mapping(address => mapping(address => uint256)) public allowance;\n\n   /*//////////////////////////////////////////////////////////////\n                              CALLBACK\n   //////////////////////////////////////////////////////////////*/\n\n   mapping(address => function (address, address, uint) external) public callbacks;\n\n   /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n   //////////////////////////////////////////////////////////////*/\n\n   constructor() {\n       // Owner starts with a little fortune they can distribute.\n       _mint(msg.sender, 1_000_000);\n   }\n\n   /*//////////////////////////////////////////////////////////////\n                             CALLBACK LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n  function registerCallback(function (address, address, uint) external callback) external {\n      callbacks[msg.sender] = callback;\n  }\n\n  function unregisterCallback() external {\n      delete callbacks[msg.sender];\n  }\n\n\n   /*//////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n   function approve(address spender, uint256 amount) public virtual returns (bool) {\n       allowance[msg.sender][spender] = amount;\n\n       emit Approval(msg.sender, spender, amount);\n\n       return true;\n   }\n\n   function transfer(address to, uint256 amount) public virtual returns (bool) {\n       balanceOf[msg.sender] -= amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       notify(msg.sender, msg.sender, to, amount);\n       notify(to, msg.sender, to, amount);\n\n       emit Transfer(msg.sender, to, amount);\n\n       return true;\n   }\n\n   function transferFrom(\n       address from,\n       address to,\n       uint256 amount\n   ) public virtual returns (bool) {\n       uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n       if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n       balanceOf[from] -= amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       notify(from, from, to, amount);\n       notify(to, from, to, amount);\n\n       emit Transfer(from, to, amount);\n\n       return true;\n   }\n\n   function notify(address who, address from, address to, uint amt) internal {\n       if (callbacks[who].address != address(0)) {\n           callbacks[who](from, to, amt);\n       }\n   }\n\n   /*//////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n   //////////////////////////////////////////////////////////////*/\n\n   function _mint(address to, uint256 amount) internal virtual {\n       totalSupply += amount;\n\n       // Cannot overflow because the sum of all user\n       // balances can't exceed the max uint256 value.\n       unchecked {\n           balanceOf[to] += amount;\n       }\n\n       emit Transfer(address(0), to, amount);\n   }\n\n   function _burn(address from, uint256 amount) internal virtual {\n       balanceOf[from] -= amount;\n\n       // Cannot underflow because a user's balance\n       // will never be larger than the total supply.\n       unchecked {\n           totalSupply -= amount;\n       }\n\n       emit Transfer(from, address(0), amount);\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "During the callback, while being the sender of a transfer, repeat the transfer\\"
      },
      {
        "choice": "B",
        "answer": "During the callback, while being the recipient of a transfer, call `transfer` again in the token contract sending the tokens back to the original sender\\"
      },
      {
        "choice": "C",
        "answer": "During the callback, while being the recipient of a transfer, burn the received tokens\\"
      },
      {
        "choice": "D",
        "answer": "This cannot happen in this contract \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-13.md"
  },
  {
    "question": "1] Lending platforms have a few options to configure when it comes to adding new tokens as collateral. For example, youll have to set up an oracle for the price of the collateral, and you have to configure a margin requirement. The security concern with using the given collateral configuration is:",
    "context": "**Note**: Questions 1 & 2 are based on the below code snippet. You will see the same code snippet for these two questions. The question is below the code snippet.\n\n```solidity\ncontract USDCCollateral {\n  // This is a contract that's part of a larger system implementing a lending protocol\n  // This particular contract concerns itself with allowing people to deposit USDC as collateral for their loans\n\n  // A list of all the addresses lending\n  address[] lenders;\n  // A mapping to allow efficient is lender checks\n  mapping(address => bool) isLender;\n  \n  address immutable lendingPlatform;\n  address token = ERC20(USDC_ADDRESS);\n\n  // We use a mapping to store the deposits of all lenders\n  mapping (address => bool) balance;\n\n  // USDC is very stable, so for every 1 USDC you can borrow 1 DAI or 1 USD worth of the other currency\n  // Similar to other lending platforms, this lending system uses an oracle to determine how much one can borrow. \n  // The following describes how the system determines the max borrow value (ignoring precision for simplicity).\n  // maxBorrow = (collateralRatio * underlying * underlyingValueUSD) / otherValueUSD \n  // This encodes the margin requirement of the system.\n  uint collateralRatio = 100_000_000; \n\n  constructor() {\n      periodicFee = 1;\n      \n      // approved collateral contracts are deployed by the lending platform\n      // assume it is implemented correctly, and doesn't allow false collateral contracts.\n      lendingPlatform = msg.sender;\n  }\n\n  function deposit(uint amount) external {\n      require(!isLender[msg.sender]);\n      isLender[msg.sender] = true;\n      lenders.push(msg.sender);\n\n      ...\n  }\n\n  function computeFee(uint periodicFee, uint balance) internal returns (uint) {\n      // Assume this is a correctly implemented function that computes the share of fees that someone should receive based on their balance.\n  }\n \n  // this function is called monthly by the lending platform\n  // We compute how much fees the lender should receive and send it to them\n  function payFees() external onlyLendingPlatform {\n      for (uint i=0; i<lenders.length; i++) {\n        // Compute fee uses the balance of each lender\n         uint fee = computeFee(periodicFee, balance[lenders[i]])\n          token.transferFrom(lendingPlatform, lenders[i], fee);\n      }\n  }\n  ...\n}\n```\n\n**[Q1] Lending platforms have a few options to configure when it comes to adding new tokens as collateral. For example, youll have to set up an oracle for the price of the collateral, and you have to configure a margin requirement. The security concern with using the given collateral configuration is:**\n\n(A): The periodic fee parameter is static\\\n(B): The collateral ratio of loans is too low\\\n(C): USDC should not be used as collateral for loans\\\n(D): None of the above\n\n**[Answers]: B**\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The periodic fee parameter is static\\"
      },
      {
        "choice": "B",
        "answer": "The collateral ratio of loans is too low\\"
      },
      {
        "choice": "C",
        "answer": "USDC should not be used as collateral for loans\\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-14.md"
  },
  {
    "question": "2] Assuming payFees() is periodically called by a function, which iteratively calls payFees() of all collateral contracts, the security concern(s) is/are:",
    "context": "**Note**: Questions 1 & 2 are based on the below code snippet. You will see the same code snippet for these two questions. The question is below the code snippet.\n\n```solidity\ncontract USDCCollateral {\n  // This is a contract that's part of a larger system implementing a lending protocol\n  // This particular contract concerns itself with allowing people to deposit USDC as collateral for their loans\n\n  // A list of all the addresses lending\n  address[] lenders;\n  // A mapping to allow efficient is lender checks\n  mapping(address => bool) isLender;\n  \n  address immutable lendingPlatform;\n  address token = ERC20(USDC_ADDRESS);\n\n  // We use a mapping to store the deposits of all lenders\n  mapping (address => bool) balance;\n\n  // USDC is very stable, so for every 1 USDC you can borrow 1 DAI or 1 USD worth of the other currency\n  // Similar to other lending platforms, this lending system uses an oracle to determine how much one can borrow. \n  // The following describes how the system determines the max borrow value (ignoring precision for simplicity).\n  // maxBorrow = (collateralRatio * underlying * underlyingValueUSD) / otherValueUSD \n  // This encodes the margin requirement of the system.\n  uint collateralRatio = 100_000_000; \n\n  constructor() {\n      periodicFee = 1;\n      \n      // approved collateral contracts are deployed by the lending platform\n      // assume it is implemented correctly, and doesn't allow false collateral contracts.\n      lendingPlatform = msg.sender;\n  }\n\n  function deposit(uint amount) external {\n      require(!isLender[msg.sender]);\n      isLender[msg.sender] = true;\n      lenders.push(msg.sender);\n\n      ...\n  }\n\n  function computeFee(uint periodicFee, uint balance) internal returns (uint) {\n      // Assume this is a correctly implemented function that computes the share of fees that someone should receive based on their balance.\n  }\n \n  // this function is called monthly by the lending platform\n  // We compute how much fees the lender should receive and send it to them\n  function payFees() external onlyLendingPlatform {\n      for (uint i=0; i<lenders.length; i++) {\n        // Compute fee uses the balance of each lender\n         uint fee = computeFee(periodicFee, balance[lenders[i]])\n          token.transferFrom(lendingPlatform, lenders[i], fee);\n      }\n  }\n  ...\n}\n```\n\n**[Q1] Lending platforms have a few options to configure when it comes to adding new tokens as collateral. For example, youll have to set up an oracle for the price of the collateral, and you have to configure a margin requirement. The security concern with using the given collateral configuration is:**\n\n(A): The periodic fee parameter is static\\\n(B): The collateral ratio of loans is too low\\\n(C): USDC should not be used as collateral for loans\\\n(D): None of the above\n\n**[Answers]: B**\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Collateral tokens can define their own fee rewards and have the protocol pay too much fees\\"
      },
      {
        "choice": "B",
        "answer": "There could be many lenders\\"
      },
      {
        "choice": "C",
        "answer": "payFees() might re-enter the contract, paying all fees again\\"
      },
      {
        "choice": "D",
        "answer": "You can deposit at any point during the period \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "D"
    ],
    "race": "RACE-14.md"
  },
  {
    "question": "3] The developers want to prevent people from accidentally sending ETH instead of WETH and have implemented a noETH modifier, as defined above, and annotated the deposit function with it. They have also not implemented a receive function. Which of the following statements is true?",
    "context": "**Note**: Questions 1 & 2 are based on the below code snippet. You will see the same code snippet for these two questions. The question is below the code snippet.\n\n```solidity\ncontract USDCCollateral {\n  // This is a contract that's part of a larger system implementing a lending protocol\n  // This particular contract concerns itself with allowing people to deposit USDC as collateral for their loans\n\n  // A list of all the addresses lending\n  address[] lenders;\n  // A mapping to allow efficient is lender checks\n  mapping(address => bool) isLender;\n  \n  address immutable lendingPlatform;\n  address token = ERC20(USDC_ADDRESS);\n\n  // We use a mapping to store the deposits of all lenders\n  mapping (address => bool) balance;\n\n  // USDC is very stable, so for every 1 USDC you can borrow 1 DAI or 1 USD worth of the other currency\n  // Similar to other lending platforms, this lending system uses an oracle to determine how much one can borrow. \n  // The following describes how the system determines the max borrow value (ignoring precision for simplicity).\n  // maxBorrow = (collateralRatio * underlying * underlyingValueUSD) / otherValueUSD \n  // This encodes the margin requirement of the system.\n  uint collateralRatio = 100_000_000; \n\n  constructor() {\n      periodicFee = 1;\n      \n      // approved collateral contracts are deployed by the lending platform\n      // assume it is implemented correctly, and doesn't allow false collateral contracts.\n      lendingPlatform = msg.sender;\n  }\n\n  function deposit(uint amount) external {\n      require(!isLender[msg.sender]);\n      isLender[msg.sender] = true;\n      lenders.push(msg.sender);\n\n      ...\n  }\n\n  function computeFee(uint periodicFee, uint balance) internal returns (uint) {\n      // Assume this is a correctly implemented function that computes the share of fees that someone should receive based on their balance.\n  }\n \n  // this function is called monthly by the lending platform\n  // We compute how much fees the lender should receive and send it to them\n  function payFees() external onlyLendingPlatform {\n      for (uint i=0; i<lenders.length; i++) {\n        // Compute fee uses the balance of each lender\n         uint fee = computeFee(periodicFee, balance[lenders[i]])\n          token.transferFrom(lendingPlatform, lenders[i], fee);\n      }\n  }\n  ...\n}\n```\n\n**[Q1] Lending platforms have a few options to configure when it comes to adding new tokens as collateral. For example, youll have to set up an oracle for the price of the collateral, and you have to configure a margin requirement. The security concern with using the given collateral configuration is:**\n\n(A): The periodic fee parameter is static\\\n(B): The collateral ratio of loans is too low\\\n(C): USDC should not be used as collateral for loans\\\n(D): None of the above\n\n**[Answers]: B**\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Developers can either use the modifier or achieve the same effect by omitting the payable keyword on deposit function\\"
      },
      {
        "choice": "B",
        "answer": "Developers should use the modifier because it achieves a different effect from omitting the payable keyword on deposit function\\"
      },
      {
        "choice": "C",
        "answer": "Developers should remove the modifier but achieve the required effect by omitting the payable keyword on deposit function\\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-14.md"
  },
  {
    "question": "4] Developers have used assembly to make their code a bit less repetitive. They use it to annotate a bunch of functions that have as their last argument a pool address. Unfortunately they made a mistake. Which of the following options fixes the bug?",
    "context": "**Note**: Questions 1 & 2 are based on the below code snippet. You will see the same code snippet for these two questions. The question is below the code snippet.\n\n```solidity\ncontract USDCCollateral {\n  // This is a contract that's part of a larger system implementing a lending protocol\n  // This particular contract concerns itself with allowing people to deposit USDC as collateral for their loans\n\n  // A list of all the addresses lending\n  address[] lenders;\n  // A mapping to allow efficient is lender checks\n  mapping(address => bool) isLender;\n  \n  address immutable lendingPlatform;\n  address token = ERC20(USDC_ADDRESS);\n\n  // We use a mapping to store the deposits of all lenders\n  mapping (address => bool) balance;\n\n  // USDC is very stable, so for every 1 USDC you can borrow 1 DAI or 1 USD worth of the other currency\n  // Similar to other lending platforms, this lending system uses an oracle to determine how much one can borrow. \n  // The following describes how the system determines the max borrow value (ignoring precision for simplicity).\n  // maxBorrow = (collateralRatio * underlying * underlyingValueUSD) / otherValueUSD \n  // This encodes the margin requirement of the system.\n  uint collateralRatio = 100_000_000; \n\n  constructor() {\n      periodicFee = 1;\n      \n      // approved collateral contracts are deployed by the lending platform\n      // assume it is implemented correctly, and doesn't allow false collateral contracts.\n      lendingPlatform = msg.sender;\n  }\n\n  function deposit(uint amount) external {\n      require(!isLender[msg.sender]);\n      isLender[msg.sender] = true;\n      lenders.push(msg.sender);\n\n      ...\n  }\n\n  function computeFee(uint periodicFee, uint balance) internal returns (uint) {\n      // Assume this is a correctly implemented function that computes the share of fees that someone should receive based on their balance.\n  }\n \n  // this function is called monthly by the lending platform\n  // We compute how much fees the lender should receive and send it to them\n  function payFees() external onlyLendingPlatform {\n      for (uint i=0; i<lenders.length; i++) {\n        // Compute fee uses the balance of each lender\n         uint fee = computeFee(periodicFee, balance[lenders[i]])\n          token.transferFrom(lendingPlatform, lenders[i], fee);\n      }\n  }\n  ...\n}\n```\n\n**[Q1] Lending platforms have a few options to configure when it comes to adding new tokens as collateral. For example, youll have to set up an oracle for the price of the collateral, and you have to configure a margin requirement. The security concern with using the given collateral configuration is:**\n\n(A): The periodic fee parameter is static\\\n(B): The collateral ratio of loans is too low\\\n(C): USDC should not be used as collateral for loans\\\n(D): None of the above\n\n**[Answers]: B**\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Replace the modifier with require(isValid(pool)); in every function with the modifier\\"
      },
      {
        "choice": "B",
        "answer": "Make all functions using checkedPool external\\"
      },
      {
        "choice": "C",
        "answer": "Everything is fine; this code has no problems\\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "race": "RACE-14.md"
  },
  {
    "question": "5] The lending protocol has also built in a liquidation function to be called in the case of under-collateralization. Anyone can call the function and be rewarded for calling it by taking a small percentage of the liquidation. The liquidation function has a vulnerability  which can be exploited because:",
    "context": "**Note**: Questions 1 & 2 are based on the below code snippet. You will see the same code snippet for these two questions. The question is below the code snippet.\n\n```solidity\ncontract USDCCollateral {\n  // This is a contract that's part of a larger system implementing a lending protocol\n  // This particular contract concerns itself with allowing people to deposit USDC as collateral for their loans\n\n  // A list of all the addresses lending\n  address[] lenders;\n  // A mapping to allow efficient is lender checks\n  mapping(address => bool) isLender;\n  \n  address immutable lendingPlatform;\n  address token = ERC20(USDC_ADDRESS);\n\n  // We use a mapping to store the deposits of all lenders\n  mapping (address => bool) balance;\n\n  // USDC is very stable, so for every 1 USDC you can borrow 1 DAI or 1 USD worth of the other currency\n  // Similar to other lending platforms, this lending system uses an oracle to determine how much one can borrow. \n  // The following describes how the system determines the max borrow value (ignoring precision for simplicity).\n  // maxBorrow = (collateralRatio * underlying * underlyingValueUSD) / otherValueUSD \n  // This encodes the margin requirement of the system.\n  uint collateralRatio = 100_000_000; \n\n  constructor() {\n      periodicFee = 1;\n      \n      // approved collateral contracts are deployed by the lending platform\n      // assume it is implemented correctly, and doesn't allow false collateral contracts.\n      lendingPlatform = msg.sender;\n  }\n\n  function deposit(uint amount) external {\n      require(!isLender[msg.sender]);\n      isLender[msg.sender] = true;\n      lenders.push(msg.sender);\n\n      ...\n  }\n\n  function computeFee(uint periodicFee, uint balance) internal returns (uint) {\n      // Assume this is a correctly implemented function that computes the share of fees that someone should receive based on their balance.\n  }\n \n  // this function is called monthly by the lending platform\n  // We compute how much fees the lender should receive and send it to them\n  function payFees() external onlyLendingPlatform {\n      for (uint i=0; i<lenders.length; i++) {\n        // Compute fee uses the balance of each lender\n         uint fee = computeFee(periodicFee, balance[lenders[i]])\n          token.transferFrom(lendingPlatform, lenders[i], fee);\n      }\n  }\n  ...\n}\n```\n\n**[Q1] Lending platforms have a few options to configure when it comes to adding new tokens as collateral. For example, youll have to set up an oracle for the price of the collateral, and you have to configure a margin requirement. The security concern with using the given collateral configuration is:**\n\n(A): The periodic fee parameter is static\\\n(B): The collateral ratio of loans is too low\\\n(C): USDC should not be used as collateral for loans\\\n(D): None of the above\n\n**[Answers]: B**\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The lender can open a position with a low amount of collateral and the fee payout reverts\\"
      },
      {
        "choice": "B",
        "answer": "The lender can make the position unliquidatable with reentrancy\\"
      },
      {
        "choice": "C",
        "answer": "The lender can liquidate other positions with his callback and make more money\\"
      },
      {
        "choice": "D",
        "answer": "The liquidator can take the full collateral amount with reentrancy \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-14.md"
  },
  {
    "question": "6] Assume that the vulnerability referenced in the previous question has been fixed by changing the line with the Liquidation event emission to emit Liquidation(lender, oldDeposit). The protocol team has built a bot that monitors and liquidates under-collateralized positions automatically. Even though the bot does not monitor the mempool, it simulates the full transaction and, if successful, sends transactions with the exact amount to be able to execute the function + 100000 gas for minimal execution in the onLiquidation() callback. Which of these attacks can be executed in a harmful way towards the protocol?",
    "context": "**Note**: Questions 1 & 2 are based on the below code snippet. You will see the same code snippet for these two questions. The question is below the code snippet.\n\n```solidity\ncontract USDCCollateral {\n  // This is a contract that's part of a larger system implementing a lending protocol\n  // This particular contract concerns itself with allowing people to deposit USDC as collateral for their loans\n\n  // A list of all the addresses lending\n  address[] lenders;\n  // A mapping to allow efficient is lender checks\n  mapping(address => bool) isLender;\n  \n  address immutable lendingPlatform;\n  address token = ERC20(USDC_ADDRESS);\n\n  // We use a mapping to store the deposits of all lenders\n  mapping (address => bool) balance;\n\n  // USDC is very stable, so for every 1 USDC you can borrow 1 DAI or 1 USD worth of the other currency\n  // Similar to other lending platforms, this lending system uses an oracle to determine how much one can borrow. \n  // The following describes how the system determines the max borrow value (ignoring precision for simplicity).\n  // maxBorrow = (collateralRatio * underlying * underlyingValueUSD) / otherValueUSD \n  // This encodes the margin requirement of the system.\n  uint collateralRatio = 100_000_000; \n\n  constructor() {\n      periodicFee = 1;\n      \n      // approved collateral contracts are deployed by the lending platform\n      // assume it is implemented correctly, and doesn't allow false collateral contracts.\n      lendingPlatform = msg.sender;\n  }\n\n  function deposit(uint amount) external {\n      require(!isLender[msg.sender]);\n      isLender[msg.sender] = true;\n      lenders.push(msg.sender);\n\n      ...\n  }\n\n  function computeFee(uint periodicFee, uint balance) internal returns (uint) {\n      // Assume this is a correctly implemented function that computes the share of fees that someone should receive based on their balance.\n  }\n \n  // this function is called monthly by the lending platform\n  // We compute how much fees the lender should receive and send it to them\n  function payFees() external onlyLendingPlatform {\n      for (uint i=0; i<lenders.length; i++) {\n        // Compute fee uses the balance of each lender\n         uint fee = computeFee(periodicFee, balance[lenders[i]])\n          token.transferFrom(lendingPlatform, lenders[i], fee);\n      }\n  }\n  ...\n}\n```\n\n**[Q1] Lending platforms have a few options to configure when it comes to adding new tokens as collateral. For example, youll have to set up an oracle for the price of the collateral, and you have to configure a margin requirement. The security concern with using the given collateral configuration is:**\n\n(A): The periodic fee parameter is static\\\n(B): The collateral ratio of loans is too low\\\n(C): USDC should not be used as collateral for loans\\\n(D): None of the above\n\n**[Answers]: B**\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "An attacker can liquidate positions, reenter the contract and steal tokens\\"
      },
      {
        "choice": "B",
        "answer": "The liquidated lender can monitor the mempool and frontrun the protocol bot with a deposit, griefing it\\"
      },
      {
        "choice": "C",
        "answer": "The lender can make their position unliquidatable by consuming all the gas provided in the callback\\"
      },
      {
        "choice": "D",
        "answer": "The liquidated lender can tokenize the extra gas in the callback and make a profit \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-14.md"
  },
  {
    "question": "7] In the context of Questions 5 and 6, someone built a MEV frontrunner bot that is exploiting liquidations in different protocols. It monitors the mempool for collateral contracts deployed from the lending factory and simulates transactions in a mainnet fork within Foundry to check whether it should attack them. The logic behind the bot is that it checks only the tokens Transfer events for its success conditions. More precisely, it checks if there is liquidity in an AMM to exchange to ETH and make sure it turns a profit at the end. If so, it sends a Flashbot bundle to make a profit by frontrunning the liquidator. Knowing the factory for this new contract is permissionless, how could you extract assets out of this bot?",
    "context": "**Note**: Questions 1 & 2 are based on the below code snippet. You will see the same code snippet for these two questions. The question is below the code snippet.\n\n```solidity\ncontract USDCCollateral {\n  // This is a contract that's part of a larger system implementing a lending protocol\n  // This particular contract concerns itself with allowing people to deposit USDC as collateral for their loans\n\n  // A list of all the addresses lending\n  address[] lenders;\n  // A mapping to allow efficient is lender checks\n  mapping(address => bool) isLender;\n  \n  address immutable lendingPlatform;\n  address token = ERC20(USDC_ADDRESS);\n\n  // We use a mapping to store the deposits of all lenders\n  mapping (address => bool) balance;\n\n  // USDC is very stable, so for every 1 USDC you can borrow 1 DAI or 1 USD worth of the other currency\n  // Similar to other lending platforms, this lending system uses an oracle to determine how much one can borrow. \n  // The following describes how the system determines the max borrow value (ignoring precision for simplicity).\n  // maxBorrow = (collateralRatio * underlying * underlyingValueUSD) / otherValueUSD \n  // This encodes the margin requirement of the system.\n  uint collateralRatio = 100_000_000; \n\n  constructor() {\n      periodicFee = 1;\n      \n      // approved collateral contracts are deployed by the lending platform\n      // assume it is implemented correctly, and doesn't allow false collateral contracts.\n      lendingPlatform = msg.sender;\n  }\n\n  function deposit(uint amount) external {\n      require(!isLender[msg.sender]);\n      isLender[msg.sender] = true;\n      lenders.push(msg.sender);\n\n      ...\n  }\n\n  function computeFee(uint periodicFee, uint balance) internal returns (uint) {\n      // Assume this is a correctly implemented function that computes the share of fees that someone should receive based on their balance.\n  }\n \n  // this function is called monthly by the lending platform\n  // We compute how much fees the lender should receive and send it to them\n  function payFees() external onlyLendingPlatform {\n      for (uint i=0; i<lenders.length; i++) {\n        // Compute fee uses the balance of each lender\n         uint fee = computeFee(periodicFee, balance[lenders[i]])\n          token.transferFrom(lendingPlatform, lenders[i], fee);\n      }\n  }\n  ...\n}\n```\n\n**[Q1] Lending platforms have a few options to configure when it comes to adding new tokens as collateral. For example, youll have to set up an oracle for the price of the collateral, and you have to configure a margin requirement. The security concern with using the given collateral configuration is:**\n\n(A): The periodic fee parameter is static\\\n(B): The collateral ratio of loans is too low\\\n(C): USDC should not be used as collateral for loans\\\n(D): None of the above\n\n**[Answers]: B**\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Open a position with a low collateral amount to grief the bot\\"
      },
      {
        "choice": "B",
        "answer": "Build a similar bot that frontruns this one\\"
      },
      {
        "choice": "C",
        "answer": "Deploy a collateral contract with your own custom token and seed an AMM pool with some ETH and this token, tricking the bot\\"
      },
      {
        "choice": "D",
        "answer": "There is no way to do it \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-14.md"
  },
  {
    "question": "8] The protocol implemented a function to transfer collateral from lender A to lender B with a signature from A, as shown above. Is there a way you can break it?",
    "context": "**Note**: Questions 1 & 2 are based on the below code snippet. You will see the same code snippet for these two questions. The question is below the code snippet.\n\n```solidity\ncontract USDCCollateral {\n  // This is a contract that's part of a larger system implementing a lending protocol\n  // This particular contract concerns itself with allowing people to deposit USDC as collateral for their loans\n\n  // A list of all the addresses lending\n  address[] lenders;\n  // A mapping to allow efficient is lender checks\n  mapping(address => bool) isLender;\n  \n  address immutable lendingPlatform;\n  address token = ERC20(USDC_ADDRESS);\n\n  // We use a mapping to store the deposits of all lenders\n  mapping (address => bool) balance;\n\n  // USDC is very stable, so for every 1 USDC you can borrow 1 DAI or 1 USD worth of the other currency\n  // Similar to other lending platforms, this lending system uses an oracle to determine how much one can borrow. \n  // The following describes how the system determines the max borrow value (ignoring precision for simplicity).\n  // maxBorrow = (collateralRatio * underlying * underlyingValueUSD) / otherValueUSD \n  // This encodes the margin requirement of the system.\n  uint collateralRatio = 100_000_000; \n\n  constructor() {\n      periodicFee = 1;\n      \n      // approved collateral contracts are deployed by the lending platform\n      // assume it is implemented correctly, and doesn't allow false collateral contracts.\n      lendingPlatform = msg.sender;\n  }\n\n  function deposit(uint amount) external {\n      require(!isLender[msg.sender]);\n      isLender[msg.sender] = true;\n      lenders.push(msg.sender);\n\n      ...\n  }\n\n  function computeFee(uint periodicFee, uint balance) internal returns (uint) {\n      // Assume this is a correctly implemented function that computes the share of fees that someone should receive based on their balance.\n  }\n \n  // this function is called monthly by the lending platform\n  // We compute how much fees the lender should receive and send it to them\n  function payFees() external onlyLendingPlatform {\n      for (uint i=0; i<lenders.length; i++) {\n        // Compute fee uses the balance of each lender\n         uint fee = computeFee(periodicFee, balance[lenders[i]])\n          token.transferFrom(lendingPlatform, lenders[i], fee);\n      }\n  }\n  ...\n}\n```\n\n**[Q1] Lending platforms have a few options to configure when it comes to adding new tokens as collateral. For example, youll have to set up an oracle for the price of the collateral, and you have to configure a margin requirement. The security concern with using the given collateral configuration is:**\n\n(A): The periodic fee parameter is static\\\n(B): The collateral ratio of loans is too low\\\n(C): USDC should not be used as collateral for loans\\\n(D): None of the above\n\n**[Answers]: B**\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Lender B can get more than the intended amount from lender A (assuming there is more than double the amount in As account)\\"
      },
      {
        "choice": "B",
        "answer": "Lender A can pretend to transfer to lender B but then steal amount from him\\"
      },
      {
        "choice": "C",
        "answer": "Lender A can grief lender B by sending a malformed signature (assuming the S parameter is correct)\\"
      },
      {
        "choice": "D",
        "answer": "Lender B can steal from another lender C, by submitting a malformed signature. \n \n \n"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "race": "RACE-14.md"
  },
  {
    "question": "1] What is/are the correct implementation(s) of the `nonReentrant()` modifier? \\",
    "context": "*\n```\n// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.0.0/contracts/token/ERC20/IERC20.sol\";\n\ncontract SimpleDEX {\n   uint64 public token_balance;\n   uint256 public current_eth;\n   IERC20 public token;\n   uint8 public reentrancy_lock;\n   address owner;\n   uint256 public fees;\n   uint256 public immutable fees_percentage = 10;\n\n   modifier nonReentrant(){\n     // Logic needs to be implemented    \n       _; \n   }\n  \n   modifier onlyOwner(){\n       require(tx.origin == owner, \"Only owner permitted\");\n       _;\n   }\n\n    constructor(uint first_balance, address _token, address _owner) payable {\n        require(_owner != address(0) , \"No zero Address allowed\");\n        require(msg.value >= 100);\n        token = IERC20(_token);\n        bool token_success = token.transferFrom(msg.sender, address(this), first_balance);\n        require (token_success, \"couldn't transfer tokens\");\n        owner = _owner;\n        token_balance = uint64(first_balance);\n        current_eth = msg.value;\n    }\n\n   function setOwner(address _owner) public onlyOwner {\n       owner = _owner;\n   }\n\n   function getTokenBalance() public view returns(uint64 _token_balance) {\n       _token_balance = token_balance;\n   }\n\n   function getCurrentEth() public view returns(uint256 _current_eth) {\n       _current_eth = current_eth;\n   }\n\n   function getEthPrice() public view returns(uint) {\n       return uint256(token_balance) / current_eth;\n   }\n\n   function claimFees() public onlyOwner {\n       bool token_success =  token.transfer(msg.sender, fees);\n       require(token_success, \"couldn't transfer tokens\");\n       token_balance -= uint64(fees); \n       fees = 0;\n   }\n\n   function buyEth(uint amount) external nonReentrant {\n       require(amount >= 10);\n       uint ratio = getEthPrice();\n       uint fee = (amount / 100) * fees_percentage;\n       uint token_amount = ratio * (amount + fee);\n       bool token_success = token.transferFrom(msg.sender, address(this), token_amount);\n       current_eth -= amount;\n       require(token_success, \"couldn't transfer tokens\");\n       (bool success, ) = msg.sender.call{value: amount}(\"\");\n       require(success, \"Failed to transfer Eth\");\n       token_balance += uint64(token_amount);\n       fees += ratio * fee; \n   }\n\n   fallback() payable external {\n       revert();\n   }\n}\n\n\ncontract SimpleDexProxy {\n   function buyEth(address simpleDexAddr, uint amount) external {\n       require(amount > 0, \"Zero amount not allowed\");\n       (bool success, ) = (simpleDexAddr).call(abi.encodeWithSignature(\"buyEth(uint)\", amount));\n       require (success, \"Failed\");\n   }\n}\n\n\ncontract Seller {\n        // Sells tokens to the msg.sender in exchange for eth, according to SimpleDex's getEthPrice() \n        function buyToken(SimpleDEX simpleDexAddr) external  payable {\n            uint ratio = simpleDexAddr.getEthPrice();\n            IERC20 token = simpleDexAddr.token(); \n            uint256 token_amount = msg.value * ratio; \n            token.transfer(msg.sender, token_amount);\n        }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "(A): ```\n require (reentrancy_lock == 1);\n reentrancy_lock = 0;\n _;\n reentrancy_lock = 1;\n ```\n"
      },
      {
        "choice": "B",
        "answer": "(B): ```\n require (reentrancy_lock == 0);\n reentrancy_lock = 1;\n _;\n reentrancy_lock = 0;\n ```\n"
      },
      {
        "choice": "C",
        "answer": "(C): ```\n require (reentrancy_lock == 1);\n reentrancy_lock = 1;\n _;\n reentrancy_lock = 0;\n ```\n"
      },
      {
        "choice": "D",
        "answer": "(D): ```\n require (reentrancy_lock == 0);\n reentrancy_lock = 2;\n _;\n reentrancy_lock = 0;\n ```\n \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "D"
    ],
    "race": "RACE-15.md"
  },
  {
    "question": "2] Who can claim fees using `claimFees()`? \\",
    "context": "*\n```\n// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.0.0/contracts/token/ERC20/IERC20.sol\";\n\ncontract SimpleDEX {\n   uint64 public token_balance;\n   uint256 public current_eth;\n   IERC20 public token;\n   uint8 public reentrancy_lock;\n   address owner;\n   uint256 public fees;\n   uint256 public immutable fees_percentage = 10;\n\n   modifier nonReentrant(){\n     // Logic needs to be implemented    \n       _; \n   }\n  \n   modifier onlyOwner(){\n       require(tx.origin == owner, \"Only owner permitted\");\n       _;\n   }\n\n    constructor(uint first_balance, address _token, address _owner) payable {\n        require(_owner != address(0) , \"No zero Address allowed\");\n        require(msg.value >= 100);\n        token = IERC20(_token);\n        bool token_success = token.transferFrom(msg.sender, address(this), first_balance);\n        require (token_success, \"couldn't transfer tokens\");\n        owner = _owner;\n        token_balance = uint64(first_balance);\n        current_eth = msg.value;\n    }\n\n   function setOwner(address _owner) public onlyOwner {\n       owner = _owner;\n   }\n\n   function getTokenBalance() public view returns(uint64 _token_balance) {\n       _token_balance = token_balance;\n   }\n\n   function getCurrentEth() public view returns(uint256 _current_eth) {\n       _current_eth = current_eth;\n   }\n\n   function getEthPrice() public view returns(uint) {\n       return uint256(token_balance) / current_eth;\n   }\n\n   function claimFees() public onlyOwner {\n       bool token_success =  token.transfer(msg.sender, fees);\n       require(token_success, \"couldn't transfer tokens\");\n       token_balance -= uint64(fees); \n       fees = 0;\n   }\n\n   function buyEth(uint amount) external nonReentrant {\n       require(amount >= 10);\n       uint ratio = getEthPrice();\n       uint fee = (amount / 100) * fees_percentage;\n       uint token_amount = ratio * (amount + fee);\n       bool token_success = token.transferFrom(msg.sender, address(this), token_amount);\n       current_eth -= amount;\n       require(token_success, \"couldn't transfer tokens\");\n       (bool success, ) = msg.sender.call{value: amount}(\"\");\n       require(success, \"Failed to transfer Eth\");\n       token_balance += uint64(token_amount);\n       fees += ratio * fee; \n   }\n\n   fallback() payable external {\n       revert();\n   }\n}\n\n\ncontract SimpleDexProxy {\n   function buyEth(address simpleDexAddr, uint amount) external {\n       require(amount > 0, \"Zero amount not allowed\");\n       (bool success, ) = (simpleDexAddr).call(abi.encodeWithSignature(\"buyEth(uint)\", amount));\n       require (success, \"Failed\");\n   }\n}\n\n\ncontract Seller {\n        // Sells tokens to the msg.sender in exchange for eth, according to SimpleDex's getEthPrice() \n        function buyToken(SimpleDEX simpleDexAddr) external  payable {\n            uint ratio = simpleDexAddr.getEthPrice();\n            IERC20 token = simpleDexAddr.token(); \n            uint256 token_amount = msg.value * ratio; \n            token.transfer(msg.sender, token_amount);\n        }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Only the owner, due to `onlyOwner` modifier \\"
      },
      {
        "choice": "B",
        "answer": "The owner \\"
      },
      {
        "choice": "C",
        "answer": "Anyone who can trick owner into signing an arbitrary transaction \\"
      },
      {
        "choice": "D",
        "answer": "No one \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C"
    ],
    "race": "RACE-15.md"
  },
  {
    "question": "3] In `buyEth()`, we put an `unchecked` block on `current_eth -= amount`: \\",
    "context": "*\n```\n// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.0.0/contracts/token/ERC20/IERC20.sol\";\n\ncontract SimpleDEX {\n   uint64 public token_balance;\n   uint256 public current_eth;\n   IERC20 public token;\n   uint8 public reentrancy_lock;\n   address owner;\n   uint256 public fees;\n   uint256 public immutable fees_percentage = 10;\n\n   modifier nonReentrant(){\n     // Logic needs to be implemented    \n       _; \n   }\n  \n   modifier onlyOwner(){\n       require(tx.origin == owner, \"Only owner permitted\");\n       _;\n   }\n\n    constructor(uint first_balance, address _token, address _owner) payable {\n        require(_owner != address(0) , \"No zero Address allowed\");\n        require(msg.value >= 100);\n        token = IERC20(_token);\n        bool token_success = token.transferFrom(msg.sender, address(this), first_balance);\n        require (token_success, \"couldn't transfer tokens\");\n        owner = _owner;\n        token_balance = uint64(first_balance);\n        current_eth = msg.value;\n    }\n\n   function setOwner(address _owner) public onlyOwner {\n       owner = _owner;\n   }\n\n   function getTokenBalance() public view returns(uint64 _token_balance) {\n       _token_balance = token_balance;\n   }\n\n   function getCurrentEth() public view returns(uint256 _current_eth) {\n       _current_eth = current_eth;\n   }\n\n   function getEthPrice() public view returns(uint) {\n       return uint256(token_balance) / current_eth;\n   }\n\n   function claimFees() public onlyOwner {\n       bool token_success =  token.transfer(msg.sender, fees);\n       require(token_success, \"couldn't transfer tokens\");\n       token_balance -= uint64(fees); \n       fees = 0;\n   }\n\n   function buyEth(uint amount) external nonReentrant {\n       require(amount >= 10);\n       uint ratio = getEthPrice();\n       uint fee = (amount / 100) * fees_percentage;\n       uint token_amount = ratio * (amount + fee);\n       bool token_success = token.transferFrom(msg.sender, address(this), token_amount);\n       current_eth -= amount;\n       require(token_success, \"couldn't transfer tokens\");\n       (bool success, ) = msg.sender.call{value: amount}(\"\");\n       require(success, \"Failed to transfer Eth\");\n       token_balance += uint64(token_amount);\n       fees += ratio * fee; \n   }\n\n   fallback() payable external {\n       revert();\n   }\n}\n\n\ncontract SimpleDexProxy {\n   function buyEth(address simpleDexAddr, uint amount) external {\n       require(amount > 0, \"Zero amount not allowed\");\n       (bool success, ) = (simpleDexAddr).call(abi.encodeWithSignature(\"buyEth(uint)\", amount));\n       require (success, \"Failed\");\n   }\n}\n\n\ncontract Seller {\n        // Sells tokens to the msg.sender in exchange for eth, according to SimpleDex's getEthPrice() \n        function buyToken(SimpleDEX simpleDexAddr) external  payable {\n            uint ratio = simpleDexAddr.getEthPrice();\n            IERC20 token = simpleDexAddr.token(); \n            uint256 token_amount = msg.value * ratio; \n            token.transfer(msg.sender, token_amount);\n        }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Because `current_eth` is `uint` \\"
      },
      {
        "choice": "B",
        "answer": "Because the compiler is protecting us from overflows \\"
      },
      {
        "choice": "C",
        "answer": "Only if we add a prior check:\t\\ `require(current_eth > amount);` \\\n"
      },
      {
        "choice": "D",
        "answer": "Only if we add a prior check: \\ `require(current_eth >= amount);`\n \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-15.md"
  },
  {
    "question": "4] In `buyEth()`, are there any reentrancy concerns assuming the `nonReentrant` modifier is implemented correctly? \\",
    "context": "*\n```\n// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.0.0/contracts/token/ERC20/IERC20.sol\";\n\ncontract SimpleDEX {\n   uint64 public token_balance;\n   uint256 public current_eth;\n   IERC20 public token;\n   uint8 public reentrancy_lock;\n   address owner;\n   uint256 public fees;\n   uint256 public immutable fees_percentage = 10;\n\n   modifier nonReentrant(){\n     // Logic needs to be implemented    \n       _; \n   }\n  \n   modifier onlyOwner(){\n       require(tx.origin == owner, \"Only owner permitted\");\n       _;\n   }\n\n    constructor(uint first_balance, address _token, address _owner) payable {\n        require(_owner != address(0) , \"No zero Address allowed\");\n        require(msg.value >= 100);\n        token = IERC20(_token);\n        bool token_success = token.transferFrom(msg.sender, address(this), first_balance);\n        require (token_success, \"couldn't transfer tokens\");\n        owner = _owner;\n        token_balance = uint64(first_balance);\n        current_eth = msg.value;\n    }\n\n   function setOwner(address _owner) public onlyOwner {\n       owner = _owner;\n   }\n\n   function getTokenBalance() public view returns(uint64 _token_balance) {\n       _token_balance = token_balance;\n   }\n\n   function getCurrentEth() public view returns(uint256 _current_eth) {\n       _current_eth = current_eth;\n   }\n\n   function getEthPrice() public view returns(uint) {\n       return uint256(token_balance) / current_eth;\n   }\n\n   function claimFees() public onlyOwner {\n       bool token_success =  token.transfer(msg.sender, fees);\n       require(token_success, \"couldn't transfer tokens\");\n       token_balance -= uint64(fees); \n       fees = 0;\n   }\n\n   function buyEth(uint amount) external nonReentrant {\n       require(amount >= 10);\n       uint ratio = getEthPrice();\n       uint fee = (amount / 100) * fees_percentage;\n       uint token_amount = ratio * (amount + fee);\n       bool token_success = token.transferFrom(msg.sender, address(this), token_amount);\n       current_eth -= amount;\n       require(token_success, \"couldn't transfer tokens\");\n       (bool success, ) = msg.sender.call{value: amount}(\"\");\n       require(success, \"Failed to transfer Eth\");\n       token_balance += uint64(token_amount);\n       fees += ratio * fee; \n   }\n\n   fallback() payable external {\n       revert();\n   }\n}\n\n\ncontract SimpleDexProxy {\n   function buyEth(address simpleDexAddr, uint amount) external {\n       require(amount > 0, \"Zero amount not allowed\");\n       (bool success, ) = (simpleDexAddr).call(abi.encodeWithSignature(\"buyEth(uint)\", amount));\n       require (success, \"Failed\");\n   }\n}\n\n\ncontract Seller {\n        // Sells tokens to the msg.sender in exchange for eth, according to SimpleDex's getEthPrice() \n        function buyToken(SimpleDEX simpleDexAddr) external  payable {\n            uint ratio = simpleDexAddr.getEthPrice();\n            IERC20 token = simpleDexAddr.token(); \n            uint256 token_amount = msg.value * ratio; \n            token.transfer(msg.sender, token_amount);\n        }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "No, because it has the `nonReentrant` modifier \\"
      },
      {
        "choice": "B",
        "answer": "No, and even without the modifier you can't exploit any issue  \\"
      },
      {
        "choice": "C",
        "answer": "Yes, there is a cross-contract reentrancy concern via `Seller` \\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-15.md"
  },
  {
    "question": "5] What will happen when calling `buyEth()` via `SimpleDexProxy`? \\",
    "context": "*\n```\n// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.0.0/contracts/token/ERC20/IERC20.sol\";\n\ncontract SimpleDEX {\n   uint64 public token_balance;\n   uint256 public current_eth;\n   IERC20 public token;\n   uint8 public reentrancy_lock;\n   address owner;\n   uint256 public fees;\n   uint256 public immutable fees_percentage = 10;\n\n   modifier nonReentrant(){\n     // Logic needs to be implemented    \n       _; \n   }\n  \n   modifier onlyOwner(){\n       require(tx.origin == owner, \"Only owner permitted\");\n       _;\n   }\n\n    constructor(uint first_balance, address _token, address _owner) payable {\n        require(_owner != address(0) , \"No zero Address allowed\");\n        require(msg.value >= 100);\n        token = IERC20(_token);\n        bool token_success = token.transferFrom(msg.sender, address(this), first_balance);\n        require (token_success, \"couldn't transfer tokens\");\n        owner = _owner;\n        token_balance = uint64(first_balance);\n        current_eth = msg.value;\n    }\n\n   function setOwner(address _owner) public onlyOwner {\n       owner = _owner;\n   }\n\n   function getTokenBalance() public view returns(uint64 _token_balance) {\n       _token_balance = token_balance;\n   }\n\n   function getCurrentEth() public view returns(uint256 _current_eth) {\n       _current_eth = current_eth;\n   }\n\n   function getEthPrice() public view returns(uint) {\n       return uint256(token_balance) / current_eth;\n   }\n\n   function claimFees() public onlyOwner {\n       bool token_success =  token.transfer(msg.sender, fees);\n       require(token_success, \"couldn't transfer tokens\");\n       token_balance -= uint64(fees); \n       fees = 0;\n   }\n\n   function buyEth(uint amount) external nonReentrant {\n       require(amount >= 10);\n       uint ratio = getEthPrice();\n       uint fee = (amount / 100) * fees_percentage;\n       uint token_amount = ratio * (amount + fee);\n       bool token_success = token.transferFrom(msg.sender, address(this), token_amount);\n       current_eth -= amount;\n       require(token_success, \"couldn't transfer tokens\");\n       (bool success, ) = msg.sender.call{value: amount}(\"\");\n       require(success, \"Failed to transfer Eth\");\n       token_balance += uint64(token_amount);\n       fees += ratio * fee; \n   }\n\n   fallback() payable external {\n       revert();\n   }\n}\n\n\ncontract SimpleDexProxy {\n   function buyEth(address simpleDexAddr, uint amount) external {\n       require(amount > 0, \"Zero amount not allowed\");\n       (bool success, ) = (simpleDexAddr).call(abi.encodeWithSignature(\"buyEth(uint)\", amount));\n       require (success, \"Failed\");\n   }\n}\n\n\ncontract Seller {\n        // Sells tokens to the msg.sender in exchange for eth, according to SimpleDex's getEthPrice() \n        function buyToken(SimpleDEX simpleDexAddr) external  payable {\n            uint ratio = simpleDexAddr.getEthPrice();\n            IERC20 token = simpleDexAddr.token(); \n            uint256 token_amount = msg.value * ratio; \n            token.transfer(msg.sender, token_amount);\n        }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "`buyEth()` will be called and successfully executed \\"
      },
      {
        "choice": "B",
        "answer": "You cant call a function that way; it must be called directly \\"
      },
      {
        "choice": "C",
        "answer": "`buyEth()` will be called but ETH won't be transferred \\"
      },
      {
        "choice": "D",
        "answer": "Transaction will be reverted \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-15.md"
  },
  {
    "question": "6] In `buyEth()`: \\",
    "context": "*\n```\n// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.0.0/contracts/token/ERC20/IERC20.sol\";\n\ncontract SimpleDEX {\n   uint64 public token_balance;\n   uint256 public current_eth;\n   IERC20 public token;\n   uint8 public reentrancy_lock;\n   address owner;\n   uint256 public fees;\n   uint256 public immutable fees_percentage = 10;\n\n   modifier nonReentrant(){\n     // Logic needs to be implemented    \n       _; \n   }\n  \n   modifier onlyOwner(){\n       require(tx.origin == owner, \"Only owner permitted\");\n       _;\n   }\n\n    constructor(uint first_balance, address _token, address _owner) payable {\n        require(_owner != address(0) , \"No zero Address allowed\");\n        require(msg.value >= 100);\n        token = IERC20(_token);\n        bool token_success = token.transferFrom(msg.sender, address(this), first_balance);\n        require (token_success, \"couldn't transfer tokens\");\n        owner = _owner;\n        token_balance = uint64(first_balance);\n        current_eth = msg.value;\n    }\n\n   function setOwner(address _owner) public onlyOwner {\n       owner = _owner;\n   }\n\n   function getTokenBalance() public view returns(uint64 _token_balance) {\n       _token_balance = token_balance;\n   }\n\n   function getCurrentEth() public view returns(uint256 _current_eth) {\n       _current_eth = current_eth;\n   }\n\n   function getEthPrice() public view returns(uint) {\n       return uint256(token_balance) / current_eth;\n   }\n\n   function claimFees() public onlyOwner {\n       bool token_success =  token.transfer(msg.sender, fees);\n       require(token_success, \"couldn't transfer tokens\");\n       token_balance -= uint64(fees); \n       fees = 0;\n   }\n\n   function buyEth(uint amount) external nonReentrant {\n       require(amount >= 10);\n       uint ratio = getEthPrice();\n       uint fee = (amount / 100) * fees_percentage;\n       uint token_amount = ratio * (amount + fee);\n       bool token_success = token.transferFrom(msg.sender, address(this), token_amount);\n       current_eth -= amount;\n       require(token_success, \"couldn't transfer tokens\");\n       (bool success, ) = msg.sender.call{value: amount}(\"\");\n       require(success, \"Failed to transfer Eth\");\n       token_balance += uint64(token_amount);\n       fees += ratio * fee; \n   }\n\n   fallback() payable external {\n       revert();\n   }\n}\n\n\ncontract SimpleDexProxy {\n   function buyEth(address simpleDexAddr, uint amount) external {\n       require(amount > 0, \"Zero amount not allowed\");\n       (bool success, ) = (simpleDexAddr).call(abi.encodeWithSignature(\"buyEth(uint)\", amount));\n       require (success, \"Failed\");\n   }\n}\n\n\ncontract Seller {\n        // Sells tokens to the msg.sender in exchange for eth, according to SimpleDex's getEthPrice() \n        function buyToken(SimpleDEX simpleDexAddr) external  payable {\n            uint ratio = simpleDexAddr.getEthPrice();\n            IERC20 token = simpleDexAddr.token(); \n            uint256 token_amount = msg.value * ratio; \n            token.transfer(msg.sender, token_amount);\n        }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "If `amount` is less than 100, it will lead to an incorrect calculation of `fee` \\"
      },
      {
        "choice": "B",
        "answer": "If `token_balance` is already at its `MAX_UINT256`, it will result in overflow and won't revert \\"
      },
      {
        "choice": "C",
        "answer": "If `token_amount` is > `MAX_UINT64`, it will result in a casting issue \\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "C"
    ],
    "race": "RACE-15.md"
  },
  {
    "question": "7] Can `getEthPrice()` return zero? \\",
    "context": "*\n```\n// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.0.0/contracts/token/ERC20/IERC20.sol\";\n\ncontract SimpleDEX {\n   uint64 public token_balance;\n   uint256 public current_eth;\n   IERC20 public token;\n   uint8 public reentrancy_lock;\n   address owner;\n   uint256 public fees;\n   uint256 public immutable fees_percentage = 10;\n\n   modifier nonReentrant(){\n     // Logic needs to be implemented    \n       _; \n   }\n  \n   modifier onlyOwner(){\n       require(tx.origin == owner, \"Only owner permitted\");\n       _;\n   }\n\n    constructor(uint first_balance, address _token, address _owner) payable {\n        require(_owner != address(0) , \"No zero Address allowed\");\n        require(msg.value >= 100);\n        token = IERC20(_token);\n        bool token_success = token.transferFrom(msg.sender, address(this), first_balance);\n        require (token_success, \"couldn't transfer tokens\");\n        owner = _owner;\n        token_balance = uint64(first_balance);\n        current_eth = msg.value;\n    }\n\n   function setOwner(address _owner) public onlyOwner {\n       owner = _owner;\n   }\n\n   function getTokenBalance() public view returns(uint64 _token_balance) {\n       _token_balance = token_balance;\n   }\n\n   function getCurrentEth() public view returns(uint256 _current_eth) {\n       _current_eth = current_eth;\n   }\n\n   function getEthPrice() public view returns(uint) {\n       return uint256(token_balance) / current_eth;\n   }\n\n   function claimFees() public onlyOwner {\n       bool token_success =  token.transfer(msg.sender, fees);\n       require(token_success, \"couldn't transfer tokens\");\n       token_balance -= uint64(fees); \n       fees = 0;\n   }\n\n   function buyEth(uint amount) external nonReentrant {\n       require(amount >= 10);\n       uint ratio = getEthPrice();\n       uint fee = (amount / 100) * fees_percentage;\n       uint token_amount = ratio * (amount + fee);\n       bool token_success = token.transferFrom(msg.sender, address(this), token_amount);\n       current_eth -= amount;\n       require(token_success, \"couldn't transfer tokens\");\n       (bool success, ) = msg.sender.call{value: amount}(\"\");\n       require(success, \"Failed to transfer Eth\");\n       token_balance += uint64(token_amount);\n       fees += ratio * fee; \n   }\n\n   fallback() payable external {\n       revert();\n   }\n}\n\n\ncontract SimpleDexProxy {\n   function buyEth(address simpleDexAddr, uint amount) external {\n       require(amount > 0, \"Zero amount not allowed\");\n       (bool success, ) = (simpleDexAddr).call(abi.encodeWithSignature(\"buyEth(uint)\", amount));\n       require (success, \"Failed\");\n   }\n}\n\n\ncontract Seller {\n        // Sells tokens to the msg.sender in exchange for eth, according to SimpleDex's getEthPrice() \n        function buyToken(SimpleDEX simpleDexAddr) external  payable {\n            uint ratio = simpleDexAddr.getEthPrice();\n            IERC20 token = simpleDexAddr.token(); \n            uint256 token_amount = msg.value * ratio; \n            token.transfer(msg.sender, token_amount);\n        }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Yes, if the owner initializes the contract with more ETH than `token_balance` \\"
      },
      {
        "choice": "C",
        "answer": "Yes, once all the ETH are sold \\"
      },
      {
        "choice": "D",
        "answer": "No, there is no issue \n \n \n"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "race": "RACE-15.md"
  },
  {
    "question": "8] Which of the following invariants (written in propositional logic) hold on a correct implementation of the code? \\",
    "context": "*\n```\n// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.0.0/contracts/token/ERC20/IERC20.sol\";\n\ncontract SimpleDEX {\n   uint64 public token_balance;\n   uint256 public current_eth;\n   IERC20 public token;\n   uint8 public reentrancy_lock;\n   address owner;\n   uint256 public fees;\n   uint256 public immutable fees_percentage = 10;\n\n   modifier nonReentrant(){\n     // Logic needs to be implemented    \n       _; \n   }\n  \n   modifier onlyOwner(){\n       require(tx.origin == owner, \"Only owner permitted\");\n       _;\n   }\n\n    constructor(uint first_balance, address _token, address _owner) payable {\n        require(_owner != address(0) , \"No zero Address allowed\");\n        require(msg.value >= 100);\n        token = IERC20(_token);\n        bool token_success = token.transferFrom(msg.sender, address(this), first_balance);\n        require (token_success, \"couldn't transfer tokens\");\n        owner = _owner;\n        token_balance = uint64(first_balance);\n        current_eth = msg.value;\n    }\n\n   function setOwner(address _owner) public onlyOwner {\n       owner = _owner;\n   }\n\n   function getTokenBalance() public view returns(uint64 _token_balance) {\n       _token_balance = token_balance;\n   }\n\n   function getCurrentEth() public view returns(uint256 _current_eth) {\n       _current_eth = current_eth;\n   }\n\n   function getEthPrice() public view returns(uint) {\n       return uint256(token_balance) / current_eth;\n   }\n\n   function claimFees() public onlyOwner {\n       bool token_success =  token.transfer(msg.sender, fees);\n       require(token_success, \"couldn't transfer tokens\");\n       token_balance -= uint64(fees); \n       fees = 0;\n   }\n\n   function buyEth(uint amount) external nonReentrant {\n       require(amount >= 10);\n       uint ratio = getEthPrice();\n       uint fee = (amount / 100) * fees_percentage;\n       uint token_amount = ratio * (amount + fee);\n       bool token_success = token.transferFrom(msg.sender, address(this), token_amount);\n       current_eth -= amount;\n       require(token_success, \"couldn't transfer tokens\");\n       (bool success, ) = msg.sender.call{value: amount}(\"\");\n       require(success, \"Failed to transfer Eth\");\n       token_balance += uint64(token_amount);\n       fees += ratio * fee; \n   }\n\n   fallback() payable external {\n       revert();\n   }\n}\n\n\ncontract SimpleDexProxy {\n   function buyEth(address simpleDexAddr, uint amount) external {\n       require(amount > 0, \"Zero amount not allowed\");\n       (bool success, ) = (simpleDexAddr).call(abi.encodeWithSignature(\"buyEth(uint)\", amount));\n       require (success, \"Failed\");\n   }\n}\n\n\ncontract Seller {\n        // Sells tokens to the msg.sender in exchange for eth, according to SimpleDex's getEthPrice() \n        function buyToken(SimpleDEX simpleDexAddr) external  payable {\n            uint ratio = simpleDexAddr.getEthPrice();\n            IERC20 token = simpleDexAddr.token(); \n            uint256 token_amount = msg.value * ratio; \n            token.transfer(msg.sender, token_amount);\n        }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "`this.balance == current_eth` <=> `token.balanceOf(this) == token_balance` \\"
      },
      {
        "choice": "B",
        "answer": "`this.balance >= current_eth` && `token.balanceOf(this) >= token_balance` \\"
      },
      {
        "choice": "C",
        "answer": "`this.balance <= token.balanceOf(this)` &&  `token.balanceOf(this) <= token_balance` \\"
      },
      {
        "choice": "D",
        "answer": "`this.balance >= current_eth` || `token.balanceOf(this)  >= token_balance` \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "D"
    ],
    "race": "RACE-15.md"
  },
  {
    "question": "1] Which of the following is an explanation of why `flashLoan()` could revert? \\",
    "context": "*\n```\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\ncontract FlashLoan is IERC3156FlashLender {\n   bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n   uint256 public fee;\n\n   /**\n    * @param fee_ the fee that should be paid on a flashloan\n    */\n   constructor (\n       uint256 fee_\n   ) {\n       fee = fee_;\n   }\n\n   /**\n    * @dev The amount of currency available to be lent.\n    * @param token The loan currency.\n    * @return The amount of `token` that can be borrowed.\n    */\n   function maxFlashLoan(\n       address token\n   ) public view override returns (uint256) {\n       return IERC20(token).balanceOf(address(this));\n   }\n\n   /**\n    * @dev The fee to be charged for a given loan.\n    * @param token The loan currency. Must match the address of this contract.\n    * @param amount The amount of tokens lent.\n    * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n    */\n   function flashFee(\n       address token,\n       uint256 amount\n   ) external view override returns (uint256) {\n       return fee;\n   }\n\n   /**\n    * @dev Loan `amount` tokens to `receiver`, and takes it back plus a `flashFee` after the ERC3156 callback.\n    * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n    * @param token The loan currency. Must match the address of this contract.\n    * @param amount The amount of tokens lent.\n    * @param data A data parameter to be passed on to the `receiver` for any custom use.\n    */\n   function flashLoan(\n       IERC3156FlashBorrower receiver,\n       address token,\n       uint256 amount,\n       bytes calldata data\n   ) external override returns (bool){\n       uint256 oldAllowance = IERC20(token).allowance(address(this), address(receiver));\n       uint256 oldBal = IERC20(token).balanceOf(address(this));\n       require(amount <= oldBal, \"Too many funds requested\");\n       IERC20(token).approve(address(receiver), oldAllowance + amount);\n\n       require(\n           receiver.onFlashLoan(msg.sender, token, amount, fee, data) == CALLBACK_SUCCESS,\n           \"Callback failed\"\n       );\n\n       uint256 newBal = IERC20(token).balanceOf(address(this));\n       if(newBal < oldBal + fee) {\n           uint retAmt = oldBal + fee - newBal;\n           require(IERC20(token).transferFrom(msg.sender, address(this), retAmt), \"All funds not returned\");\n       }\n\n       if (IERC20(token).allowance(address(this), address(receiver)) > oldAllowance) {\n           IERC20(token).approve(address(receiver), oldAllowance);\n       }\n       return true;\n   }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The transaction reverts because a user requested to borrow more than `maxFlashLoan()` \\"
      },
      {
        "choice": "B",
        "answer": "The transaction reverts because the receivers `onFlashLoan()` did not return `CALLBACK_SUCCESS` \\"
      },
      {
        "choice": "C",
        "answer": "The transaction reverts because the user returned more than `retAmt` funds \\"
      },
      {
        "choice": "D",
        "answer": "The transaction reverts because a user tried to spend more funds than their allowance in `onFlashLoan()` \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "D"
    ],
    "race": "RACE-16.md"
  },
  {
    "question": "2] If the `FlashLoan` contract were safe, which of the following invariants should hold at the end of any given transaction for some ERC20 token t? Note: old(expr) evaluates expr at the beginning of the transaction. \\",
    "context": "*\n```\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\ncontract FlashLoan is IERC3156FlashLender {\n   bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n   uint256 public fee;\n\n   /**\n    * @param fee_ the fee that should be paid on a flashloan\n    */\n   constructor (\n       uint256 fee_\n   ) {\n       fee = fee_;\n   }\n\n   /**\n    * @dev The amount of currency available to be lent.\n    * @param token The loan currency.\n    * @return The amount of `token` that can be borrowed.\n    */\n   function maxFlashLoan(\n       address token\n   ) public view override returns (uint256) {\n       return IERC20(token).balanceOf(address(this));\n   }\n\n   /**\n    * @dev The fee to be charged for a given loan.\n    * @param token The loan currency. Must match the address of this contract.\n    * @param amount The amount of tokens lent.\n    * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n    */\n   function flashFee(\n       address token,\n       uint256 amount\n   ) external view override returns (uint256) {\n       return fee;\n   }\n\n   /**\n    * @dev Loan `amount` tokens to `receiver`, and takes it back plus a `flashFee` after the ERC3156 callback.\n    * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n    * @param token The loan currency. Must match the address of this contract.\n    * @param amount The amount of tokens lent.\n    * @param data A data parameter to be passed on to the `receiver` for any custom use.\n    */\n   function flashLoan(\n       IERC3156FlashBorrower receiver,\n       address token,\n       uint256 amount,\n       bytes calldata data\n   ) external override returns (bool){\n       uint256 oldAllowance = IERC20(token).allowance(address(this), address(receiver));\n       uint256 oldBal = IERC20(token).balanceOf(address(this));\n       require(amount <= oldBal, \"Too many funds requested\");\n       IERC20(token).approve(address(receiver), oldAllowance + amount);\n\n       require(\n           receiver.onFlashLoan(msg.sender, token, amount, fee, data) == CALLBACK_SUCCESS,\n           \"Callback failed\"\n       );\n\n       uint256 newBal = IERC20(token).balanceOf(address(this));\n       if(newBal < oldBal + fee) {\n           uint retAmt = oldBal + fee - newBal;\n           require(IERC20(token).transferFrom(msg.sender, address(this), retAmt), \"All funds not returned\");\n       }\n\n       if (IERC20(token).allowance(address(this), address(receiver)) > oldAllowance) {\n           IERC20(token).approve(address(receiver), oldAllowance);\n       }\n       return true;\n   }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "t.balanceOf(address(this)) >= old(t.balanceOf(address(this))) \\"
      },
      {
        "choice": "B",
        "answer": "t.balanceOf(address(this)) == old(t.balanceOf(address(this))) \\"
      },
      {
        "choice": "C",
        "answer": "t.balanceOf(address(this)) > old(t.balanceOf(address(this))) \\"
      },
      {
        "choice": "D",
        "answer": "t.balanceOf(address(this)) == old(t.balanceOf(address(this))) + fee \n \n \n"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "race": "RACE-16.md"
  },
  {
    "question": "3] Which of the following tokens would be unsafe for the above contract to loan as doing so could result in theft? \\",
    "context": "*\n```\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\ncontract FlashLoan is IERC3156FlashLender {\n   bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n   uint256 public fee;\n\n   /**\n    * @param fee_ the fee that should be paid on a flashloan\n    */\n   constructor (\n       uint256 fee_\n   ) {\n       fee = fee_;\n   }\n\n   /**\n    * @dev The amount of currency available to be lent.\n    * @param token The loan currency.\n    * @return The amount of `token` that can be borrowed.\n    */\n   function maxFlashLoan(\n       address token\n   ) public view override returns (uint256) {\n       return IERC20(token).balanceOf(address(this));\n   }\n\n   /**\n    * @dev The fee to be charged for a given loan.\n    * @param token The loan currency. Must match the address of this contract.\n    * @param amount The amount of tokens lent.\n    * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n    */\n   function flashFee(\n       address token,\n       uint256 amount\n   ) external view override returns (uint256) {\n       return fee;\n   }\n\n   /**\n    * @dev Loan `amount` tokens to `receiver`, and takes it back plus a `flashFee` after the ERC3156 callback.\n    * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n    * @param token The loan currency. Must match the address of this contract.\n    * @param amount The amount of tokens lent.\n    * @param data A data parameter to be passed on to the `receiver` for any custom use.\n    */\n   function flashLoan(\n       IERC3156FlashBorrower receiver,\n       address token,\n       uint256 amount,\n       bytes calldata data\n   ) external override returns (bool){\n       uint256 oldAllowance = IERC20(token).allowance(address(this), address(receiver));\n       uint256 oldBal = IERC20(token).balanceOf(address(this));\n       require(amount <= oldBal, \"Too many funds requested\");\n       IERC20(token).approve(address(receiver), oldAllowance + amount);\n\n       require(\n           receiver.onFlashLoan(msg.sender, token, amount, fee, data) == CALLBACK_SUCCESS,\n           \"Callback failed\"\n       );\n\n       uint256 newBal = IERC20(token).balanceOf(address(this));\n       if(newBal < oldBal + fee) {\n           uint retAmt = oldBal + fee - newBal;\n           require(IERC20(token).transferFrom(msg.sender, address(this), retAmt), \"All funds not returned\");\n       }\n\n       if (IERC20(token).allowance(address(this), address(receiver)) > oldAllowance) {\n           IERC20(token).approve(address(receiver), oldAllowance);\n       }\n       return true;\n   }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "ERC223 \\"
      },
      {
        "choice": "B",
        "answer": "ERC777 \\"
      },
      {
        "choice": "C",
        "answer": "ERC1155 \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-16.md"
  },
  {
    "question": "4] Which external call made by `flashLoan()` could result in theft if the token(s) identified in the previous question  were to be used? \\",
    "context": "*\n```\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\ncontract FlashLoan is IERC3156FlashLender {\n   bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n   uint256 public fee;\n\n   /**\n    * @param fee_ the fee that should be paid on a flashloan\n    */\n   constructor (\n       uint256 fee_\n   ) {\n       fee = fee_;\n   }\n\n   /**\n    * @dev The amount of currency available to be lent.\n    * @param token The loan currency.\n    * @return The amount of `token` that can be borrowed.\n    */\n   function maxFlashLoan(\n       address token\n   ) public view override returns (uint256) {\n       return IERC20(token).balanceOf(address(this));\n   }\n\n   /**\n    * @dev The fee to be charged for a given loan.\n    * @param token The loan currency. Must match the address of this contract.\n    * @param amount The amount of tokens lent.\n    * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n    */\n   function flashFee(\n       address token,\n       uint256 amount\n   ) external view override returns (uint256) {\n       return fee;\n   }\n\n   /**\n    * @dev Loan `amount` tokens to `receiver`, and takes it back plus a `flashFee` after the ERC3156 callback.\n    * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n    * @param token The loan currency. Must match the address of this contract.\n    * @param amount The amount of tokens lent.\n    * @param data A data parameter to be passed on to the `receiver` for any custom use.\n    */\n   function flashLoan(\n       IERC3156FlashBorrower receiver,\n       address token,\n       uint256 amount,\n       bytes calldata data\n   ) external override returns (bool){\n       uint256 oldAllowance = IERC20(token).allowance(address(this), address(receiver));\n       uint256 oldBal = IERC20(token).balanceOf(address(this));\n       require(amount <= oldBal, \"Too many funds requested\");\n       IERC20(token).approve(address(receiver), oldAllowance + amount);\n\n       require(\n           receiver.onFlashLoan(msg.sender, token, amount, fee, data) == CALLBACK_SUCCESS,\n           \"Callback failed\"\n       );\n\n       uint256 newBal = IERC20(token).balanceOf(address(this));\n       if(newBal < oldBal + fee) {\n           uint retAmt = oldBal + fee - newBal;\n           require(IERC20(token).transferFrom(msg.sender, address(this), retAmt), \"All funds not returned\");\n       }\n\n       if (IERC20(token).allowance(address(this), address(receiver)) > oldAllowance) {\n           IERC20(token).approve(address(receiver), oldAllowance);\n       }\n       return true;\n   }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "`onFlashLoan()` \\"
      },
      {
        "choice": "B",
        "answer": "`balanceOf()` \\"
      },
      {
        "choice": "C",
        "answer": "`transferFrom()` \\"
      },
      {
        "choice": "D",
        "answer": "`approve()` \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-16.md"
  },
  {
    "question": "5] What is the purpose of the fee in the `FlashLoan` contract as is? \\",
    "context": "*\n```\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\ncontract FlashLoan is IERC3156FlashLender {\n   bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n   uint256 public fee;\n\n   /**\n    * @param fee_ the fee that should be paid on a flashloan\n    */\n   constructor (\n       uint256 fee_\n   ) {\n       fee = fee_;\n   }\n\n   /**\n    * @dev The amount of currency available to be lent.\n    * @param token The loan currency.\n    * @return The amount of `token` that can be borrowed.\n    */\n   function maxFlashLoan(\n       address token\n   ) public view override returns (uint256) {\n       return IERC20(token).balanceOf(address(this));\n   }\n\n   /**\n    * @dev The fee to be charged for a given loan.\n    * @param token The loan currency. Must match the address of this contract.\n    * @param amount The amount of tokens lent.\n    * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n    */\n   function flashFee(\n       address token,\n       uint256 amount\n   ) external view override returns (uint256) {\n       return fee;\n   }\n\n   /**\n    * @dev Loan `amount` tokens to `receiver`, and takes it back plus a `flashFee` after the ERC3156 callback.\n    * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n    * @param token The loan currency. Must match the address of this contract.\n    * @param amount The amount of tokens lent.\n    * @param data A data parameter to be passed on to the `receiver` for any custom use.\n    */\n   function flashLoan(\n       IERC3156FlashBorrower receiver,\n       address token,\n       uint256 amount,\n       bytes calldata data\n   ) external override returns (bool){\n       uint256 oldAllowance = IERC20(token).allowance(address(this), address(receiver));\n       uint256 oldBal = IERC20(token).balanceOf(address(this));\n       require(amount <= oldBal, \"Too many funds requested\");\n       IERC20(token).approve(address(receiver), oldAllowance + amount);\n\n       require(\n           receiver.onFlashLoan(msg.sender, token, amount, fee, data) == CALLBACK_SUCCESS,\n           \"Callback failed\"\n       );\n\n       uint256 newBal = IERC20(token).balanceOf(address(this));\n       if(newBal < oldBal + fee) {\n           uint retAmt = oldBal + fee - newBal;\n           require(IERC20(token).transferFrom(msg.sender, address(this), retAmt), \"All funds not returned\");\n       }\n\n       if (IERC20(token).allowance(address(this), address(receiver)) > oldAllowance) {\n           IERC20(token).approve(address(receiver), oldAllowance);\n       }\n       return true;\n   }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "To increase the size of available flashloans over time \\"
      },
      {
        "choice": "B",
        "answer": "To pay the owner of the flashloan contract \\"
      },
      {
        "choice": "C",
        "answer": "To pay those who staked their funds to be flashloaned \\"
      },
      {
        "choice": "D",
        "answer": "It has no purpose \n \n \n"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "race": "RACE-16.md"
  },
  {
    "question": "6] Which of the following describes the behavior of `maxFlashLoan` for a standard ERC20 token over time? \\",
    "context": "*\n```\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\ncontract FlashLoan is IERC3156FlashLender {\n   bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n   uint256 public fee;\n\n   /**\n    * @param fee_ the fee that should be paid on a flashloan\n    */\n   constructor (\n       uint256 fee_\n   ) {\n       fee = fee_;\n   }\n\n   /**\n    * @dev The amount of currency available to be lent.\n    * @param token The loan currency.\n    * @return The amount of `token` that can be borrowed.\n    */\n   function maxFlashLoan(\n       address token\n   ) public view override returns (uint256) {\n       return IERC20(token).balanceOf(address(this));\n   }\n\n   /**\n    * @dev The fee to be charged for a given loan.\n    * @param token The loan currency. Must match the address of this contract.\n    * @param amount The amount of tokens lent.\n    * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n    */\n   function flashFee(\n       address token,\n       uint256 amount\n   ) external view override returns (uint256) {\n       return fee;\n   }\n\n   /**\n    * @dev Loan `amount` tokens to `receiver`, and takes it back plus a `flashFee` after the ERC3156 callback.\n    * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n    * @param token The loan currency. Must match the address of this contract.\n    * @param amount The amount of tokens lent.\n    * @param data A data parameter to be passed on to the `receiver` for any custom use.\n    */\n   function flashLoan(\n       IERC3156FlashBorrower receiver,\n       address token,\n       uint256 amount,\n       bytes calldata data\n   ) external override returns (bool){\n       uint256 oldAllowance = IERC20(token).allowance(address(this), address(receiver));\n       uint256 oldBal = IERC20(token).balanceOf(address(this));\n       require(amount <= oldBal, \"Too many funds requested\");\n       IERC20(token).approve(address(receiver), oldAllowance + amount);\n\n       require(\n           receiver.onFlashLoan(msg.sender, token, amount, fee, data) == CALLBACK_SUCCESS,\n           \"Callback failed\"\n       );\n\n       uint256 newBal = IERC20(token).balanceOf(address(this));\n       if(newBal < oldBal + fee) {\n           uint retAmt = oldBal + fee - newBal;\n           require(IERC20(token).transferFrom(msg.sender, address(this), retAmt), \"All funds not returned\");\n       }\n\n       if (IERC20(token).allowance(address(this), address(receiver)) > oldAllowance) {\n           IERC20(token).approve(address(receiver), oldAllowance);\n       }\n       return true;\n   }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Strictly-increasing \\"
      },
      {
        "choice": "B",
        "answer": "Non-decreasing \\"
      },
      {
        "choice": "C",
        "answer": "Constant \\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-16.md"
  },
  {
    "question": "7] For some arbitrary ERC20 token t, which of the following accurately describes the `FlashLoan` contract's balance of t after a successful (i.e. non-reverting) call to `flashLoan()` (where t is the token requested for the flashloan)? \\",
    "context": "*\n```\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\ncontract FlashLoan is IERC3156FlashLender {\n   bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n   uint256 public fee;\n\n   /**\n    * @param fee_ the fee that should be paid on a flashloan\n    */\n   constructor (\n       uint256 fee_\n   ) {\n       fee = fee_;\n   }\n\n   /**\n    * @dev The amount of currency available to be lent.\n    * @param token The loan currency.\n    * @return The amount of `token` that can be borrowed.\n    */\n   function maxFlashLoan(\n       address token\n   ) public view override returns (uint256) {\n       return IERC20(token).balanceOf(address(this));\n   }\n\n   /**\n    * @dev The fee to be charged for a given loan.\n    * @param token The loan currency. Must match the address of this contract.\n    * @param amount The amount of tokens lent.\n    * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n    */\n   function flashFee(\n       address token,\n       uint256 amount\n   ) external view override returns (uint256) {\n       return fee;\n   }\n\n   /**\n    * @dev Loan `amount` tokens to `receiver`, and takes it back plus a `flashFee` after the ERC3156 callback.\n    * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n    * @param token The loan currency. Must match the address of this contract.\n    * @param amount The amount of tokens lent.\n    * @param data A data parameter to be passed on to the `receiver` for any custom use.\n    */\n   function flashLoan(\n       IERC3156FlashBorrower receiver,\n       address token,\n       uint256 amount,\n       bytes calldata data\n   ) external override returns (bool){\n       uint256 oldAllowance = IERC20(token).allowance(address(this), address(receiver));\n       uint256 oldBal = IERC20(token).balanceOf(address(this));\n       require(amount <= oldBal, \"Too many funds requested\");\n       IERC20(token).approve(address(receiver), oldAllowance + amount);\n\n       require(\n           receiver.onFlashLoan(msg.sender, token, amount, fee, data) == CALLBACK_SUCCESS,\n           \"Callback failed\"\n       );\n\n       uint256 newBal = IERC20(token).balanceOf(address(this));\n       if(newBal < oldBal + fee) {\n           uint retAmt = oldBal + fee - newBal;\n           require(IERC20(token).transferFrom(msg.sender, address(this), retAmt), \"All funds not returned\");\n       }\n\n       if (IERC20(token).allowance(address(this), address(receiver)) > oldAllowance) {\n           IERC20(token).approve(address(receiver), oldAllowance);\n       }\n       return true;\n   }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The `FlashLoan` contract's balance of token t will INCREASE OR STAY THE SAME \\"
      },
      {
        "choice": "B",
        "answer": "The `FlashLoan` contract's balance of token t will DECREASE OR STAY THE SAME \\"
      },
      {
        "choice": "C",
        "answer": "The `FlashLoan` contract's balance of token t will STAY THE SAME \\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-16.md"
  },
  {
    "question": "8] Which of the following are guaranteed to hold after a successful (i.e., non-reverting) execution of `flashLoan()`, assuming the token for which the flashloan is requested uses OpenZeppelins Standard ERC20 implementation? \\",
    "context": "*\n```\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\ncontract FlashLoan is IERC3156FlashLender {\n   bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n   uint256 public fee;\n\n   /**\n    * @param fee_ the fee that should be paid on a flashloan\n    */\n   constructor (\n       uint256 fee_\n   ) {\n       fee = fee_;\n   }\n\n   /**\n    * @dev The amount of currency available to be lent.\n    * @param token The loan currency.\n    * @return The amount of `token` that can be borrowed.\n    */\n   function maxFlashLoan(\n       address token\n   ) public view override returns (uint256) {\n       return IERC20(token).balanceOf(address(this));\n   }\n\n   /**\n    * @dev The fee to be charged for a given loan.\n    * @param token The loan currency. Must match the address of this contract.\n    * @param amount The amount of tokens lent.\n    * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n    */\n   function flashFee(\n       address token,\n       uint256 amount\n   ) external view override returns (uint256) {\n       return fee;\n   }\n\n   /**\n    * @dev Loan `amount` tokens to `receiver`, and takes it back plus a `flashFee` after the ERC3156 callback.\n    * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n    * @param token The loan currency. Must match the address of this contract.\n    * @param amount The amount of tokens lent.\n    * @param data A data parameter to be passed on to the `receiver` for any custom use.\n    */\n   function flashLoan(\n       IERC3156FlashBorrower receiver,\n       address token,\n       uint256 amount,\n       bytes calldata data\n   ) external override returns (bool){\n       uint256 oldAllowance = IERC20(token).allowance(address(this), address(receiver));\n       uint256 oldBal = IERC20(token).balanceOf(address(this));\n       require(amount <= oldBal, \"Too many funds requested\");\n       IERC20(token).approve(address(receiver), oldAllowance + amount);\n\n       require(\n           receiver.onFlashLoan(msg.sender, token, amount, fee, data) == CALLBACK_SUCCESS,\n           \"Callback failed\"\n       );\n\n       uint256 newBal = IERC20(token).balanceOf(address(this));\n       if(newBal < oldBal + fee) {\n           uint retAmt = oldBal + fee - newBal;\n           require(IERC20(token).transferFrom(msg.sender, address(this), retAmt), \"All funds not returned\");\n       }\n\n       if (IERC20(token).allowance(address(this), address(receiver)) > oldAllowance) {\n           IERC20(token).approve(address(receiver), oldAllowance);\n       }\n       return true;\n   }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The receivers balance of token increases \\"
      },
      {
        "choice": "B",
        "answer": "The funds that the `FlashLoan` contract has approved the `receiver` to spend has either stayed the same or decreased \\"
      },
      {
        "choice": "C",
        "answer": "The sum of all flashloans granted by the `FlashLoan` contract is less than the `maxFlashLoan` amount \\"
      },
      {
        "choice": "D",
        "answer": "The token balance of any contract/user other than the `FlashLoan` contract, the caller of the `flashLoan()`, and the receiver contract will remain the same as before the call to `flashLoan()` \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-16.md"
  },
  {
    "question": "1] deposit() can revert: \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity 0.8.19;\n\n\nimport {Pausable} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\";\nimport {IERC20} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ninterface IWETH is IERC20 {\n  function deposit() external payable;\n  function withdraw(uint256) external;\n}\n\n\ncontract Vault is Pausable {\n  using SafeERC20 for IWETH;\n\n\n  address public immutable controller;\n  IWETH public immutable WETH;\n\n\n  // about 4700 ETH\n  uint72 public constant TOTAL_CONTRIBUTION_CAP = type(uint72).max;\n  // ALLOWANCE_CAP = 40% of TOTAL_CONTRIBUTION_CAP\n  uint256 public immutable ALLOWANCE_CAP = 40 * uint256(TOTAL_CONTRIBUTION_CAP) / 100;\n  uint72 public totalContributions;\n  mapping (address => uint72) individualContributions;\n\n\n  uint256 numContributors;\n  event ContributorsUpdated(address newContributor, uint256 indexed oldNumContributors, uint256 indexed newNumContributors);\n\n\n  constructor(address _controller, IWETH _weth) {\n      controller = _controller;\n      WETH = _weth;\n  }\n\n\n  function deposit(uint72 amount) external payable whenNotPaused {\n      if (msg.value > 0) {\n          WETH.deposit{value: amount}();\n      } else {\n          WETH.transferFrom(msg.sender, address(this), amount);\n      }\n      require((totalContributions += amount) <= TOTAL_CONTRIBUTION_CAP, \"cap exceeded\");\n      if (individualContributions[msg.sender] == 0) emit ContributorsUpdated(msg.sender, numContributors, numContributors++);\n      individualContributions[msg.sender] += amount;\n  }\n\n\n  function withdraw(uint72 amount) external whenNotPaused {\n      individualContributions[msg.sender] -= amount;\n      totalContributions -= amount;\n      // unwrap and call\n      WETH.withdraw(amount);\n      (bool success, ) = payable(address(msg.sender)).call{value: amount}(\"\");\n      require(success, \"failed to transfer ETH\");\n  }\n\n\n  function requestAllowance(uint256 amount) external {\n      // ALLOWANCE_CAP is 40% of TOTAL_CAP\n      uint256 allowanceCap = ALLOWANCE_CAP;\n      uint256 allowance = amount > totalContributions ? allowanceCap : amount;\n      WETH.safeApprove(controller, allowance);\n  }\n\n\n  // for unwrapping WETH -> ETH\n  receive() external payable {\n      require(msg.sender == address(WETH), \"only WETH contract\");\n  }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "If insufficient ETH was sent with the call \\"
      },
      {
        "choice": "B",
        "answer": "If the caller has insufficient WETH balance \\"
      },
      {
        "choice": "C",
        "answer": "With the \"cap exceeded\" error \\"
      },
      {
        "choice": "D",
        "answer": "If called internally \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B"
    ],
    "race": "RACE-17.md"
  },
  {
    "question": "2] What issues pertain to the `deposit()` function? \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity 0.8.19;\n\n\nimport {Pausable} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\";\nimport {IERC20} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ninterface IWETH is IERC20 {\n  function deposit() external payable;\n  function withdraw(uint256) external;\n}\n\n\ncontract Vault is Pausable {\n  using SafeERC20 for IWETH;\n\n\n  address public immutable controller;\n  IWETH public immutable WETH;\n\n\n  // about 4700 ETH\n  uint72 public constant TOTAL_CONTRIBUTION_CAP = type(uint72).max;\n  // ALLOWANCE_CAP = 40% of TOTAL_CONTRIBUTION_CAP\n  uint256 public immutable ALLOWANCE_CAP = 40 * uint256(TOTAL_CONTRIBUTION_CAP) / 100;\n  uint72 public totalContributions;\n  mapping (address => uint72) individualContributions;\n\n\n  uint256 numContributors;\n  event ContributorsUpdated(address newContributor, uint256 indexed oldNumContributors, uint256 indexed newNumContributors);\n\n\n  constructor(address _controller, IWETH _weth) {\n      controller = _controller;\n      WETH = _weth;\n  }\n\n\n  function deposit(uint72 amount) external payable whenNotPaused {\n      if (msg.value > 0) {\n          WETH.deposit{value: amount}();\n      } else {\n          WETH.transferFrom(msg.sender, address(this), amount);\n      }\n      require((totalContributions += amount) <= TOTAL_CONTRIBUTION_CAP, \"cap exceeded\");\n      if (individualContributions[msg.sender] == 0) emit ContributorsUpdated(msg.sender, numContributors, numContributors++);\n      individualContributions[msg.sender] += amount;\n  }\n\n\n  function withdraw(uint72 amount) external whenNotPaused {\n      individualContributions[msg.sender] -= amount;\n      totalContributions -= amount;\n      // unwrap and call\n      WETH.withdraw(amount);\n      (bool success, ) = payable(address(msg.sender)).call{value: amount}(\"\");\n      require(success, \"failed to transfer ETH\");\n  }\n\n\n  function requestAllowance(uint256 amount) external {\n      // ALLOWANCE_CAP is 40% of TOTAL_CAP\n      uint256 allowanceCap = ALLOWANCE_CAP;\n      uint256 allowance = amount > totalContributions ? allowanceCap : amount;\n      WETH.safeApprove(controller, allowance);\n  }\n\n\n  // for unwrapping WETH -> ETH\n  receive() external payable {\n      require(msg.sender == address(WETH), \"only WETH contract\");\n  }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Funds can be drained through re-entrancy \\"
      },
      {
        "choice": "B",
        "answer": "Accounting mismatch if user specifies `amount` > `msg.value` \\"
      },
      {
        "choice": "C",
        "answer": "Accounting mismatch if user specifies `amount` < `msg.value` \\"
      },
      {
        "choice": "D",
        "answer": "`totalContributionCap` isn't enforced on an individual level \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-17.md"
  },
  {
    "question": "3] Which of the following is/are true about `withdraw()`? \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity 0.8.19;\n\n\nimport {Pausable} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\";\nimport {IERC20} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ninterface IWETH is IERC20 {\n  function deposit() external payable;\n  function withdraw(uint256) external;\n}\n\n\ncontract Vault is Pausable {\n  using SafeERC20 for IWETH;\n\n\n  address public immutable controller;\n  IWETH public immutable WETH;\n\n\n  // about 4700 ETH\n  uint72 public constant TOTAL_CONTRIBUTION_CAP = type(uint72).max;\n  // ALLOWANCE_CAP = 40% of TOTAL_CONTRIBUTION_CAP\n  uint256 public immutable ALLOWANCE_CAP = 40 * uint256(TOTAL_CONTRIBUTION_CAP) / 100;\n  uint72 public totalContributions;\n  mapping (address => uint72) individualContributions;\n\n\n  uint256 numContributors;\n  event ContributorsUpdated(address newContributor, uint256 indexed oldNumContributors, uint256 indexed newNumContributors);\n\n\n  constructor(address _controller, IWETH _weth) {\n      controller = _controller;\n      WETH = _weth;\n  }\n\n\n  function deposit(uint72 amount) external payable whenNotPaused {\n      if (msg.value > 0) {\n          WETH.deposit{value: amount}();\n      } else {\n          WETH.transferFrom(msg.sender, address(this), amount);\n      }\n      require((totalContributions += amount) <= TOTAL_CONTRIBUTION_CAP, \"cap exceeded\");\n      if (individualContributions[msg.sender] == 0) emit ContributorsUpdated(msg.sender, numContributors, numContributors++);\n      individualContributions[msg.sender] += amount;\n  }\n\n\n  function withdraw(uint72 amount) external whenNotPaused {\n      individualContributions[msg.sender] -= amount;\n      totalContributions -= amount;\n      // unwrap and call\n      WETH.withdraw(amount);\n      (bool success, ) = payable(address(msg.sender)).call{value: amount}(\"\");\n      require(success, \"failed to transfer ETH\");\n  }\n\n\n  function requestAllowance(uint256 amount) external {\n      // ALLOWANCE_CAP is 40% of TOTAL_CAP\n      uint256 allowanceCap = ALLOWANCE_CAP;\n      uint256 allowance = amount > totalContributions ? allowanceCap : amount;\n      WETH.safeApprove(controller, allowance);\n  }\n\n\n  // for unwrapping WETH -> ETH\n  receive() external payable {\n      require(msg.sender == address(WETH), \"only WETH contract\");\n  }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Funds can be drained through re-entrancy \\"
      },
      {
        "choice": "B",
        "answer": "Funds can be drained due to improper amount accounting in `deposit()` \\"
      },
      {
        "choice": "C",
        "answer": "Assuming a sufficiently high gas limit, the function reverts from the recipient (caller) consuming all forwarded gas \\"
      },
      {
        "choice": "D",
        "answer": "May revert with \"failed to transfer ETH\" \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-17.md"
  },
  {
    "question": "4] Which of the following parameters are correctly emitted in the `ContributorsUpdated()` event? \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity 0.8.19;\n\n\nimport {Pausable} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\";\nimport {IERC20} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ninterface IWETH is IERC20 {\n  function deposit() external payable;\n  function withdraw(uint256) external;\n}\n\n\ncontract Vault is Pausable {\n  using SafeERC20 for IWETH;\n\n\n  address public immutable controller;\n  IWETH public immutable WETH;\n\n\n  // about 4700 ETH\n  uint72 public constant TOTAL_CONTRIBUTION_CAP = type(uint72).max;\n  // ALLOWANCE_CAP = 40% of TOTAL_CONTRIBUTION_CAP\n  uint256 public immutable ALLOWANCE_CAP = 40 * uint256(TOTAL_CONTRIBUTION_CAP) / 100;\n  uint72 public totalContributions;\n  mapping (address => uint72) individualContributions;\n\n\n  uint256 numContributors;\n  event ContributorsUpdated(address newContributor, uint256 indexed oldNumContributors, uint256 indexed newNumContributors);\n\n\n  constructor(address _controller, IWETH _weth) {\n      controller = _controller;\n      WETH = _weth;\n  }\n\n\n  function deposit(uint72 amount) external payable whenNotPaused {\n      if (msg.value > 0) {\n          WETH.deposit{value: amount}();\n      } else {\n          WETH.transferFrom(msg.sender, address(this), amount);\n      }\n      require((totalContributions += amount) <= TOTAL_CONTRIBUTION_CAP, \"cap exceeded\");\n      if (individualContributions[msg.sender] == 0) emit ContributorsUpdated(msg.sender, numContributors, numContributors++);\n      individualContributions[msg.sender] += amount;\n  }\n\n\n  function withdraw(uint72 amount) external whenNotPaused {\n      individualContributions[msg.sender] -= amount;\n      totalContributions -= amount;\n      // unwrap and call\n      WETH.withdraw(amount);\n      (bool success, ) = payable(address(msg.sender)).call{value: amount}(\"\");\n      require(success, \"failed to transfer ETH\");\n  }\n\n\n  function requestAllowance(uint256 amount) external {\n      // ALLOWANCE_CAP is 40% of TOTAL_CAP\n      uint256 allowanceCap = ALLOWANCE_CAP;\n      uint256 allowance = amount > totalContributions ? allowanceCap : amount;\n      WETH.safeApprove(controller, allowance);\n  }\n\n\n  // for unwrapping WETH -> ETH\n  receive() external payable {\n      require(msg.sender == address(WETH), \"only WETH contract\");\n  }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "`newContributor` \\"
      },
      {
        "choice": "B",
        "answer": "`oldNumContributors` \\"
      },
      {
        "choice": "C",
        "answer": "`newNumContributors` \\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "race": "RACE-17.md"
  },
  {
    "question": "5] The vault deployer can pause the following functions: \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity 0.8.19;\n\n\nimport {Pausable} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\";\nimport {IERC20} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ninterface IWETH is IERC20 {\n  function deposit() external payable;\n  function withdraw(uint256) external;\n}\n\n\ncontract Vault is Pausable {\n  using SafeERC20 for IWETH;\n\n\n  address public immutable controller;\n  IWETH public immutable WETH;\n\n\n  // about 4700 ETH\n  uint72 public constant TOTAL_CONTRIBUTION_CAP = type(uint72).max;\n  // ALLOWANCE_CAP = 40% of TOTAL_CONTRIBUTION_CAP\n  uint256 public immutable ALLOWANCE_CAP = 40 * uint256(TOTAL_CONTRIBUTION_CAP) / 100;\n  uint72 public totalContributions;\n  mapping (address => uint72) individualContributions;\n\n\n  uint256 numContributors;\n  event ContributorsUpdated(address newContributor, uint256 indexed oldNumContributors, uint256 indexed newNumContributors);\n\n\n  constructor(address _controller, IWETH _weth) {\n      controller = _controller;\n      WETH = _weth;\n  }\n\n\n  function deposit(uint72 amount) external payable whenNotPaused {\n      if (msg.value > 0) {\n          WETH.deposit{value: amount}();\n      } else {\n          WETH.transferFrom(msg.sender, address(this), amount);\n      }\n      require((totalContributions += amount) <= TOTAL_CONTRIBUTION_CAP, \"cap exceeded\");\n      if (individualContributions[msg.sender] == 0) emit ContributorsUpdated(msg.sender, numContributors, numContributors++);\n      individualContributions[msg.sender] += amount;\n  }\n\n\n  function withdraw(uint72 amount) external whenNotPaused {\n      individualContributions[msg.sender] -= amount;\n      totalContributions -= amount;\n      // unwrap and call\n      WETH.withdraw(amount);\n      (bool success, ) = payable(address(msg.sender)).call{value: amount}(\"\");\n      require(success, \"failed to transfer ETH\");\n  }\n\n\n  function requestAllowance(uint256 amount) external {\n      // ALLOWANCE_CAP is 40% of TOTAL_CAP\n      uint256 allowanceCap = ALLOWANCE_CAP;\n      uint256 allowance = amount > totalContributions ? allowanceCap : amount;\n      WETH.safeApprove(controller, allowance);\n  }\n\n\n  // for unwrapping WETH -> ETH\n  receive() external payable {\n      require(msg.sender == address(WETH), \"only WETH contract\");\n  }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "`deposit()` \\"
      },
      {
        "choice": "B",
        "answer": "`withdraw()` \\"
      },
      {
        "choice": "C",
        "answer": "`requestAllowance()` \\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-17.md"
  },
  {
    "question": "6] What is the largest possible allowance given to the controller? \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity 0.8.19;\n\n\nimport {Pausable} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\";\nimport {IERC20} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ninterface IWETH is IERC20 {\n  function deposit() external payable;\n  function withdraw(uint256) external;\n}\n\n\ncontract Vault is Pausable {\n  using SafeERC20 for IWETH;\n\n\n  address public immutable controller;\n  IWETH public immutable WETH;\n\n\n  // about 4700 ETH\n  uint72 public constant TOTAL_CONTRIBUTION_CAP = type(uint72).max;\n  // ALLOWANCE_CAP = 40% of TOTAL_CONTRIBUTION_CAP\n  uint256 public immutable ALLOWANCE_CAP = 40 * uint256(TOTAL_CONTRIBUTION_CAP) / 100;\n  uint72 public totalContributions;\n  mapping (address => uint72) individualContributions;\n\n\n  uint256 numContributors;\n  event ContributorsUpdated(address newContributor, uint256 indexed oldNumContributors, uint256 indexed newNumContributors);\n\n\n  constructor(address _controller, IWETH _weth) {\n      controller = _controller;\n      WETH = _weth;\n  }\n\n\n  function deposit(uint72 amount) external payable whenNotPaused {\n      if (msg.value > 0) {\n          WETH.deposit{value: amount}();\n      } else {\n          WETH.transferFrom(msg.sender, address(this), amount);\n      }\n      require((totalContributions += amount) <= TOTAL_CONTRIBUTION_CAP, \"cap exceeded\");\n      if (individualContributions[msg.sender] == 0) emit ContributorsUpdated(msg.sender, numContributors, numContributors++);\n      individualContributions[msg.sender] += amount;\n  }\n\n\n  function withdraw(uint72 amount) external whenNotPaused {\n      individualContributions[msg.sender] -= amount;\n      totalContributions -= amount;\n      // unwrap and call\n      WETH.withdraw(amount);\n      (bool success, ) = payable(address(msg.sender)).call{value: amount}(\"\");\n      require(success, \"failed to transfer ETH\");\n  }\n\n\n  function requestAllowance(uint256 amount) external {\n      // ALLOWANCE_CAP is 40% of TOTAL_CAP\n      uint256 allowanceCap = ALLOWANCE_CAP;\n      uint256 allowance = amount > totalContributions ? allowanceCap : amount;\n      WETH.safeApprove(controller, allowance);\n  }\n\n\n  // for unwrapping WETH -> ETH\n  receive() external payable {\n      require(msg.sender == address(WETH), \"only WETH contract\");\n  }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "40% of `totalContributionCap` \\"
      },
      {
        "choice": "B",
        "answer": "60% of `totalContributionCap` \\"
      },
      {
        "choice": "C",
        "answer": "100% of `totalContributionCap` \\"
      },
      {
        "choice": "D",
        "answer": "Unbounded \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-17.md"
  },
  {
    "question": "7] The `requestAllowance()` implementation would have failed after the 1st call for tokens that only allow zero to non-zero allowances. Which of the following mitigations do NOT work? \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity 0.8.19;\n\n\nimport {Pausable} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\";\nimport {IERC20} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ninterface IWETH is IERC20 {\n  function deposit() external payable;\n  function withdraw(uint256) external;\n}\n\n\ncontract Vault is Pausable {\n  using SafeERC20 for IWETH;\n\n\n  address public immutable controller;\n  IWETH public immutable WETH;\n\n\n  // about 4700 ETH\n  uint72 public constant TOTAL_CONTRIBUTION_CAP = type(uint72).max;\n  // ALLOWANCE_CAP = 40% of TOTAL_CONTRIBUTION_CAP\n  uint256 public immutable ALLOWANCE_CAP = 40 * uint256(TOTAL_CONTRIBUTION_CAP) / 100;\n  uint72 public totalContributions;\n  mapping (address => uint72) individualContributions;\n\n\n  uint256 numContributors;\n  event ContributorsUpdated(address newContributor, uint256 indexed oldNumContributors, uint256 indexed newNumContributors);\n\n\n  constructor(address _controller, IWETH _weth) {\n      controller = _controller;\n      WETH = _weth;\n  }\n\n\n  function deposit(uint72 amount) external payable whenNotPaused {\n      if (msg.value > 0) {\n          WETH.deposit{value: amount}();\n      } else {\n          WETH.transferFrom(msg.sender, address(this), amount);\n      }\n      require((totalContributions += amount) <= TOTAL_CONTRIBUTION_CAP, \"cap exceeded\");\n      if (individualContributions[msg.sender] == 0) emit ContributorsUpdated(msg.sender, numContributors, numContributors++);\n      individualContributions[msg.sender] += amount;\n  }\n\n\n  function withdraw(uint72 amount) external whenNotPaused {\n      individualContributions[msg.sender] -= amount;\n      totalContributions -= amount;\n      // unwrap and call\n      WETH.withdraw(amount);\n      (bool success, ) = payable(address(msg.sender)).call{value: amount}(\"\");\n      require(success, \"failed to transfer ETH\");\n  }\n\n\n  function requestAllowance(uint256 amount) external {\n      // ALLOWANCE_CAP is 40% of TOTAL_CAP\n      uint256 allowanceCap = ALLOWANCE_CAP;\n      uint256 allowance = amount > totalContributions ? allowanceCap : amount;\n      WETH.safeApprove(controller, allowance);\n  }\n\n\n  // for unwrapping WETH -> ETH\n  receive() external payable {\n      require(msg.sender == address(WETH), \"only WETH contract\");\n  }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "`safeApprove(0)` followed by `safeApprove(type(uint256).max)` \\"
      },
      {
        "choice": "B",
        "answer": "`safeIncreaseAllowance(type(uint256).max)` \\"
      },
      {
        "choice": "C",
        "answer": "`safeIncreaseAllowance(0)` followed by `safeIncreaseAllowance(type(uint256).max)` \\"
      },
      {
        "choice": "D",
        "answer": "`safeDecreaseAllowance(0)` followed by `safeApprove(type(uint256).max)` \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C",
      "D"
    ],
    "race": "RACE-17.md"
  },
  {
    "question": "8] Which of the following gas optimizations are relevant in reducing runtime gas costs for the vault contract? \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity 0.8.19;\n\n\nimport {Pausable} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\";\nimport {IERC20} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ninterface IWETH is IERC20 {\n  function deposit() external payable;\n  function withdraw(uint256) external;\n}\n\n\ncontract Vault is Pausable {\n  using SafeERC20 for IWETH;\n\n\n  address public immutable controller;\n  IWETH public immutable WETH;\n\n\n  // about 4700 ETH\n  uint72 public constant TOTAL_CONTRIBUTION_CAP = type(uint72).max;\n  // ALLOWANCE_CAP = 40% of TOTAL_CONTRIBUTION_CAP\n  uint256 public immutable ALLOWANCE_CAP = 40 * uint256(TOTAL_CONTRIBUTION_CAP) / 100;\n  uint72 public totalContributions;\n  mapping (address => uint72) individualContributions;\n\n\n  uint256 numContributors;\n  event ContributorsUpdated(address newContributor, uint256 indexed oldNumContributors, uint256 indexed newNumContributors);\n\n\n  constructor(address _controller, IWETH _weth) {\n      controller = _controller;\n      WETH = _weth;\n  }\n\n\n  function deposit(uint72 amount) external payable whenNotPaused {\n      if (msg.value > 0) {\n          WETH.deposit{value: amount}();\n      } else {\n          WETH.transferFrom(msg.sender, address(this), amount);\n      }\n      require((totalContributions += amount) <= TOTAL_CONTRIBUTION_CAP, \"cap exceeded\");\n      if (individualContributions[msg.sender] == 0) emit ContributorsUpdated(msg.sender, numContributors, numContributors++);\n      individualContributions[msg.sender] += amount;\n  }\n\n\n  function withdraw(uint72 amount) external whenNotPaused {\n      individualContributions[msg.sender] -= amount;\n      totalContributions -= amount;\n      // unwrap and call\n      WETH.withdraw(amount);\n      (bool success, ) = payable(address(msg.sender)).call{value: amount}(\"\");\n      require(success, \"failed to transfer ETH\");\n  }\n\n\n  function requestAllowance(uint256 amount) external {\n      // ALLOWANCE_CAP is 40% of TOTAL_CAP\n      uint256 allowanceCap = ALLOWANCE_CAP;\n      uint256 allowance = amount > totalContributions ? allowanceCap : amount;\n      WETH.safeApprove(controller, allowance);\n  }\n\n\n  // for unwrapping WETH -> ETH\n  receive() external payable {\n      require(msg.sender == address(WETH), \"only WETH contract\");\n  }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Changing `ALLOWANCE_CAP` type from immutable to constant, ie. `uint256 public constant ALLOWANCE_CAP = 40 * uint256(TOTAL_CONTRIBUTION_CAP) / 100;` \\"
      },
      {
        "choice": "B",
        "answer": "Increase number of solc runs (assuming default was 200 runs) \\"
      },
      {
        "choice": "C",
        "answer": "Renaming functions so that the most used functions have smaller method IDs \\"
      },
      {
        "choice": "D",
        "answer": "Use `unchecked` math in `withdraw()` \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C"
    ],
    "race": "RACE-17.md"
  },
  {
    "question": "1] What risk(s) should be considered when reviewing this contract? \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity ^0.8.0; // using 0.8 to be safe from arithmetic risks\n\ninterface IERC20 {\n   function decimals() external view returns (uint256);\n   function balanceOf(address account) external view returns (uint256);\n   function transfer(address to, uint256 amount) external returns (bool);\n   function allowance(address owner, address spender) external view returns (uint256);\n   function approve(address spender, uint256 amount) external returns (bool);\n   function transferFrom(address from, address to, uint256 amount) external returns (bool);\n   function totalSupply() external view returns (uint256);\n\n   // Mint tokens\n   // The access controls only allows the Bank contract to call this function\n   // mint does not have callback (i.e. it does not allow reentrancies)\n   // [Secureum] Assume no bug\n   function mint(uint amount, address to) external;\n\n   // Burn token\n   // The access controls only allows the Bank contract to call this function\n   // burn does not have callback (i.e. it does not allow reentrancies)\n   // [Secureum] Assume no bug\n   function burn(uint amount, address to) external;\n}\n\n// This contract allows to deposit ether and mint tokens by locking Ether, at a rate of 1 ether = 10 tokens\n// The user needs to burn the token to unlock their balance\n// Once they minted tokens, the user cannot mint more, unless they burned the original amount\n// This contract is safe from reentrancies and front running risks\ncontract Bank{\n\n   mapping(address => uint) balances;\n   mapping(address => uint) minted;\n   uint decimals_factor = 10**18;\n   IERC20 token;\n\n   uint8 isReenter = 1;\n   modifier nonReentrant{\n       require(isReenter>=1);\n       isReenter = 2;\n       _;\n       isReenter = 1;\n   }\n\n   constructor(address token_address){\n       token = IERC20(token_address);\n       // Only accept tokens with 18 decimals to ease the math\n       require(token.decimals() == 18);\n   }\n\n   /***\n   Deposit function\n   ***/\n\n   function deposit(uint amount) internal{\n       balances[msg.sender] += amount;\n   }\n\n   function deposit() payable nonReentrant public{\n       deposit(msg.value);\n   }\n\n   function depositTo(address to) payable nonReentrant public{\n       balances[to] = msg.value;\n   }\n\n   /***\n   Getter\n   ***/\n\n   // Return the balance of the user\n   function getBalances(address user) public nonReentrant returns(uint balance){\n       uint balance = balances[user];\n   }\n\n   /***\n   Withdraw functions\n   ***/\n\n   function withdraw(uint amount) nonReentrant public{\n       // Cannot withdraw if some tokens have been minted\n       require(minted[msg.sender]==0);\n       msg.sender.call{value: amount}(\"\");\n       balances[msg.sender] -= amount;\n   }\n\n   function withdrawAll() nonReentrant public{\n       // Cannot withdraw if some tokens have been minted\n       require(minted[msg.sender]==0);\n       balances[msg.sender] = 0;\n       msg.sender.call{value: balances[msg.sender]}(\"\");\n   }\n\n   /***\n   Mint/burn functions\n   ***/\n\n   // Mint tokens\n   // The user must have locked enough ether in the contract\n   // This function only mint whole number and not fraction.\n   // As a result, amount is expressed without the decimals.\n   // To mint 10 tokens, call mint(10);\n   // @param amount The number of tokens to be minted. amount is the whole number.\n   function mint(uint amount) nonReentrant public{\n       // Cannot mint if some tokens have already been minted\n       require(minted[msg.sender]==0);\n\n       _has_enough_balance(amount, balances[msg.sender]);\n       minted[msg.sender] = amount * decimals_factor;\n       // [Secureum] Assume token.mint has no bug and no callback\n       token.mint(amount * decimals_factor, msg.sender);\n   }\n\n   /// @notice burn the token and unlock the account.\n   function burn() nonReentrant public{\n       // This will revert if the user does not have minted[msg.sender] tokens in its balance\n       require(token.balanceOf(msg.sender) == minted[msg.sender]);\n       // [Secureum] Assume token.burn has no bug and no callback\n       token.burn(minted[msg.sender], msg.sender);\n       minted[msg.sender] = 0;\n   }\n\n   /// @notice Ensure that enough ethers are locked. 1 ether allows to mint 10 tokens\n   /// @param desired_tokens The number of tokens to buy\n   /// @param balance The ether balance available\n   function _has_enough_balance(uint256 desired_tokens, uint256 balance) internal view {\n       uint256 required_balance = (desired_tokens / 10) * decimals_factor;\n       require(balance >= required_balance);\n   }\n\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Reentrancy risks \\"
      },
      {
        "choice": "B",
        "answer": "Logic bugs \\"
      },
      {
        "choice": "C",
        "answer": "Front-running risks \\"
      },
      {
        "choice": "D",
        "answer": "Arithmetic risks \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C",
      "D"
    ],
    "race": "RACE-18.md"
  },
  {
    "question": "2] Which of the following statement(s) is/are true? \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity ^0.8.0; // using 0.8 to be safe from arithmetic risks\n\ninterface IERC20 {\n   function decimals() external view returns (uint256);\n   function balanceOf(address account) external view returns (uint256);\n   function transfer(address to, uint256 amount) external returns (bool);\n   function allowance(address owner, address spender) external view returns (uint256);\n   function approve(address spender, uint256 amount) external returns (bool);\n   function transferFrom(address from, address to, uint256 amount) external returns (bool);\n   function totalSupply() external view returns (uint256);\n\n   // Mint tokens\n   // The access controls only allows the Bank contract to call this function\n   // mint does not have callback (i.e. it does not allow reentrancies)\n   // [Secureum] Assume no bug\n   function mint(uint amount, address to) external;\n\n   // Burn token\n   // The access controls only allows the Bank contract to call this function\n   // burn does not have callback (i.e. it does not allow reentrancies)\n   // [Secureum] Assume no bug\n   function burn(uint amount, address to) external;\n}\n\n// This contract allows to deposit ether and mint tokens by locking Ether, at a rate of 1 ether = 10 tokens\n// The user needs to burn the token to unlock their balance\n// Once they minted tokens, the user cannot mint more, unless they burned the original amount\n// This contract is safe from reentrancies and front running risks\ncontract Bank{\n\n   mapping(address => uint) balances;\n   mapping(address => uint) minted;\n   uint decimals_factor = 10**18;\n   IERC20 token;\n\n   uint8 isReenter = 1;\n   modifier nonReentrant{\n       require(isReenter>=1);\n       isReenter = 2;\n       _;\n       isReenter = 1;\n   }\n\n   constructor(address token_address){\n       token = IERC20(token_address);\n       // Only accept tokens with 18 decimals to ease the math\n       require(token.decimals() == 18);\n   }\n\n   /***\n   Deposit function\n   ***/\n\n   function deposit(uint amount) internal{\n       balances[msg.sender] += amount;\n   }\n\n   function deposit() payable nonReentrant public{\n       deposit(msg.value);\n   }\n\n   function depositTo(address to) payable nonReentrant public{\n       balances[to] = msg.value;\n   }\n\n   /***\n   Getter\n   ***/\n\n   // Return the balance of the user\n   function getBalances(address user) public nonReentrant returns(uint balance){\n       uint balance = balances[user];\n   }\n\n   /***\n   Withdraw functions\n   ***/\n\n   function withdraw(uint amount) nonReentrant public{\n       // Cannot withdraw if some tokens have been minted\n       require(minted[msg.sender]==0);\n       msg.sender.call{value: amount}(\"\");\n       balances[msg.sender] -= amount;\n   }\n\n   function withdrawAll() nonReentrant public{\n       // Cannot withdraw if some tokens have been minted\n       require(minted[msg.sender]==0);\n       balances[msg.sender] = 0;\n       msg.sender.call{value: balances[msg.sender]}(\"\");\n   }\n\n   /***\n   Mint/burn functions\n   ***/\n\n   // Mint tokens\n   // The user must have locked enough ether in the contract\n   // This function only mint whole number and not fraction.\n   // As a result, amount is expressed without the decimals.\n   // To mint 10 tokens, call mint(10);\n   // @param amount The number of tokens to be minted. amount is the whole number.\n   function mint(uint amount) nonReentrant public{\n       // Cannot mint if some tokens have already been minted\n       require(minted[msg.sender]==0);\n\n       _has_enough_balance(amount, balances[msg.sender]);\n       minted[msg.sender] = amount * decimals_factor;\n       // [Secureum] Assume token.mint has no bug and no callback\n       token.mint(amount * decimals_factor, msg.sender);\n   }\n\n   /// @notice burn the token and unlock the account.\n   function burn() nonReentrant public{\n       // This will revert if the user does not have minted[msg.sender] tokens in its balance\n       require(token.balanceOf(msg.sender) == minted[msg.sender]);\n       // [Secureum] Assume token.burn has no bug and no callback\n       token.burn(minted[msg.sender], msg.sender);\n       minted[msg.sender] = 0;\n   }\n\n   /// @notice Ensure that enough ethers are locked. 1 ether allows to mint 10 tokens\n   /// @param desired_tokens The number of tokens to buy\n   /// @param balance The ether balance available\n   function _has_enough_balance(uint256 desired_tokens, uint256 balance) internal view {\n       uint256 required_balance = (desired_tokens / 10) * decimals_factor;\n       require(balance >= required_balance);\n   }\n\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "No overflow can ever occur in a contract compiled with solc version 0.8 \\"
      },
      {
        "choice": "B",
        "answer": "`IERC20.decimals returns(uint256)` is not a correct ERC20 function according to the ERC20 specification \\"
      },
      {
        "choice": "C",
        "answer": "The contract does not follow Natspec for all the documentation \\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C"
    ],
    "race": "RACE-18.md"
  },
  {
    "question": "3] Which of the following is an/are invariant(s) that should hold true? (assuming no bug) \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity ^0.8.0; // using 0.8 to be safe from arithmetic risks\n\ninterface IERC20 {\n   function decimals() external view returns (uint256);\n   function balanceOf(address account) external view returns (uint256);\n   function transfer(address to, uint256 amount) external returns (bool);\n   function allowance(address owner, address spender) external view returns (uint256);\n   function approve(address spender, uint256 amount) external returns (bool);\n   function transferFrom(address from, address to, uint256 amount) external returns (bool);\n   function totalSupply() external view returns (uint256);\n\n   // Mint tokens\n   // The access controls only allows the Bank contract to call this function\n   // mint does not have callback (i.e. it does not allow reentrancies)\n   // [Secureum] Assume no bug\n   function mint(uint amount, address to) external;\n\n   // Burn token\n   // The access controls only allows the Bank contract to call this function\n   // burn does not have callback (i.e. it does not allow reentrancies)\n   // [Secureum] Assume no bug\n   function burn(uint amount, address to) external;\n}\n\n// This contract allows to deposit ether and mint tokens by locking Ether, at a rate of 1 ether = 10 tokens\n// The user needs to burn the token to unlock their balance\n// Once they minted tokens, the user cannot mint more, unless they burned the original amount\n// This contract is safe from reentrancies and front running risks\ncontract Bank{\n\n   mapping(address => uint) balances;\n   mapping(address => uint) minted;\n   uint decimals_factor = 10**18;\n   IERC20 token;\n\n   uint8 isReenter = 1;\n   modifier nonReentrant{\n       require(isReenter>=1);\n       isReenter = 2;\n       _;\n       isReenter = 1;\n   }\n\n   constructor(address token_address){\n       token = IERC20(token_address);\n       // Only accept tokens with 18 decimals to ease the math\n       require(token.decimals() == 18);\n   }\n\n   /***\n   Deposit function\n   ***/\n\n   function deposit(uint amount) internal{\n       balances[msg.sender] += amount;\n   }\n\n   function deposit() payable nonReentrant public{\n       deposit(msg.value);\n   }\n\n   function depositTo(address to) payable nonReentrant public{\n       balances[to] = msg.value;\n   }\n\n   /***\n   Getter\n   ***/\n\n   // Return the balance of the user\n   function getBalances(address user) public nonReentrant returns(uint balance){\n       uint balance = balances[user];\n   }\n\n   /***\n   Withdraw functions\n   ***/\n\n   function withdraw(uint amount) nonReentrant public{\n       // Cannot withdraw if some tokens have been minted\n       require(minted[msg.sender]==0);\n       msg.sender.call{value: amount}(\"\");\n       balances[msg.sender] -= amount;\n   }\n\n   function withdrawAll() nonReentrant public{\n       // Cannot withdraw if some tokens have been minted\n       require(minted[msg.sender]==0);\n       balances[msg.sender] = 0;\n       msg.sender.call{value: balances[msg.sender]}(\"\");\n   }\n\n   /***\n   Mint/burn functions\n   ***/\n\n   // Mint tokens\n   // The user must have locked enough ether in the contract\n   // This function only mint whole number and not fraction.\n   // As a result, amount is expressed without the decimals.\n   // To mint 10 tokens, call mint(10);\n   // @param amount The number of tokens to be minted. amount is the whole number.\n   function mint(uint amount) nonReentrant public{\n       // Cannot mint if some tokens have already been minted\n       require(minted[msg.sender]==0);\n\n       _has_enough_balance(amount, balances[msg.sender]);\n       minted[msg.sender] = amount * decimals_factor;\n       // [Secureum] Assume token.mint has no bug and no callback\n       token.mint(amount * decimals_factor, msg.sender);\n   }\n\n   /// @notice burn the token and unlock the account.\n   function burn() nonReentrant public{\n       // This will revert if the user does not have minted[msg.sender] tokens in its balance\n       require(token.balanceOf(msg.sender) == minted[msg.sender]);\n       // [Secureum] Assume token.burn has no bug and no callback\n       token.burn(minted[msg.sender], msg.sender);\n       minted[msg.sender] = 0;\n   }\n\n   /// @notice Ensure that enough ethers are locked. 1 ether allows to mint 10 tokens\n   /// @param desired_tokens The number of tokens to buy\n   /// @param balance The ether balance available\n   function _has_enough_balance(uint256 desired_tokens, uint256 balance) internal view {\n       uint256 required_balance = (desired_tokens / 10) * decimals_factor;\n       require(balance >= required_balance);\n   }\n\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The contract's ether balance must be strictly equal to the sum of all the balances (in the `balances` mapping) \\"
      },
      {
        "choice": "B",
        "answer": "For any user, `minted[user] <= balances[user] * 10` \\"
      },
      {
        "choice": "C",
        "answer": "For any user, `token.balanceOf(user) == balances[user]` \\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-18.md"
  },
  {
    "question": "4] Which of the following sentence(s) is/are true regarding `getBalances`? \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity ^0.8.0; // using 0.8 to be safe from arithmetic risks\n\ninterface IERC20 {\n   function decimals() external view returns (uint256);\n   function balanceOf(address account) external view returns (uint256);\n   function transfer(address to, uint256 amount) external returns (bool);\n   function allowance(address owner, address spender) external view returns (uint256);\n   function approve(address spender, uint256 amount) external returns (bool);\n   function transferFrom(address from, address to, uint256 amount) external returns (bool);\n   function totalSupply() external view returns (uint256);\n\n   // Mint tokens\n   // The access controls only allows the Bank contract to call this function\n   // mint does not have callback (i.e. it does not allow reentrancies)\n   // [Secureum] Assume no bug\n   function mint(uint amount, address to) external;\n\n   // Burn token\n   // The access controls only allows the Bank contract to call this function\n   // burn does not have callback (i.e. it does not allow reentrancies)\n   // [Secureum] Assume no bug\n   function burn(uint amount, address to) external;\n}\n\n// This contract allows to deposit ether and mint tokens by locking Ether, at a rate of 1 ether = 10 tokens\n// The user needs to burn the token to unlock their balance\n// Once they minted tokens, the user cannot mint more, unless they burned the original amount\n// This contract is safe from reentrancies and front running risks\ncontract Bank{\n\n   mapping(address => uint) balances;\n   mapping(address => uint) minted;\n   uint decimals_factor = 10**18;\n   IERC20 token;\n\n   uint8 isReenter = 1;\n   modifier nonReentrant{\n       require(isReenter>=1);\n       isReenter = 2;\n       _;\n       isReenter = 1;\n   }\n\n   constructor(address token_address){\n       token = IERC20(token_address);\n       // Only accept tokens with 18 decimals to ease the math\n       require(token.decimals() == 18);\n   }\n\n   /***\n   Deposit function\n   ***/\n\n   function deposit(uint amount) internal{\n       balances[msg.sender] += amount;\n   }\n\n   function deposit() payable nonReentrant public{\n       deposit(msg.value);\n   }\n\n   function depositTo(address to) payable nonReentrant public{\n       balances[to] = msg.value;\n   }\n\n   /***\n   Getter\n   ***/\n\n   // Return the balance of the user\n   function getBalances(address user) public nonReentrant returns(uint balance){\n       uint balance = balances[user];\n   }\n\n   /***\n   Withdraw functions\n   ***/\n\n   function withdraw(uint amount) nonReentrant public{\n       // Cannot withdraw if some tokens have been minted\n       require(minted[msg.sender]==0);\n       msg.sender.call{value: amount}(\"\");\n       balances[msg.sender] -= amount;\n   }\n\n   function withdrawAll() nonReentrant public{\n       // Cannot withdraw if some tokens have been minted\n       require(minted[msg.sender]==0);\n       balances[msg.sender] = 0;\n       msg.sender.call{value: balances[msg.sender]}(\"\");\n   }\n\n   /***\n   Mint/burn functions\n   ***/\n\n   // Mint tokens\n   // The user must have locked enough ether in the contract\n   // This function only mint whole number and not fraction.\n   // As a result, amount is expressed without the decimals.\n   // To mint 10 tokens, call mint(10);\n   // @param amount The number of tokens to be minted. amount is the whole number.\n   function mint(uint amount) nonReentrant public{\n       // Cannot mint if some tokens have already been minted\n       require(minted[msg.sender]==0);\n\n       _has_enough_balance(amount, balances[msg.sender]);\n       minted[msg.sender] = amount * decimals_factor;\n       // [Secureum] Assume token.mint has no bug and no callback\n       token.mint(amount * decimals_factor, msg.sender);\n   }\n\n   /// @notice burn the token and unlock the account.\n   function burn() nonReentrant public{\n       // This will revert if the user does not have minted[msg.sender] tokens in its balance\n       require(token.balanceOf(msg.sender) == minted[msg.sender]);\n       // [Secureum] Assume token.burn has no bug and no callback\n       token.burn(minted[msg.sender], msg.sender);\n       minted[msg.sender] = 0;\n   }\n\n   /// @notice Ensure that enough ethers are locked. 1 ether allows to mint 10 tokens\n   /// @param desired_tokens The number of tokens to buy\n   /// @param balance The ether balance available\n   function _has_enough_balance(uint256 desired_tokens, uint256 balance) internal view {\n       uint256 required_balance = (desired_tokens / 10) * decimals_factor;\n       require(balance >= required_balance);\n   }\n\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "`getBalances(msg.sender)` returns the sender's balance \\"
      },
      {
        "choice": "B",
        "answer": "`getBalances` reverts if the user's balance is zero \\"
      },
      {
        "choice": "C",
        "answer": "`getBalances` always returns zero \\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-18.md"
  },
  {
    "question": "5] Which of the following sentence(s) is/are true regarding the `balances` mapping? \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity ^0.8.0; // using 0.8 to be safe from arithmetic risks\n\ninterface IERC20 {\n   function decimals() external view returns (uint256);\n   function balanceOf(address account) external view returns (uint256);\n   function transfer(address to, uint256 amount) external returns (bool);\n   function allowance(address owner, address spender) external view returns (uint256);\n   function approve(address spender, uint256 amount) external returns (bool);\n   function transferFrom(address from, address to, uint256 amount) external returns (bool);\n   function totalSupply() external view returns (uint256);\n\n   // Mint tokens\n   // The access controls only allows the Bank contract to call this function\n   // mint does not have callback (i.e. it does not allow reentrancies)\n   // [Secureum] Assume no bug\n   function mint(uint amount, address to) external;\n\n   // Burn token\n   // The access controls only allows the Bank contract to call this function\n   // burn does not have callback (i.e. it does not allow reentrancies)\n   // [Secureum] Assume no bug\n   function burn(uint amount, address to) external;\n}\n\n// This contract allows to deposit ether and mint tokens by locking Ether, at a rate of 1 ether = 10 tokens\n// The user needs to burn the token to unlock their balance\n// Once they minted tokens, the user cannot mint more, unless they burned the original amount\n// This contract is safe from reentrancies and front running risks\ncontract Bank{\n\n   mapping(address => uint) balances;\n   mapping(address => uint) minted;\n   uint decimals_factor = 10**18;\n   IERC20 token;\n\n   uint8 isReenter = 1;\n   modifier nonReentrant{\n       require(isReenter>=1);\n       isReenter = 2;\n       _;\n       isReenter = 1;\n   }\n\n   constructor(address token_address){\n       token = IERC20(token_address);\n       // Only accept tokens with 18 decimals to ease the math\n       require(token.decimals() == 18);\n   }\n\n   /***\n   Deposit function\n   ***/\n\n   function deposit(uint amount) internal{\n       balances[msg.sender] += amount;\n   }\n\n   function deposit() payable nonReentrant public{\n       deposit(msg.value);\n   }\n\n   function depositTo(address to) payable nonReentrant public{\n       balances[to] = msg.value;\n   }\n\n   /***\n   Getter\n   ***/\n\n   // Return the balance of the user\n   function getBalances(address user) public nonReentrant returns(uint balance){\n       uint balance = balances[user];\n   }\n\n   /***\n   Withdraw functions\n   ***/\n\n   function withdraw(uint amount) nonReentrant public{\n       // Cannot withdraw if some tokens have been minted\n       require(minted[msg.sender]==0);\n       msg.sender.call{value: amount}(\"\");\n       balances[msg.sender] -= amount;\n   }\n\n   function withdrawAll() nonReentrant public{\n       // Cannot withdraw if some tokens have been minted\n       require(minted[msg.sender]==0);\n       balances[msg.sender] = 0;\n       msg.sender.call{value: balances[msg.sender]}(\"\");\n   }\n\n   /***\n   Mint/burn functions\n   ***/\n\n   // Mint tokens\n   // The user must have locked enough ether in the contract\n   // This function only mint whole number and not fraction.\n   // As a result, amount is expressed without the decimals.\n   // To mint 10 tokens, call mint(10);\n   // @param amount The number of tokens to be minted. amount is the whole number.\n   function mint(uint amount) nonReentrant public{\n       // Cannot mint if some tokens have already been minted\n       require(minted[msg.sender]==0);\n\n       _has_enough_balance(amount, balances[msg.sender]);\n       minted[msg.sender] = amount * decimals_factor;\n       // [Secureum] Assume token.mint has no bug and no callback\n       token.mint(amount * decimals_factor, msg.sender);\n   }\n\n   /// @notice burn the token and unlock the account.\n   function burn() nonReentrant public{\n       // This will revert if the user does not have minted[msg.sender] tokens in its balance\n       require(token.balanceOf(msg.sender) == minted[msg.sender]);\n       // [Secureum] Assume token.burn has no bug and no callback\n       token.burn(minted[msg.sender], msg.sender);\n       minted[msg.sender] = 0;\n   }\n\n   /// @notice Ensure that enough ethers are locked. 1 ether allows to mint 10 tokens\n   /// @param desired_tokens The number of tokens to buy\n   /// @param balance The ether balance available\n   function _has_enough_balance(uint256 desired_tokens, uint256 balance) internal view {\n       uint256 required_balance = (desired_tokens / 10) * decimals_factor;\n       require(balance >= required_balance);\n   }\n\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "An attacker can increase their `balances` (theft) from `balances[victim]` \\"
      },
      {
        "choice": "B",
        "answer": "An attacker can reset `balances[victim]` \\"
      },
      {
        "choice": "C",
        "answer": "An attacker can increase their `balances` to any amount \\"
      },
      {
        "choice": "D",
        "answer": "An attacker cannot compromise the `balances` mapping \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-18.md"
  },
  {
    "question": "6] Which of the following sentence(s) is/are true regarding reentrancies in this contract? \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity ^0.8.0; // using 0.8 to be safe from arithmetic risks\n\ninterface IERC20 {\n   function decimals() external view returns (uint256);\n   function balanceOf(address account) external view returns (uint256);\n   function transfer(address to, uint256 amount) external returns (bool);\n   function allowance(address owner, address spender) external view returns (uint256);\n   function approve(address spender, uint256 amount) external returns (bool);\n   function transferFrom(address from, address to, uint256 amount) external returns (bool);\n   function totalSupply() external view returns (uint256);\n\n   // Mint tokens\n   // The access controls only allows the Bank contract to call this function\n   // mint does not have callback (i.e. it does not allow reentrancies)\n   // [Secureum] Assume no bug\n   function mint(uint amount, address to) external;\n\n   // Burn token\n   // The access controls only allows the Bank contract to call this function\n   // burn does not have callback (i.e. it does not allow reentrancies)\n   // [Secureum] Assume no bug\n   function burn(uint amount, address to) external;\n}\n\n// This contract allows to deposit ether and mint tokens by locking Ether, at a rate of 1 ether = 10 tokens\n// The user needs to burn the token to unlock their balance\n// Once they minted tokens, the user cannot mint more, unless they burned the original amount\n// This contract is safe from reentrancies and front running risks\ncontract Bank{\n\n   mapping(address => uint) balances;\n   mapping(address => uint) minted;\n   uint decimals_factor = 10**18;\n   IERC20 token;\n\n   uint8 isReenter = 1;\n   modifier nonReentrant{\n       require(isReenter>=1);\n       isReenter = 2;\n       _;\n       isReenter = 1;\n   }\n\n   constructor(address token_address){\n       token = IERC20(token_address);\n       // Only accept tokens with 18 decimals to ease the math\n       require(token.decimals() == 18);\n   }\n\n   /***\n   Deposit function\n   ***/\n\n   function deposit(uint amount) internal{\n       balances[msg.sender] += amount;\n   }\n\n   function deposit() payable nonReentrant public{\n       deposit(msg.value);\n   }\n\n   function depositTo(address to) payable nonReentrant public{\n       balances[to] = msg.value;\n   }\n\n   /***\n   Getter\n   ***/\n\n   // Return the balance of the user\n   function getBalances(address user) public nonReentrant returns(uint balance){\n       uint balance = balances[user];\n   }\n\n   /***\n   Withdraw functions\n   ***/\n\n   function withdraw(uint amount) nonReentrant public{\n       // Cannot withdraw if some tokens have been minted\n       require(minted[msg.sender]==0);\n       msg.sender.call{value: amount}(\"\");\n       balances[msg.sender] -= amount;\n   }\n\n   function withdrawAll() nonReentrant public{\n       // Cannot withdraw if some tokens have been minted\n       require(minted[msg.sender]==0);\n       balances[msg.sender] = 0;\n       msg.sender.call{value: balances[msg.sender]}(\"\");\n   }\n\n   /***\n   Mint/burn functions\n   ***/\n\n   // Mint tokens\n   // The user must have locked enough ether in the contract\n   // This function only mint whole number and not fraction.\n   // As a result, amount is expressed without the decimals.\n   // To mint 10 tokens, call mint(10);\n   // @param amount The number of tokens to be minted. amount is the whole number.\n   function mint(uint amount) nonReentrant public{\n       // Cannot mint if some tokens have already been minted\n       require(minted[msg.sender]==0);\n\n       _has_enough_balance(amount, balances[msg.sender]);\n       minted[msg.sender] = amount * decimals_factor;\n       // [Secureum] Assume token.mint has no bug and no callback\n       token.mint(amount * decimals_factor, msg.sender);\n   }\n\n   /// @notice burn the token and unlock the account.\n   function burn() nonReentrant public{\n       // This will revert if the user does not have minted[msg.sender] tokens in its balance\n       require(token.balanceOf(msg.sender) == minted[msg.sender]);\n       // [Secureum] Assume token.burn has no bug and no callback\n       token.burn(minted[msg.sender], msg.sender);\n       minted[msg.sender] = 0;\n   }\n\n   /// @notice Ensure that enough ethers are locked. 1 ether allows to mint 10 tokens\n   /// @param desired_tokens The number of tokens to buy\n   /// @param balance The ether balance available\n   function _has_enough_balance(uint256 desired_tokens, uint256 balance) internal view {\n       uint256 required_balance = (desired_tokens / 10) * decimals_factor;\n       require(balance >= required_balance);\n   }\n\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "`nonReentrant` protects the contract from reentrancies \\"
      },
      {
        "choice": "B",
        "answer": "A correct reentrancy protection modifier is not needed if `withdraw` is refactored to follow the CEI pattern \\"
      },
      {
        "choice": "C",
        "answer": "There are no reentrancy risks \\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-18.md"
  },
  {
    "question": "7] The `mint` function has the following risks (assuming there are no bugs in the other functions): \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity ^0.8.0; // using 0.8 to be safe from arithmetic risks\n\ninterface IERC20 {\n   function decimals() external view returns (uint256);\n   function balanceOf(address account) external view returns (uint256);\n   function transfer(address to, uint256 amount) external returns (bool);\n   function allowance(address owner, address spender) external view returns (uint256);\n   function approve(address spender, uint256 amount) external returns (bool);\n   function transferFrom(address from, address to, uint256 amount) external returns (bool);\n   function totalSupply() external view returns (uint256);\n\n   // Mint tokens\n   // The access controls only allows the Bank contract to call this function\n   // mint does not have callback (i.e. it does not allow reentrancies)\n   // [Secureum] Assume no bug\n   function mint(uint amount, address to) external;\n\n   // Burn token\n   // The access controls only allows the Bank contract to call this function\n   // burn does not have callback (i.e. it does not allow reentrancies)\n   // [Secureum] Assume no bug\n   function burn(uint amount, address to) external;\n}\n\n// This contract allows to deposit ether and mint tokens by locking Ether, at a rate of 1 ether = 10 tokens\n// The user needs to burn the token to unlock their balance\n// Once they minted tokens, the user cannot mint more, unless they burned the original amount\n// This contract is safe from reentrancies and front running risks\ncontract Bank{\n\n   mapping(address => uint) balances;\n   mapping(address => uint) minted;\n   uint decimals_factor = 10**18;\n   IERC20 token;\n\n   uint8 isReenter = 1;\n   modifier nonReentrant{\n       require(isReenter>=1);\n       isReenter = 2;\n       _;\n       isReenter = 1;\n   }\n\n   constructor(address token_address){\n       token = IERC20(token_address);\n       // Only accept tokens with 18 decimals to ease the math\n       require(token.decimals() == 18);\n   }\n\n   /***\n   Deposit function\n   ***/\n\n   function deposit(uint amount) internal{\n       balances[msg.sender] += amount;\n   }\n\n   function deposit() payable nonReentrant public{\n       deposit(msg.value);\n   }\n\n   function depositTo(address to) payable nonReentrant public{\n       balances[to] = msg.value;\n   }\n\n   /***\n   Getter\n   ***/\n\n   // Return the balance of the user\n   function getBalances(address user) public nonReentrant returns(uint balance){\n       uint balance = balances[user];\n   }\n\n   /***\n   Withdraw functions\n   ***/\n\n   function withdraw(uint amount) nonReentrant public{\n       // Cannot withdraw if some tokens have been minted\n       require(minted[msg.sender]==0);\n       msg.sender.call{value: amount}(\"\");\n       balances[msg.sender] -= amount;\n   }\n\n   function withdrawAll() nonReentrant public{\n       // Cannot withdraw if some tokens have been minted\n       require(minted[msg.sender]==0);\n       balances[msg.sender] = 0;\n       msg.sender.call{value: balances[msg.sender]}(\"\");\n   }\n\n   /***\n   Mint/burn functions\n   ***/\n\n   // Mint tokens\n   // The user must have locked enough ether in the contract\n   // This function only mint whole number and not fraction.\n   // As a result, amount is expressed without the decimals.\n   // To mint 10 tokens, call mint(10);\n   // @param amount The number of tokens to be minted. amount is the whole number.\n   function mint(uint amount) nonReentrant public{\n       // Cannot mint if some tokens have already been minted\n       require(minted[msg.sender]==0);\n\n       _has_enough_balance(amount, balances[msg.sender]);\n       minted[msg.sender] = amount * decimals_factor;\n       // [Secureum] Assume token.mint has no bug and no callback\n       token.mint(amount * decimals_factor, msg.sender);\n   }\n\n   /// @notice burn the token and unlock the account.\n   function burn() nonReentrant public{\n       // This will revert if the user does not have minted[msg.sender] tokens in its balance\n       require(token.balanceOf(msg.sender) == minted[msg.sender]);\n       // [Secureum] Assume token.burn has no bug and no callback\n       token.burn(minted[msg.sender], msg.sender);\n       minted[msg.sender] = 0;\n   }\n\n   /// @notice Ensure that enough ethers are locked. 1 ether allows to mint 10 tokens\n   /// @param desired_tokens The number of tokens to buy\n   /// @param balance The ether balance available\n   function _has_enough_balance(uint256 desired_tokens, uint256 balance) internal view {\n       uint256 required_balance = (desired_tokens / 10) * decimals_factor;\n       require(balance >= required_balance);\n   }\n\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The user can generate tokens without having locked ether \\"
      },
      {
        "choice": "B",
        "answer": "An attacker can front-run a call to `mint` and make it revert \\"
      },
      {
        "choice": "C",
        "answer": "`minted[msg.sender] = amount * decimals_factor;` should be replaced by `minted[msg.sender] = amount / decimals_factor;` \\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "race": "RACE-18.md"
  },
  {
    "question": "8] The `burn` and `_has_enough_balance` functions have the following risks (assuming there are no bugs in the other functions): \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity ^0.8.0; // using 0.8 to be safe from arithmetic risks\n\ninterface IERC20 {\n   function decimals() external view returns (uint256);\n   function balanceOf(address account) external view returns (uint256);\n   function transfer(address to, uint256 amount) external returns (bool);\n   function allowance(address owner, address spender) external view returns (uint256);\n   function approve(address spender, uint256 amount) external returns (bool);\n   function transferFrom(address from, address to, uint256 amount) external returns (bool);\n   function totalSupply() external view returns (uint256);\n\n   // Mint tokens\n   // The access controls only allows the Bank contract to call this function\n   // mint does not have callback (i.e. it does not allow reentrancies)\n   // [Secureum] Assume no bug\n   function mint(uint amount, address to) external;\n\n   // Burn token\n   // The access controls only allows the Bank contract to call this function\n   // burn does not have callback (i.e. it does not allow reentrancies)\n   // [Secureum] Assume no bug\n   function burn(uint amount, address to) external;\n}\n\n// This contract allows to deposit ether and mint tokens by locking Ether, at a rate of 1 ether = 10 tokens\n// The user needs to burn the token to unlock their balance\n// Once they minted tokens, the user cannot mint more, unless they burned the original amount\n// This contract is safe from reentrancies and front running risks\ncontract Bank{\n\n   mapping(address => uint) balances;\n   mapping(address => uint) minted;\n   uint decimals_factor = 10**18;\n   IERC20 token;\n\n   uint8 isReenter = 1;\n   modifier nonReentrant{\n       require(isReenter>=1);\n       isReenter = 2;\n       _;\n       isReenter = 1;\n   }\n\n   constructor(address token_address){\n       token = IERC20(token_address);\n       // Only accept tokens with 18 decimals to ease the math\n       require(token.decimals() == 18);\n   }\n\n   /***\n   Deposit function\n   ***/\n\n   function deposit(uint amount) internal{\n       balances[msg.sender] += amount;\n   }\n\n   function deposit() payable nonReentrant public{\n       deposit(msg.value);\n   }\n\n   function depositTo(address to) payable nonReentrant public{\n       balances[to] = msg.value;\n   }\n\n   /***\n   Getter\n   ***/\n\n   // Return the balance of the user\n   function getBalances(address user) public nonReentrant returns(uint balance){\n       uint balance = balances[user];\n   }\n\n   /***\n   Withdraw functions\n   ***/\n\n   function withdraw(uint amount) nonReentrant public{\n       // Cannot withdraw if some tokens have been minted\n       require(minted[msg.sender]==0);\n       msg.sender.call{value: amount}(\"\");\n       balances[msg.sender] -= amount;\n   }\n\n   function withdrawAll() nonReentrant public{\n       // Cannot withdraw if some tokens have been minted\n       require(minted[msg.sender]==0);\n       balances[msg.sender] = 0;\n       msg.sender.call{value: balances[msg.sender]}(\"\");\n   }\n\n   /***\n   Mint/burn functions\n   ***/\n\n   // Mint tokens\n   // The user must have locked enough ether in the contract\n   // This function only mint whole number and not fraction.\n   // As a result, amount is expressed without the decimals.\n   // To mint 10 tokens, call mint(10);\n   // @param amount The number of tokens to be minted. amount is the whole number.\n   function mint(uint amount) nonReentrant public{\n       // Cannot mint if some tokens have already been minted\n       require(minted[msg.sender]==0);\n\n       _has_enough_balance(amount, balances[msg.sender]);\n       minted[msg.sender] = amount * decimals_factor;\n       // [Secureum] Assume token.mint has no bug and no callback\n       token.mint(amount * decimals_factor, msg.sender);\n   }\n\n   /// @notice burn the token and unlock the account.\n   function burn() nonReentrant public{\n       // This will revert if the user does not have minted[msg.sender] tokens in its balance\n       require(token.balanceOf(msg.sender) == minted[msg.sender]);\n       // [Secureum] Assume token.burn has no bug and no callback\n       token.burn(minted[msg.sender], msg.sender);\n       minted[msg.sender] = 0;\n   }\n\n   /// @notice Ensure that enough ethers are locked. 1 ether allows to mint 10 tokens\n   /// @param desired_tokens The number of tokens to buy\n   /// @param balance The ether balance available\n   function _has_enough_balance(uint256 desired_tokens, uint256 balance) internal view {\n       uint256 required_balance = (desired_tokens / 10) * decimals_factor;\n       require(balance >= required_balance);\n   }\n\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The user can unlock their balance without burning the underlying tokens \\"
      },
      {
        "choice": "B",
        "answer": "An attacker can front-run a call to `burn` and make it revert \\"
      },
      {
        "choice": "C",
        "answer": "`burn` should use `tx.origin` instead of `msg.sender` to prevent access control issues \\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-18.md"
  },
  {
    "question": "1] The deployment concern(s) here for different EVM-compatible chains is/are: \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity 0.8.20;\n\nimport {ERC721Burnable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport {ERC1155Burnable} from \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n\ncontract WalletFactory {\n   using Address for address;\n   address immutable implementation;\n\n   constructor(address _implementation) {\n       implementation = _implementation;\n   }\n\n   function deployAndLoad(uint256 salt) external payable returns (address addr) {\n       addr = deploy(salt);\n       payable(addr).send(msg.value);\n   }\n\n   function deploy(uint256 salt) public returns (address addr) {\n       bytes memory code = implementation.code;\n       assembly {\n           addr := create2(0, add(code, 0x20), mload(code), salt)\n       }\n    }\n}  \n\n\ncontract Wallet {\n\n   struct Transaction {\n       address from;\n       address to;\n       uint256 value;\n       bytes data;\n   }\n\n   uint256 nonce;\n\n   receive() external payable {}\n   fallback() external payable {}\n\n   function execute(Transaction calldata transaction, bytes calldata signature) public payable {\n       bytes32 hash = keccak256(abi.encode(address(this), nonce, transaction));\n       bytes32 r = readBytes32(signature, 0);\n       bytes32 s = readBytes32(signature, 32);\n       uint8 v = uint8(signature[64]);\n       address signer = ecrecover(hash, v, r, s);\n\n       if (signer == msg.sender || signer == transaction.from) {\n           address to = transaction.to;\n           uint256 value = transaction.value;\n           bytes memory data = transaction.data;\n\n           assembly {\n               let res := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\n           }\n           return;\n       }\n\n       nonce++;\n   }\n\n   function executeMultiple(Transaction[] calldata transactions, bytes[] calldata signatures) external payable {\n       for(uint256 i = 0; i < transactions.length; ++i) execute(transactions[i], signatures[i]);\n   }\n\n   function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n       index += 32;\n       require(b.length >= index);\n\n       assembly {\n           result := mload(add(b, index))\n       }\n   }\n\n   function burnNFT(address owner, ERC721Burnable nftContract, uint256 id) external {\n       require(msg.sender == owner, \"Unauthorized\");\n       nftContract.burn(id);\n   }\n\n   function burnERC1155(ERC1155Burnable semiFungibleToken, uint256 id, uint256 amount) external {\n       semiFungibleToken.burn(msg.sender, id, amount);\n   }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "`receive` method behavior might be undefined \\"
      },
      {
        "choice": "B",
        "answer": "The presence of `ecrecover` precompile is potentially dangerous \\"
      },
      {
        "choice": "C",
        "answer": "Not all opcodes in the bytecode are guaranteed to be supported \\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-19.md"
  },
  {
    "question": "2] The security concern(s) in `WalletFactory` is/are: \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity 0.8.20;\n\nimport {ERC721Burnable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport {ERC1155Burnable} from \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n\ncontract WalletFactory {\n   using Address for address;\n   address immutable implementation;\n\n   constructor(address _implementation) {\n       implementation = _implementation;\n   }\n\n   function deployAndLoad(uint256 salt) external payable returns (address addr) {\n       addr = deploy(salt);\n       payable(addr).send(msg.value);\n   }\n\n   function deploy(uint256 salt) public returns (address addr) {\n       bytes memory code = implementation.code;\n       assembly {\n           addr := create2(0, add(code, 0x20), mload(code), salt)\n       }\n    }\n}  \n\n\ncontract Wallet {\n\n   struct Transaction {\n       address from;\n       address to;\n       uint256 value;\n       bytes data;\n   }\n\n   uint256 nonce;\n\n   receive() external payable {}\n   fallback() external payable {}\n\n   function execute(Transaction calldata transaction, bytes calldata signature) public payable {\n       bytes32 hash = keccak256(abi.encode(address(this), nonce, transaction));\n       bytes32 r = readBytes32(signature, 0);\n       bytes32 s = readBytes32(signature, 32);\n       uint8 v = uint8(signature[64]);\n       address signer = ecrecover(hash, v, r, s);\n\n       if (signer == msg.sender || signer == transaction.from) {\n           address to = transaction.to;\n           uint256 value = transaction.value;\n           bytes memory data = transaction.data;\n\n           assembly {\n               let res := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\n           }\n           return;\n       }\n\n       nonce++;\n   }\n\n   function executeMultiple(Transaction[] calldata transactions, bytes[] calldata signatures) external payable {\n       for(uint256 i = 0; i < transactions.length; ++i) execute(transactions[i], signatures[i]);\n   }\n\n   function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n       index += 32;\n       require(b.length >= index);\n\n       assembly {\n           result := mload(add(b, index))\n       }\n   }\n\n   function burnNFT(address owner, ERC721Burnable nftContract, uint256 id) external {\n       require(msg.sender == owner, \"Unauthorized\");\n       nftContract.burn(id);\n   }\n\n   function burnERC1155(ERC1155Burnable semiFungibleToken, uint256 id, uint256 amount) external {\n       semiFungibleToken.burn(msg.sender, id, amount);\n   }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "ETH funds may get stuck in it forever \\"
      },
      {
        "choice": "B",
        "answer": "The `deploy` method is not marked as `payable` \\"
      },
      {
        "choice": "C",
        "answer": "No access control on wallet deployment \\"
      },
      {
        "choice": "D",
        "answer": "Deployment may silently fail \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "D"
    ],
    "race": "RACE-19.md"
  },
  {
    "question": "3] Design flaw(s) of `Wallet` is/are: \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity 0.8.20;\n\nimport {ERC721Burnable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport {ERC1155Burnable} from \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n\ncontract WalletFactory {\n   using Address for address;\n   address immutable implementation;\n\n   constructor(address _implementation) {\n       implementation = _implementation;\n   }\n\n   function deployAndLoad(uint256 salt) external payable returns (address addr) {\n       addr = deploy(salt);\n       payable(addr).send(msg.value);\n   }\n\n   function deploy(uint256 salt) public returns (address addr) {\n       bytes memory code = implementation.code;\n       assembly {\n           addr := create2(0, add(code, 0x20), mload(code), salt)\n       }\n    }\n}  \n\n\ncontract Wallet {\n\n   struct Transaction {\n       address from;\n       address to;\n       uint256 value;\n       bytes data;\n   }\n\n   uint256 nonce;\n\n   receive() external payable {}\n   fallback() external payable {}\n\n   function execute(Transaction calldata transaction, bytes calldata signature) public payable {\n       bytes32 hash = keccak256(abi.encode(address(this), nonce, transaction));\n       bytes32 r = readBytes32(signature, 0);\n       bytes32 s = readBytes32(signature, 32);\n       uint8 v = uint8(signature[64]);\n       address signer = ecrecover(hash, v, r, s);\n\n       if (signer == msg.sender || signer == transaction.from) {\n           address to = transaction.to;\n           uint256 value = transaction.value;\n           bytes memory data = transaction.data;\n\n           assembly {\n               let res := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\n           }\n           return;\n       }\n\n       nonce++;\n   }\n\n   function executeMultiple(Transaction[] calldata transactions, bytes[] calldata signatures) external payable {\n       for(uint256 i = 0; i < transactions.length; ++i) execute(transactions[i], signatures[i]);\n   }\n\n   function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n       index += 32;\n       require(b.length >= index);\n\n       assembly {\n           result := mload(add(b, index))\n       }\n   }\n\n   function burnNFT(address owner, ERC721Burnable nftContract, uint256 id) external {\n       require(msg.sender == owner, \"Unauthorized\");\n       nftContract.burn(id);\n   }\n\n   function burnERC1155(ERC1155Burnable semiFungibleToken, uint256 id, uint256 amount) external {\n       semiFungibleToken.burn(msg.sender, id, amount);\n   }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Missing wallet owner role and appropriate access control \\"
      },
      {
        "choice": "B",
        "answer": "Inability to rescue stuck tokens \\"
      },
      {
        "choice": "C",
        "answer": "Assembly usage is unsafe for the Yul IR pipeline \\"
      },
      {
        "choice": "D",
        "answer": "Calling a `payable` method in a for-loop \n \n \n"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "race": "RACE-19.md"
  },
  {
    "question": "4] The security concern(s) with hashing of `transaction` parameter in `execute` is/are: \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity 0.8.20;\n\nimport {ERC721Burnable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport {ERC1155Burnable} from \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n\ncontract WalletFactory {\n   using Address for address;\n   address immutable implementation;\n\n   constructor(address _implementation) {\n       implementation = _implementation;\n   }\n\n   function deployAndLoad(uint256 salt) external payable returns (address addr) {\n       addr = deploy(salt);\n       payable(addr).send(msg.value);\n   }\n\n   function deploy(uint256 salt) public returns (address addr) {\n       bytes memory code = implementation.code;\n       assembly {\n           addr := create2(0, add(code, 0x20), mload(code), salt)\n       }\n    }\n}  \n\n\ncontract Wallet {\n\n   struct Transaction {\n       address from;\n       address to;\n       uint256 value;\n       bytes data;\n   }\n\n   uint256 nonce;\n\n   receive() external payable {}\n   fallback() external payable {}\n\n   function execute(Transaction calldata transaction, bytes calldata signature) public payable {\n       bytes32 hash = keccak256(abi.encode(address(this), nonce, transaction));\n       bytes32 r = readBytes32(signature, 0);\n       bytes32 s = readBytes32(signature, 32);\n       uint8 v = uint8(signature[64]);\n       address signer = ecrecover(hash, v, r, s);\n\n       if (signer == msg.sender || signer == transaction.from) {\n           address to = transaction.to;\n           uint256 value = transaction.value;\n           bytes memory data = transaction.data;\n\n           assembly {\n               let res := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\n           }\n           return;\n       }\n\n       nonce++;\n   }\n\n   function executeMultiple(Transaction[] calldata transactions, bytes[] calldata signatures) external payable {\n       for(uint256 i = 0; i < transactions.length; ++i) execute(transactions[i], signatures[i]);\n   }\n\n   function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n       index += 32;\n       require(b.length >= index);\n\n       assembly {\n           result := mload(add(b, index))\n       }\n   }\n\n   function burnNFT(address owner, ERC721Burnable nftContract, uint256 id) external {\n       require(msg.sender == owner, \"Unauthorized\");\n       nftContract.burn(id);\n   }\n\n   function burnERC1155(ERC1155Burnable semiFungibleToken, uint256 id, uint256 amount) external {\n       semiFungibleToken.burn(msg.sender, id, amount);\n   }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Cross-contract replay attacks \\"
      },
      {
        "choice": "B",
        "answer": "Cross-chain replay attacks \\"
      },
      {
        "choice": "C",
        "answer": "`keccak256` hash collision attacks \\"
      },
      {
        "choice": "D",
        "answer": "Reentrancy attacks \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-19.md"
  },
  {
    "question": "5] If the hashed payload in `execute` were to exclude a nonce, the security concern(s) with `ecrecover` would be: \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity 0.8.20;\n\nimport {ERC721Burnable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport {ERC1155Burnable} from \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n\ncontract WalletFactory {\n   using Address for address;\n   address immutable implementation;\n\n   constructor(address _implementation) {\n       implementation = _implementation;\n   }\n\n   function deployAndLoad(uint256 salt) external payable returns (address addr) {\n       addr = deploy(salt);\n       payable(addr).send(msg.value);\n   }\n\n   function deploy(uint256 salt) public returns (address addr) {\n       bytes memory code = implementation.code;\n       assembly {\n           addr := create2(0, add(code, 0x20), mload(code), salt)\n       }\n    }\n}  \n\n\ncontract Wallet {\n\n   struct Transaction {\n       address from;\n       address to;\n       uint256 value;\n       bytes data;\n   }\n\n   uint256 nonce;\n\n   receive() external payable {}\n   fallback() external payable {}\n\n   function execute(Transaction calldata transaction, bytes calldata signature) public payable {\n       bytes32 hash = keccak256(abi.encode(address(this), nonce, transaction));\n       bytes32 r = readBytes32(signature, 0);\n       bytes32 s = readBytes32(signature, 32);\n       uint8 v = uint8(signature[64]);\n       address signer = ecrecover(hash, v, r, s);\n\n       if (signer == msg.sender || signer == transaction.from) {\n           address to = transaction.to;\n           uint256 value = transaction.value;\n           bytes memory data = transaction.data;\n\n           assembly {\n               let res := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\n           }\n           return;\n       }\n\n       nonce++;\n   }\n\n   function executeMultiple(Transaction[] calldata transactions, bytes[] calldata signatures) external payable {\n       for(uint256 i = 0; i < transactions.length; ++i) execute(transactions[i], signatures[i]);\n   }\n\n   function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n       index += 32;\n       require(b.length >= index);\n\n       assembly {\n           result := mload(add(b, index))\n       }\n   }\n\n   function burnNFT(address owner, ERC721Burnable nftContract, uint256 id) external {\n       require(msg.sender == owner, \"Unauthorized\");\n       nftContract.burn(id);\n   }\n\n   function burnERC1155(ERC1155Burnable semiFungibleToken, uint256 id, uint256 amount) external {\n       semiFungibleToken.burn(msg.sender, id, amount);\n   }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Signature malleability by flipping the s or v values \\"
      },
      {
        "choice": "B",
        "answer": "Signature malleability by using compact signatures \\"
      },
      {
        "choice": "C",
        "answer": "Signature malleability by hash collisions \\"
      },
      {
        "choice": "D",
        "answer": "Forcefully reverting transactions \n \n \n"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "race": "RACE-19.md"
  },
  {
    "question": "6] The security concern(s) with `Wallet` is/are: \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity 0.8.20;\n\nimport {ERC721Burnable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport {ERC1155Burnable} from \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n\ncontract WalletFactory {\n   using Address for address;\n   address immutable implementation;\n\n   constructor(address _implementation) {\n       implementation = _implementation;\n   }\n\n   function deployAndLoad(uint256 salt) external payable returns (address addr) {\n       addr = deploy(salt);\n       payable(addr).send(msg.value);\n   }\n\n   function deploy(uint256 salt) public returns (address addr) {\n       bytes memory code = implementation.code;\n       assembly {\n           addr := create2(0, add(code, 0x20), mload(code), salt)\n       }\n    }\n}  \n\n\ncontract Wallet {\n\n   struct Transaction {\n       address from;\n       address to;\n       uint256 value;\n       bytes data;\n   }\n\n   uint256 nonce;\n\n   receive() external payable {}\n   fallback() external payable {}\n\n   function execute(Transaction calldata transaction, bytes calldata signature) public payable {\n       bytes32 hash = keccak256(abi.encode(address(this), nonce, transaction));\n       bytes32 r = readBytes32(signature, 0);\n       bytes32 s = readBytes32(signature, 32);\n       uint8 v = uint8(signature[64]);\n       address signer = ecrecover(hash, v, r, s);\n\n       if (signer == msg.sender || signer == transaction.from) {\n           address to = transaction.to;\n           uint256 value = transaction.value;\n           bytes memory data = transaction.data;\n\n           assembly {\n               let res := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\n           }\n           return;\n       }\n\n       nonce++;\n   }\n\n   function executeMultiple(Transaction[] calldata transactions, bytes[] calldata signatures) external payable {\n       for(uint256 i = 0; i < transactions.length; ++i) execute(transactions[i], signatures[i]);\n   }\n\n   function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n       index += 32;\n       require(b.length >= index);\n\n       assembly {\n           result := mload(add(b, index))\n       }\n   }\n\n   function burnNFT(address owner, ERC721Burnable nftContract, uint256 id) external {\n       require(msg.sender == owner, \"Unauthorized\");\n       nftContract.burn(id);\n   }\n\n   function burnERC1155(ERC1155Burnable semiFungibleToken, uint256 id, uint256 amount) external {\n       semiFungibleToken.burn(msg.sender, id, amount);\n   }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Ether sent to the contract will be stuck forever \\"
      },
      {
        "choice": "B",
        "answer": "Anyone can execute arbitrary calls \\"
      },
      {
        "choice": "C",
        "answer": "Anyone can steal the contract ETH balance \\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C"
    ],
    "race": "RACE-19.md"
  },
  {
    "question": "7] The nonce best practice(s) _not_ followed correctly is/are: \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity 0.8.20;\n\nimport {ERC721Burnable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport {ERC1155Burnable} from \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n\ncontract WalletFactory {\n   using Address for address;\n   address immutable implementation;\n\n   constructor(address _implementation) {\n       implementation = _implementation;\n   }\n\n   function deployAndLoad(uint256 salt) external payable returns (address addr) {\n       addr = deploy(salt);\n       payable(addr).send(msg.value);\n   }\n\n   function deploy(uint256 salt) public returns (address addr) {\n       bytes memory code = implementation.code;\n       assembly {\n           addr := create2(0, add(code, 0x20), mload(code), salt)\n       }\n    }\n}  \n\n\ncontract Wallet {\n\n   struct Transaction {\n       address from;\n       address to;\n       uint256 value;\n       bytes data;\n   }\n\n   uint256 nonce;\n\n   receive() external payable {}\n   fallback() external payable {}\n\n   function execute(Transaction calldata transaction, bytes calldata signature) public payable {\n       bytes32 hash = keccak256(abi.encode(address(this), nonce, transaction));\n       bytes32 r = readBytes32(signature, 0);\n       bytes32 s = readBytes32(signature, 32);\n       uint8 v = uint8(signature[64]);\n       address signer = ecrecover(hash, v, r, s);\n\n       if (signer == msg.sender || signer == transaction.from) {\n           address to = transaction.to;\n           uint256 value = transaction.value;\n           bytes memory data = transaction.data;\n\n           assembly {\n               let res := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\n           }\n           return;\n       }\n\n       nonce++;\n   }\n\n   function executeMultiple(Transaction[] calldata transactions, bytes[] calldata signatures) external payable {\n       for(uint256 i = 0; i < transactions.length; ++i) execute(transactions[i], signatures[i]);\n   }\n\n   function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n       index += 32;\n       require(b.length >= index);\n\n       assembly {\n           result := mload(add(b, index))\n       }\n   }\n\n   function burnNFT(address owner, ERC721Burnable nftContract, uint256 id) external {\n       require(msg.sender == owner, \"Unauthorized\");\n       nftContract.burn(id);\n   }\n\n   function burnERC1155(ERC1155Burnable semiFungibleToken, uint256 id, uint256 amount) external {\n       semiFungibleToken.burn(msg.sender, id, amount);\n   }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Nonce is not incremented before the low-level call \\"
      },
      {
        "choice": "B",
        "answer": "Nonce is not guaranteed to be included in the signature \\"
      },
      {
        "choice": "C",
        "answer": "Nonce is not incremented correctly on transaction execution \\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "C"
    ],
    "race": "RACE-19.md"
  },
  {
    "question": "8] The security concern(s) with `Wallet` contract related to ERC721 tokens is/are: \\",
    "context": "**Note**: All 8 questions in this RACE are based on the below contract. This is the same contract you will see for all the 8 questions in this RACE. The question is below the shown contract.\n```\npragma solidity 0.8.20;\n\nimport {ERC721Burnable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport {ERC1155Burnable} from \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n\ncontract WalletFactory {\n   using Address for address;\n   address immutable implementation;\n\n   constructor(address _implementation) {\n       implementation = _implementation;\n   }\n\n   function deployAndLoad(uint256 salt) external payable returns (address addr) {\n       addr = deploy(salt);\n       payable(addr).send(msg.value);\n   }\n\n   function deploy(uint256 salt) public returns (address addr) {\n       bytes memory code = implementation.code;\n       assembly {\n           addr := create2(0, add(code, 0x20), mload(code), salt)\n       }\n    }\n}  \n\n\ncontract Wallet {\n\n   struct Transaction {\n       address from;\n       address to;\n       uint256 value;\n       bytes data;\n   }\n\n   uint256 nonce;\n\n   receive() external payable {}\n   fallback() external payable {}\n\n   function execute(Transaction calldata transaction, bytes calldata signature) public payable {\n       bytes32 hash = keccak256(abi.encode(address(this), nonce, transaction));\n       bytes32 r = readBytes32(signature, 0);\n       bytes32 s = readBytes32(signature, 32);\n       uint8 v = uint8(signature[64]);\n       address signer = ecrecover(hash, v, r, s);\n\n       if (signer == msg.sender || signer == transaction.from) {\n           address to = transaction.to;\n           uint256 value = transaction.value;\n           bytes memory data = transaction.data;\n\n           assembly {\n               let res := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\n           }\n           return;\n       }\n\n       nonce++;\n   }\n\n   function executeMultiple(Transaction[] calldata transactions, bytes[] calldata signatures) external payable {\n       for(uint256 i = 0; i < transactions.length; ++i) execute(transactions[i], signatures[i]);\n   }\n\n   function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n       index += 32;\n       require(b.length >= index);\n\n       assembly {\n           result := mload(add(b, index))\n       }\n   }\n\n   function burnNFT(address owner, ERC721Burnable nftContract, uint256 id) external {\n       require(msg.sender == owner, \"Unauthorized\");\n       nftContract.burn(id);\n   }\n\n   function burnERC1155(ERC1155Burnable semiFungibleToken, uint256 id, uint256 amount) external {\n       semiFungibleToken.burn(msg.sender, id, amount);\n   }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "There is no way to get ERC721 tokens out of the contract \\"
      },
      {
        "choice": "B",
        "answer": "Failure to receive ERC721 tokens depending on the transfer method \\"
      },
      {
        "choice": "C",
        "answer": "Failure to receive any ERC721 tokens \\"
      },
      {
        "choice": "D",
        "answer": "Unauthorized burning of ERC721 tokens \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "D"
    ],
    "race": "RACE-19.md"
  },
  {
    "question": "1] Based on the comments and code shown in the _InSecureumDAO_ snippet",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureumDAO_ contract snippet shown below. This is the same contract snippet you will see for all the 8 questions in this quiz. The _InSecureumDAO_ contract snippet illustrates some basic functionality of a Decentralized Autonomous Organization (DAO) which includes the opening of the DAO for memberships, allowing users to join as members by depositing a membership fee, creating proposals for voting, casting votes, etc. Assume that all other functionality (that is not shown or represented by ...) is implemented correctly.\n```\npragma solidity 0.8.4;\nimport 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol';\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\";\n\ncontract InSecureumDAO is Pausable, ReentrancyGuard {\n\n    // Assume that all functionality represented by ... below is implemented as expected\n\n    address public admin;\n    mapping (address => bool) public members;\n    mapping (uint256 => uint8[]) public votes;\n    mapping (uint256 => uint8) public winningOutcome;\n    uint256 memberCount = 0;\n    uint256 membershipFee = 1000;\n\n    modifier onlyWhenOpen() {\n        require(address(this).balance > 0, 'InSecureumDAO: This DAO is closed');\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    modifier voteExists(uint256 _voteId) {\n       // Assume this correctly checks if _voteId is present in votes\n        ...\n        _;\n    }\n\n    constructor (address _admin) {\n        require(_admin == address(0));\n        admin = _admin;\n    }\n\n    function openDAO() external payable onlyAdmin {\n        // Admin is expected to open DAO by making a notional deposit\n        ...\n    }\n\n    function join() external payable onlyWhenOpen nonReentrant {\n        require(msg.value == membershipFee, 'InSecureumDAO: Incorrect ETH amount');\n        members[msg.sender] = true;\n        ...\n    }\n\n    function createVote(uint256 _voteId, uint8[] memory _possibleOutcomes) external onlyWhenOpen whenNotPaused {\n        votes[_voteId] = _possibleOutcomes;\n        ...\n    }\n\n    function castVote(uint256 _voteId, uint8 _vote) external voteExists(_voteId) onlyWhenOpen whenNotPaused {\n        ...\n    }\n\n    function getWinningOutcome(uint256 _voteId) public view returns (uint8) {\n        // Anyone is allowed to view winning outcome\n        ...\n        return(winningOutcome[_voteId]);\n    }\n\n    function setMembershipFee(uint256 _fee) external onlyAdmin {\n        membershipFee = _fee;\n    }\n\n    function removeAllMembers() external onlyAdmin {\n        delete members[msg.sender];\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "DAO is meant to be opened only by the _admin_ by making an Ether deposit to the contract"
      },
      {
        "choice": "B",
        "answer": "DAO can be opened by anyone by making an Ether deposit to the contract"
      },
      {
        "choice": "C",
        "answer": "DAO requires an exact payment of _membershipFee_ to join the DAO"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C"
    ],
    "race": "RACE-2.md"
  },
  {
    "question": "2] Based on the code shown in the _InSecureumDAO_ snippet",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureumDAO_ contract snippet shown below. This is the same contract snippet you will see for all the 8 questions in this quiz. The _InSecureumDAO_ contract snippet illustrates some basic functionality of a Decentralized Autonomous Organization (DAO) which includes the opening of the DAO for memberships, allowing users to join as members by depositing a membership fee, creating proposals for voting, casting votes, etc. Assume that all other functionality (that is not shown or represented by ...) is implemented correctly.\n```\npragma solidity 0.8.4;\nimport 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol';\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\";\n\ncontract InSecureumDAO is Pausable, ReentrancyGuard {\n\n    // Assume that all functionality represented by ... below is implemented as expected\n\n    address public admin;\n    mapping (address => bool) public members;\n    mapping (uint256 => uint8[]) public votes;\n    mapping (uint256 => uint8) public winningOutcome;\n    uint256 memberCount = 0;\n    uint256 membershipFee = 1000;\n\n    modifier onlyWhenOpen() {\n        require(address(this).balance > 0, 'InSecureumDAO: This DAO is closed');\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    modifier voteExists(uint256 _voteId) {\n       // Assume this correctly checks if _voteId is present in votes\n        ...\n        _;\n    }\n\n    constructor (address _admin) {\n        require(_admin == address(0));\n        admin = _admin;\n    }\n\n    function openDAO() external payable onlyAdmin {\n        // Admin is expected to open DAO by making a notional deposit\n        ...\n    }\n\n    function join() external payable onlyWhenOpen nonReentrant {\n        require(msg.value == membershipFee, 'InSecureumDAO: Incorrect ETH amount');\n        members[msg.sender] = true;\n        ...\n    }\n\n    function createVote(uint256 _voteId, uint8[] memory _possibleOutcomes) external onlyWhenOpen whenNotPaused {\n        votes[_voteId] = _possibleOutcomes;\n        ...\n    }\n\n    function castVote(uint256 _voteId, uint8 _vote) external voteExists(_voteId) onlyWhenOpen whenNotPaused {\n        ...\n    }\n\n    function getWinningOutcome(uint256 _voteId) public view returns (uint8) {\n        // Anyone is allowed to view winning outcome\n        ...\n        return(winningOutcome[_voteId]);\n    }\n\n    function setMembershipFee(uint256 _fee) external onlyAdmin {\n        membershipFee = _fee;\n    }\n\n    function removeAllMembers() external onlyAdmin {\n        delete members[msg.sender];\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Guarded launch via circuit breakers has been implemented correctly for all state modifying functions"
      },
      {
        "choice": "B",
        "answer": "Zero-address check(s) has/have been implemented correctly"
      },
      {
        "choice": "C",
        "answer": "All critical privileged-role functions have events emitted"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-2.md"
  },
  {
    "question": "3] Reentrancy protection only on _join()_ (assume its correctly specified) indicates that",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureumDAO_ contract snippet shown below. This is the same contract snippet you will see for all the 8 questions in this quiz. The _InSecureumDAO_ contract snippet illustrates some basic functionality of a Decentralized Autonomous Organization (DAO) which includes the opening of the DAO for memberships, allowing users to join as members by depositing a membership fee, creating proposals for voting, casting votes, etc. Assume that all other functionality (that is not shown or represented by ...) is implemented correctly.\n```\npragma solidity 0.8.4;\nimport 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol';\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\";\n\ncontract InSecureumDAO is Pausable, ReentrancyGuard {\n\n    // Assume that all functionality represented by ... below is implemented as expected\n\n    address public admin;\n    mapping (address => bool) public members;\n    mapping (uint256 => uint8[]) public votes;\n    mapping (uint256 => uint8) public winningOutcome;\n    uint256 memberCount = 0;\n    uint256 membershipFee = 1000;\n\n    modifier onlyWhenOpen() {\n        require(address(this).balance > 0, 'InSecureumDAO: This DAO is closed');\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    modifier voteExists(uint256 _voteId) {\n       // Assume this correctly checks if _voteId is present in votes\n        ...\n        _;\n    }\n\n    constructor (address _admin) {\n        require(_admin == address(0));\n        admin = _admin;\n    }\n\n    function openDAO() external payable onlyAdmin {\n        // Admin is expected to open DAO by making a notional deposit\n        ...\n    }\n\n    function join() external payable onlyWhenOpen nonReentrant {\n        require(msg.value == membershipFee, 'InSecureumDAO: Incorrect ETH amount');\n        members[msg.sender] = true;\n        ...\n    }\n\n    function createVote(uint256 _voteId, uint8[] memory _possibleOutcomes) external onlyWhenOpen whenNotPaused {\n        votes[_voteId] = _possibleOutcomes;\n        ...\n    }\n\n    function castVote(uint256 _voteId, uint8 _vote) external voteExists(_voteId) onlyWhenOpen whenNotPaused {\n        ...\n    }\n\n    function getWinningOutcome(uint256 _voteId) public view returns (uint8) {\n        // Anyone is allowed to view winning outcome\n        ...\n        return(winningOutcome[_voteId]);\n    }\n\n    function setMembershipFee(uint256 _fee) external onlyAdmin {\n        membershipFee = _fee;\n    }\n\n    function removeAllMembers() external onlyAdmin {\n        delete members[msg.sender];\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Only _payable_ functions require this protection because of handling _msg.value_"
      },
      {
        "choice": "B",
        "answer": "_join()_ likely makes untrusted external call(s) but not the other contract functions"
      },
      {
        "choice": "C",
        "answer": "Both A and B"
      },
      {
        "choice": "D",
        "answer": "Neither A nor B \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-2.md"
  },
  {
    "question": "4] Access control on _msg.sender_ for DAO membership is required in",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureumDAO_ contract snippet shown below. This is the same contract snippet you will see for all the 8 questions in this quiz. The _InSecureumDAO_ contract snippet illustrates some basic functionality of a Decentralized Autonomous Organization (DAO) which includes the opening of the DAO for memberships, allowing users to join as members by depositing a membership fee, creating proposals for voting, casting votes, etc. Assume that all other functionality (that is not shown or represented by ...) is implemented correctly.\n```\npragma solidity 0.8.4;\nimport 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol';\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\";\n\ncontract InSecureumDAO is Pausable, ReentrancyGuard {\n\n    // Assume that all functionality represented by ... below is implemented as expected\n\n    address public admin;\n    mapping (address => bool) public members;\n    mapping (uint256 => uint8[]) public votes;\n    mapping (uint256 => uint8) public winningOutcome;\n    uint256 memberCount = 0;\n    uint256 membershipFee = 1000;\n\n    modifier onlyWhenOpen() {\n        require(address(this).balance > 0, 'InSecureumDAO: This DAO is closed');\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    modifier voteExists(uint256 _voteId) {\n       // Assume this correctly checks if _voteId is present in votes\n        ...\n        _;\n    }\n\n    constructor (address _admin) {\n        require(_admin == address(0));\n        admin = _admin;\n    }\n\n    function openDAO() external payable onlyAdmin {\n        // Admin is expected to open DAO by making a notional deposit\n        ...\n    }\n\n    function join() external payable onlyWhenOpen nonReentrant {\n        require(msg.value == membershipFee, 'InSecureumDAO: Incorrect ETH amount');\n        members[msg.sender] = true;\n        ...\n    }\n\n    function createVote(uint256 _voteId, uint8[] memory _possibleOutcomes) external onlyWhenOpen whenNotPaused {\n        votes[_voteId] = _possibleOutcomes;\n        ...\n    }\n\n    function castVote(uint256 _voteId, uint8 _vote) external voteExists(_voteId) onlyWhenOpen whenNotPaused {\n        ...\n    }\n\n    function getWinningOutcome(uint256 _voteId) public view returns (uint8) {\n        // Anyone is allowed to view winning outcome\n        ...\n        return(winningOutcome[_voteId]);\n    }\n\n    function setMembershipFee(uint256 _fee) external onlyAdmin {\n        membershipFee = _fee;\n    }\n\n    function removeAllMembers() external onlyAdmin {\n        delete members[msg.sender];\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "_createVote()_ to prevent non-members from creating votes"
      },
      {
        "choice": "B",
        "answer": "_castVote()_ to prevent non-members from casting votes"
      },
      {
        "choice": "C",
        "answer": "_getWinningOutcome()_ to prevent non-members from viewing winning outcomes"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B"
    ],
    "race": "RACE-2.md"
  },
  {
    "question": "5] A commit/reveal scheme (a cryptographic primitive that allows one to commit to a chosen value while keeping it hidden from others, with the ability to reveal the committed value later) is relevant for",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureumDAO_ contract snippet shown below. This is the same contract snippet you will see for all the 8 questions in this quiz. The _InSecureumDAO_ contract snippet illustrates some basic functionality of a Decentralized Autonomous Organization (DAO) which includes the opening of the DAO for memberships, allowing users to join as members by depositing a membership fee, creating proposals for voting, casting votes, etc. Assume that all other functionality (that is not shown or represented by ...) is implemented correctly.\n```\npragma solidity 0.8.4;\nimport 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol';\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\";\n\ncontract InSecureumDAO is Pausable, ReentrancyGuard {\n\n    // Assume that all functionality represented by ... below is implemented as expected\n\n    address public admin;\n    mapping (address => bool) public members;\n    mapping (uint256 => uint8[]) public votes;\n    mapping (uint256 => uint8) public winningOutcome;\n    uint256 memberCount = 0;\n    uint256 membershipFee = 1000;\n\n    modifier onlyWhenOpen() {\n        require(address(this).balance > 0, 'InSecureumDAO: This DAO is closed');\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    modifier voteExists(uint256 _voteId) {\n       // Assume this correctly checks if _voteId is present in votes\n        ...\n        _;\n    }\n\n    constructor (address _admin) {\n        require(_admin == address(0));\n        admin = _admin;\n    }\n\n    function openDAO() external payable onlyAdmin {\n        // Admin is expected to open DAO by making a notional deposit\n        ...\n    }\n\n    function join() external payable onlyWhenOpen nonReentrant {\n        require(msg.value == membershipFee, 'InSecureumDAO: Incorrect ETH amount');\n        members[msg.sender] = true;\n        ...\n    }\n\n    function createVote(uint256 _voteId, uint8[] memory _possibleOutcomes) external onlyWhenOpen whenNotPaused {\n        votes[_voteId] = _possibleOutcomes;\n        ...\n    }\n\n    function castVote(uint256 _voteId, uint8 _vote) external voteExists(_voteId) onlyWhenOpen whenNotPaused {\n        ...\n    }\n\n    function getWinningOutcome(uint256 _voteId) public view returns (uint8) {\n        // Anyone is allowed to view winning outcome\n        ...\n        return(winningOutcome[_voteId]);\n    }\n\n    function setMembershipFee(uint256 _fee) external onlyAdmin {\n        membershipFee = _fee;\n    }\n\n    function removeAllMembers() external onlyAdmin {\n        delete members[msg.sender];\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "_join()_ to not disclose _msg.sender_ while joining the DAO"
      },
      {
        "choice": "B",
        "answer": "_createVote()_ to not disclose the possible outcomes during creation"
      },
      {
        "choice": "C",
        "answer": "_castVote()_ to not disclose the vote being cast"
      },
      {
        "choice": "D",
        "answer": "All the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-2.md"
  },
  {
    "question": "6] Security concern(s) from missing input validation(s) is/are present in",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureumDAO_ contract snippet shown below. This is the same contract snippet you will see for all the 8 questions in this quiz. The _InSecureumDAO_ contract snippet illustrates some basic functionality of a Decentralized Autonomous Organization (DAO) which includes the opening of the DAO for memberships, allowing users to join as members by depositing a membership fee, creating proposals for voting, casting votes, etc. Assume that all other functionality (that is not shown or represented by ...) is implemented correctly.\n```\npragma solidity 0.8.4;\nimport 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol';\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\";\n\ncontract InSecureumDAO is Pausable, ReentrancyGuard {\n\n    // Assume that all functionality represented by ... below is implemented as expected\n\n    address public admin;\n    mapping (address => bool) public members;\n    mapping (uint256 => uint8[]) public votes;\n    mapping (uint256 => uint8) public winningOutcome;\n    uint256 memberCount = 0;\n    uint256 membershipFee = 1000;\n\n    modifier onlyWhenOpen() {\n        require(address(this).balance > 0, 'InSecureumDAO: This DAO is closed');\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    modifier voteExists(uint256 _voteId) {\n       // Assume this correctly checks if _voteId is present in votes\n        ...\n        _;\n    }\n\n    constructor (address _admin) {\n        require(_admin == address(0));\n        admin = _admin;\n    }\n\n    function openDAO() external payable onlyAdmin {\n        // Admin is expected to open DAO by making a notional deposit\n        ...\n    }\n\n    function join() external payable onlyWhenOpen nonReentrant {\n        require(msg.value == membershipFee, 'InSecureumDAO: Incorrect ETH amount');\n        members[msg.sender] = true;\n        ...\n    }\n\n    function createVote(uint256 _voteId, uint8[] memory _possibleOutcomes) external onlyWhenOpen whenNotPaused {\n        votes[_voteId] = _possibleOutcomes;\n        ...\n    }\n\n    function castVote(uint256 _voteId, uint8 _vote) external voteExists(_voteId) onlyWhenOpen whenNotPaused {\n        ...\n    }\n\n    function getWinningOutcome(uint256 _voteId) public view returns (uint8) {\n        // Anyone is allowed to view winning outcome\n        ...\n        return(winningOutcome[_voteId]);\n    }\n\n    function setMembershipFee(uint256 _fee) external onlyAdmin {\n        membershipFee = _fee;\n    }\n\n    function removeAllMembers() external onlyAdmin {\n        delete members[msg.sender];\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "_createVote()_ for duplicate `_voteId`"
      },
      {
        "choice": "B",
        "answer": "_castVote()_ for existing `_voteId`"
      },
      {
        "choice": "C",
        "answer": "_getWinningOutcome()_ for existing `_voteId`"
      },
      {
        "choice": "D",
        "answer": "_setMembershipFee()_ for sanity/threshold checks on `_fee` \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "D"
    ],
    "race": "RACE-2.md"
  },
  {
    "question": "7] _removeAllMembers()_ function",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureumDAO_ contract snippet shown below. This is the same contract snippet you will see for all the 8 questions in this quiz. The _InSecureumDAO_ contract snippet illustrates some basic functionality of a Decentralized Autonomous Organization (DAO) which includes the opening of the DAO for memberships, allowing users to join as members by depositing a membership fee, creating proposals for voting, casting votes, etc. Assume that all other functionality (that is not shown or represented by ...) is implemented correctly.\n```\npragma solidity 0.8.4;\nimport 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol';\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\";\n\ncontract InSecureumDAO is Pausable, ReentrancyGuard {\n\n    // Assume that all functionality represented by ... below is implemented as expected\n\n    address public admin;\n    mapping (address => bool) public members;\n    mapping (uint256 => uint8[]) public votes;\n    mapping (uint256 => uint8) public winningOutcome;\n    uint256 memberCount = 0;\n    uint256 membershipFee = 1000;\n\n    modifier onlyWhenOpen() {\n        require(address(this).balance > 0, 'InSecureumDAO: This DAO is closed');\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    modifier voteExists(uint256 _voteId) {\n       // Assume this correctly checks if _voteId is present in votes\n        ...\n        _;\n    }\n\n    constructor (address _admin) {\n        require(_admin == address(0));\n        admin = _admin;\n    }\n\n    function openDAO() external payable onlyAdmin {\n        // Admin is expected to open DAO by making a notional deposit\n        ...\n    }\n\n    function join() external payable onlyWhenOpen nonReentrant {\n        require(msg.value == membershipFee, 'InSecureumDAO: Incorrect ETH amount');\n        members[msg.sender] = true;\n        ...\n    }\n\n    function createVote(uint256 _voteId, uint8[] memory _possibleOutcomes) external onlyWhenOpen whenNotPaused {\n        votes[_voteId] = _possibleOutcomes;\n        ...\n    }\n\n    function castVote(uint256 _voteId, uint8 _vote) external voteExists(_voteId) onlyWhenOpen whenNotPaused {\n        ...\n    }\n\n    function getWinningOutcome(uint256 _voteId) public view returns (uint8) {\n        // Anyone is allowed to view winning outcome\n        ...\n        return(winningOutcome[_voteId]);\n    }\n\n    function setMembershipFee(uint256 _fee) external onlyAdmin {\n        membershipFee = _fee;\n    }\n\n    function removeAllMembers() external onlyAdmin {\n        delete members[msg.sender];\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Will not work as expected to remove all the members from the DAO"
      },
      {
        "choice": "B",
        "answer": "Will work as expected to remove all the members from the DAO"
      },
      {
        "choice": "C",
        "answer": "Is a critical function missing an event emission"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "C"
    ],
    "race": "RACE-2.md"
  },
  {
    "question": "8] _InSecureumDAO_ will not be susceptible to something like the 2016 DAO exploit",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureumDAO_ contract snippet shown below. This is the same contract snippet you will see for all the 8 questions in this quiz. The _InSecureumDAO_ contract snippet illustrates some basic functionality of a Decentralized Autonomous Organization (DAO) which includes the opening of the DAO for memberships, allowing users to join as members by depositing a membership fee, creating proposals for voting, casting votes, etc. Assume that all other functionality (that is not shown or represented by ...) is implemented correctly.\n```\npragma solidity 0.8.4;\nimport 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol';\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\";\n\ncontract InSecureumDAO is Pausable, ReentrancyGuard {\n\n    // Assume that all functionality represented by ... below is implemented as expected\n\n    address public admin;\n    mapping (address => bool) public members;\n    mapping (uint256 => uint8[]) public votes;\n    mapping (uint256 => uint8) public winningOutcome;\n    uint256 memberCount = 0;\n    uint256 membershipFee = 1000;\n\n    modifier onlyWhenOpen() {\n        require(address(this).balance > 0, 'InSecureumDAO: This DAO is closed');\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    modifier voteExists(uint256 _voteId) {\n       // Assume this correctly checks if _voteId is present in votes\n        ...\n        _;\n    }\n\n    constructor (address _admin) {\n        require(_admin == address(0));\n        admin = _admin;\n    }\n\n    function openDAO() external payable onlyAdmin {\n        // Admin is expected to open DAO by making a notional deposit\n        ...\n    }\n\n    function join() external payable onlyWhenOpen nonReentrant {\n        require(msg.value == membershipFee, 'InSecureumDAO: Incorrect ETH amount');\n        members[msg.sender] = true;\n        ...\n    }\n\n    function createVote(uint256 _voteId, uint8[] memory _possibleOutcomes) external onlyWhenOpen whenNotPaused {\n        votes[_voteId] = _possibleOutcomes;\n        ...\n    }\n\n    function castVote(uint256 _voteId, uint8 _vote) external voteExists(_voteId) onlyWhenOpen whenNotPaused {\n        ...\n    }\n\n    function getWinningOutcome(uint256 _voteId) public view returns (uint8) {\n        // Anyone is allowed to view winning outcome\n        ...\n        return(winningOutcome[_voteId]);\n    }\n\n    function setMembershipFee(uint256 _fee) external onlyAdmin {\n        membershipFee = _fee;\n    }\n\n    function removeAllMembers() external onlyAdmin {\n        delete members[msg.sender];\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Because it derives from _ReentrancyGuard.sol_ which protects all contract functions by default"
      },
      {
        "choice": "B",
        "answer": "Only if it does not have a withdraw Ether function vulnerable to reentrancy and makes no external calls"
      },
      {
        "choice": "C",
        "answer": "Because Ethereum protocol was fixed after the DAO exploit to prevent such exploits"
      },
      {
        "choice": "D",
        "answer": "Because Solidity language was fixed after the DAO exploit to prevent such exploits \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-2.md"
  },
  {
    "question": "1] Select all true statements: \\",
    "context": "**Note**: The first four questions are based on the below library. The same library will appear for all the first four questions. The question is below the shown library.\n```\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Efficient library for creating string representations of integers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/v7/src/utils/LibString.sol)\nlibrary LibString {\n    function toString(uint256 n) internal pure returns (string memory str) {\n        if (n == 0) return \"0\"; // Otherwise it'd output an empty string for 0.\n\n        assembly {\n            let k := 78 // Start with the max length a uint256 string could be.\n\n            // We'll store our string at the first chunk of free memory.\n            str := mload(0x40)\n\n            // The length of our string will start off at the max of 78.\n            mstore(str, k)\n\n            // Update the free memory pointer to prevent overriding our string.\n            // Add 128 to the str pointer instead of 78 because we want to maintain\n            // the Solidity convention of keeping the free memory pointer word aligned.\n            mstore(0x40, add(str, 128))\n\n            // We'll populate the string from right to left.\n            // prettier-ignore\n            for {} n {} {\n                // The ASCII digit offset for '0' is 48.\n                let char := add(48, mod(n, 10))\n\n                // Write the current character into str.\n                mstore(add(str, k), char)\n\n                k := sub(k, 1)\n                n := div(n, 10)\n            }\n\n            // Shift the pointer to the start of the string.\n            str := add(str, k)\n\n            // Set the length of the string to the correct value.\n            mstore(str, sub(78, k))\n        }\n    }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The inline assembly block is `memory-safe` \\"
      },
      {
        "choice": "B",
        "answer": "The memory after `toString(...)` call is always 32-byte aligned \\"
      },
      {
        "choice": "C",
        "answer": "Instead of allocating memory from 0x40, the function can allocate from 0x0 to save gas (memory expansion cost) and still be correct \\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "race": "RACE-20.md"
  },
  {
    "question": "2] Select all true statements about the expression `mstore(0x40, add(str, 128))` \\",
    "context": "**Note**: The first four questions are based on the below library. The same library will appear for all the first four questions. The question is below the shown library.\n```\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Efficient library for creating string representations of integers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/v7/src/utils/LibString.sol)\nlibrary LibString {\n    function toString(uint256 n) internal pure returns (string memory str) {\n        if (n == 0) return \"0\"; // Otherwise it'd output an empty string for 0.\n\n        assembly {\n            let k := 78 // Start with the max length a uint256 string could be.\n\n            // We'll store our string at the first chunk of free memory.\n            str := mload(0x40)\n\n            // The length of our string will start off at the max of 78.\n            mstore(str, k)\n\n            // Update the free memory pointer to prevent overriding our string.\n            // Add 128 to the str pointer instead of 78 because we want to maintain\n            // the Solidity convention of keeping the free memory pointer word aligned.\n            mstore(0x40, add(str, 128))\n\n            // We'll populate the string from right to left.\n            // prettier-ignore\n            for {} n {} {\n                // The ASCII digit offset for '0' is 48.\n                let char := add(48, mod(n, 10))\n\n                // Write the current character into str.\n                mstore(add(str, k), char)\n\n                k := sub(k, 1)\n                n := div(n, 10)\n            }\n\n            // Shift the pointer to the start of the string.\n            str := add(str, k)\n\n            // Set the length of the string to the correct value.\n            mstore(str, sub(78, k))\n        }\n    }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The expression allocated more memory than required. The value 128 can be replaced by 96. \\"
      },
      {
        "choice": "B",
        "answer": "The expression allocates less memory than required. The value 128 can be replaced by 160. \\"
      },
      {
        "choice": "C",
        "answer": "The expression is redundant and can be removed to save gas \\"
      },
      {
        "choice": "D",
        "answer": "The expression is not `memory-safe` assembly in this context \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-20.md"
  },
  {
    "question": "3] Select all true statements: \\",
    "context": "**Note**: The first four questions are based on the below library. The same library will appear for all the first four questions. The question is below the shown library.\n```\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Efficient library for creating string representations of integers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/v7/src/utils/LibString.sol)\nlibrary LibString {\n    function toString(uint256 n) internal pure returns (string memory str) {\n        if (n == 0) return \"0\"; // Otherwise it'd output an empty string for 0.\n\n        assembly {\n            let k := 78 // Start with the max length a uint256 string could be.\n\n            // We'll store our string at the first chunk of free memory.\n            str := mload(0x40)\n\n            // The length of our string will start off at the max of 78.\n            mstore(str, k)\n\n            // Update the free memory pointer to prevent overriding our string.\n            // Add 128 to the str pointer instead of 78 because we want to maintain\n            // the Solidity convention of keeping the free memory pointer word aligned.\n            mstore(0x40, add(str, 128))\n\n            // We'll populate the string from right to left.\n            // prettier-ignore\n            for {} n {} {\n                // The ASCII digit offset for '0' is 48.\n                let char := add(48, mod(n, 10))\n\n                // Write the current character into str.\n                mstore(add(str, k), char)\n\n                k := sub(k, 1)\n                n := div(n, 10)\n            }\n\n            // Shift the pointer to the start of the string.\n            str := add(str, k)\n\n            // Set the length of the string to the correct value.\n            mstore(str, sub(78, k))\n        }\n    }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The expression `mstore(str, k)` at the beginning can be removed to save gas \\"
      },
      {
        "choice": "B",
        "answer": "The expression `mstore(add(str, k), char)` can be replaced by an equivalent `mstore8(...)` to simplify the code \\"
      },
      {
        "choice": "C",
        "answer": "The final expression `mstore(str, sub(78, k))` can be removed to save gas \\"
      },
      {
        "choice": "D",
        "answer": "The function does not return the correct output for `n = 2**256 - 1` \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B"
    ],
    "race": "RACE-20.md"
  },
  {
    "question": "4] Select all true statements: \\",
    "context": "**Note**: The first four questions are based on the below library. The same library will appear for all the first four questions. The question is below the shown library.\n```\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Efficient library for creating string representations of integers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/v7/src/utils/LibString.sol)\nlibrary LibString {\n    function toString(uint256 n) internal pure returns (string memory str) {\n        if (n == 0) return \"0\"; // Otherwise it'd output an empty string for 0.\n\n        assembly {\n            let k := 78 // Start with the max length a uint256 string could be.\n\n            // We'll store our string at the first chunk of free memory.\n            str := mload(0x40)\n\n            // The length of our string will start off at the max of 78.\n            mstore(str, k)\n\n            // Update the free memory pointer to prevent overriding our string.\n            // Add 128 to the str pointer instead of 78 because we want to maintain\n            // the Solidity convention of keeping the free memory pointer word aligned.\n            mstore(0x40, add(str, 128))\n\n            // We'll populate the string from right to left.\n            // prettier-ignore\n            for {} n {} {\n                // The ASCII digit offset for '0' is 48.\n                let char := add(48, mod(n, 10))\n\n                // Write the current character into str.\n                mstore(add(str, k), char)\n\n                k := sub(k, 1)\n                n := div(n, 10)\n            }\n\n            // Shift the pointer to the start of the string.\n            str := add(str, k)\n\n            // Set the length of the string to the correct value.\n            mstore(str, sub(78, k))\n        }\n    }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The function correctly cleans all necessary memory regions \\"
      },
      {
        "choice": "B",
        "answer": "Solidity will correctly be able to handle the string returned by the function \\"
      },
      {
        "choice": "C",
        "answer": "The last bits of memory in the string may be dirty \\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C"
    ],
    "race": "RACE-20.md"
  },
  {
    "question": "5] Select all true statements: \\",
    "context": "**Note**: The first four questions are based on the below library. The same library will appear for all the first four questions. The question is below the shown library.\n```\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Efficient library for creating string representations of integers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/v7/src/utils/LibString.sol)\nlibrary LibString {\n    function toString(uint256 n) internal pure returns (string memory str) {\n        if (n == 0) return \"0\"; // Otherwise it'd output an empty string for 0.\n\n        assembly {\n            let k := 78 // Start with the max length a uint256 string could be.\n\n            // We'll store our string at the first chunk of free memory.\n            str := mload(0x40)\n\n            // The length of our string will start off at the max of 78.\n            mstore(str, k)\n\n            // Update the free memory pointer to prevent overriding our string.\n            // Add 128 to the str pointer instead of 78 because we want to maintain\n            // the Solidity convention of keeping the free memory pointer word aligned.\n            mstore(0x40, add(str, 128))\n\n            // We'll populate the string from right to left.\n            // prettier-ignore\n            for {} n {} {\n                // The ASCII digit offset for '0' is 48.\n                let char := add(48, mod(n, 10))\n\n                // Write the current character into str.\n                mstore(add(str, k), char)\n\n                k := sub(k, 1)\n                n := div(n, 10)\n            }\n\n            // Shift the pointer to the start of the string.\n            str := add(str, k)\n\n            // Set the length of the string to the correct value.\n            mstore(str, sub(78, k))\n        }\n    }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The re-entrancy lock is always unnecessary as its never possible to re-enter the contract \\"
      },
      {
        "choice": "B",
        "answer": "Calls to `_delegate` are correctly protected for re-entrancy \\"
      },
      {
        "choice": "C",
        "answer": "The re-entrancy lock is correctly unlocked in some cases \\"
      },
      {
        "choice": "D",
        "answer": "The re-entrancy lock is correctly unlocked in all cases \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-20.md"
  },
  {
    "question": "6] Select all true statements: \\",
    "context": "**Note**: The first four questions are based on the below library. The same library will appear for all the first four questions. The question is below the shown library.\n```\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Efficient library for creating string representations of integers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/v7/src/utils/LibString.sol)\nlibrary LibString {\n    function toString(uint256 n) internal pure returns (string memory str) {\n        if (n == 0) return \"0\"; // Otherwise it'd output an empty string for 0.\n\n        assembly {\n            let k := 78 // Start with the max length a uint256 string could be.\n\n            // We'll store our string at the first chunk of free memory.\n            str := mload(0x40)\n\n            // The length of our string will start off at the max of 78.\n            mstore(str, k)\n\n            // Update the free memory pointer to prevent overriding our string.\n            // Add 128 to the str pointer instead of 78 because we want to maintain\n            // the Solidity convention of keeping the free memory pointer word aligned.\n            mstore(0x40, add(str, 128))\n\n            // We'll populate the string from right to left.\n            // prettier-ignore\n            for {} n {} {\n                // The ASCII digit offset for '0' is 48.\n                let char := add(48, mod(n, 10))\n\n                // Write the current character into str.\n                mstore(add(str, k), char)\n\n                k := sub(k, 1)\n                n := div(n, 10)\n            }\n\n            // Shift the pointer to the start of the string.\n            str := add(str, k)\n\n            // Set the length of the string to the correct value.\n            mstore(str, sub(78, k))\n        }\n    }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The assembly block is correctly marked as `memory-safe` \\"
      },
      {
        "choice": "B",
        "answer": "The assembly block will always violate the memory requirements needed for `memory-safe` blocks \\"
      },
      {
        "choice": "C",
        "answer": "In some cases, the assembly block will not violate the requirement needed for `memory-safe` blocks \\"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-20.md"
  },
  {
    "question": "7] Select all true statements: \\",
    "context": "**Note**: The first four questions are based on the below library. The same library will appear for all the first four questions. The question is below the shown library.\n```\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Efficient library for creating string representations of integers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/v7/src/utils/LibString.sol)\nlibrary LibString {\n    function toString(uint256 n) internal pure returns (string memory str) {\n        if (n == 0) return \"0\"; // Otherwise it'd output an empty string for 0.\n\n        assembly {\n            let k := 78 // Start with the max length a uint256 string could be.\n\n            // We'll store our string at the first chunk of free memory.\n            str := mload(0x40)\n\n            // The length of our string will start off at the max of 78.\n            mstore(str, k)\n\n            // Update the free memory pointer to prevent overriding our string.\n            // Add 128 to the str pointer instead of 78 because we want to maintain\n            // the Solidity convention of keeping the free memory pointer word aligned.\n            mstore(0x40, add(str, 128))\n\n            // We'll populate the string from right to left.\n            // prettier-ignore\n            for {} n {} {\n                // The ASCII digit offset for '0' is 48.\n                let char := add(48, mod(n, 10))\n\n                // Write the current character into str.\n                mstore(add(str, k), char)\n\n                k := sub(k, 1)\n                n := div(n, 10)\n            }\n\n            // Shift the pointer to the start of the string.\n            str := add(str, k)\n\n            // Set the length of the string to the correct value.\n            mstore(str, sub(78, k))\n        }\n    }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "The expression `calldatacopy(0, 0, calldatasize())` violates `memory-safe` assembly annotation \\"
      },
      {
        "choice": "B",
        "answer": "The expression `returndatacopy(0, 0, returndatasize())` violates `memory-safe` assembly annotation \\"
      },
      {
        "choice": "C",
        "answer": "The expression `delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)` violates `memory-safe` assembly annotation \\"
      },
      {
        "choice": "D",
        "answer": "The expression `return(0, returndatasize())` violates `memory-safe` assembly annotation \\"
      }
    ],
    "correctAnswers": [
      "A",
      "B"
    ],
    "race": "RACE-20.md"
  },
  {
    "question": "8] Select all true statements: \\",
    "context": "**Note**: The first four questions are based on the below library. The same library will appear for all the first four questions. The question is below the shown library.\n```\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Efficient library for creating string representations of integers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/v7/src/utils/LibString.sol)\nlibrary LibString {\n    function toString(uint256 n) internal pure returns (string memory str) {\n        if (n == 0) return \"0\"; // Otherwise it'd output an empty string for 0.\n\n        assembly {\n            let k := 78 // Start with the max length a uint256 string could be.\n\n            // We'll store our string at the first chunk of free memory.\n            str := mload(0x40)\n\n            // The length of our string will start off at the max of 78.\n            mstore(str, k)\n\n            // Update the free memory pointer to prevent overriding our string.\n            // Add 128 to the str pointer instead of 78 because we want to maintain\n            // the Solidity convention of keeping the free memory pointer word aligned.\n            mstore(0x40, add(str, 128))\n\n            // We'll populate the string from right to left.\n            // prettier-ignore\n            for {} n {} {\n                // The ASCII digit offset for '0' is 48.\n                let char := add(48, mod(n, 10))\n\n                // Write the current character into str.\n                mstore(add(str, k), char)\n\n                k := sub(k, 1)\n                n := div(n, 10)\n            }\n\n            // Shift the pointer to the start of the string.\n            str := add(str, k)\n\n            // Set the length of the string to the correct value.\n            mstore(str, sub(78, k))\n        }\n    }\n}\n```\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "`delegatecall` can never re-enter as the state is shared \\"
      },
      {
        "choice": "B",
        "answer": "`delegatecall` proxies without proper access controls may be prone to `selfdestruct` \\"
      },
      {
        "choice": "C",
        "answer": "Proxies are typically used to save deploy-time gas costs \\"
      },
      {
        "choice": "D",
        "answer": "Proxies can be used to prevent contract size limit issues \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C",
      "D"
    ],
    "race": "RACE-20.md"
  },
  {
    "question": "1] Missing zero-address check(s) in the contract",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureumNFT_ contract snippet. This is the same contract snippet you will see for all the 8 questions in this quiz.\n\n_InSecureumNFT_ is a NFT project that aims to distribute CryptoSAFU NFTs to its community where most of them are fairdropped based on past contributions and a few are sold. CryptoSAFUs with lower IDs have more unique traits, may be valued higher and therefore require a random distribution for fairness. Assume that all strictly required ERC721 functionality (not shown) and any other required functionality (not shown) are implemented correctly. Only functionality specific to the sale and minting of NFTs is shown in this contract snippet.\n```\npragma solidity 0.8.0;\n\ninterface ERC721TokenReceiver{function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);}\n\n// Assume that all strictly required ERC721 functionality (not shown) is implemented correctly\n// Assume that any other required functionality (not shown) is implemented correctly\ncontract InSecureumNFT {\n    bytes4 internal constant MAGIC_ERC721_RECEIVED = 0x150b7a02;\n    uint public constant TOKEN_LIMIT = 10; // 10 for testing, 13337 for production\n    uint public constant SALE_LIMIT = 5; // 5 for testing, 1337 for production\n\n    mapping (uint256 => address) internal idToOwner;\n    uint internal numTokens = 0;\n    uint internal numSales = 0;\n    address payable internal deployer;\n    address payable internal beneficiary;\n    bool public publicSale = false;\n    uint private price;\n    uint public saleStartTime;\n    uint public constant saleDuration = 13*13337; // 13337 blocks assuming 13s block times \n    uint internal nonce = 0;\n    uint[TOKEN_LIMIT] internal indices;\n \n    constructor(address payable _beneficiary) {\n        deployer = payable(msg.sender);\n        beneficiary = _beneficiary;\n    }\n\n    function startSale(uint _price) external {\n        require(msg.sender == deployer || _price != 0, \"Only deployer and price cannot be zero\");\n        price = _price;\n        saleStartTime = block.timestamp;\n        publicSale = true;\n    }\n\n    function isContract(address _addr) internal view returns (bool addressCheck) {\n        uint256 size;\n        assembly { size := extcodesize(_addr) }\n        addressCheck = size > 0;\n    }\n\n    function randomIndex() internal returns (uint) {\n        uint totalSize = TOKEN_LIMIT - numTokens;\n        uint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;\n        uint value = 0;\n        if (indices[index] != 0) {\n            value = indices[index];\n        } else {\n            value = index;\n        }\n        if (indices[totalSize - 1] == 0) {\n            indices[index] = totalSize - 1;\n        } else {\n            indices[index] = indices[totalSize - 1];\n        }\n        nonce += 1;\n        return (value + 1);\n    }\n\n    // Calculate the mint price\n    function getPrice() public view returns (uint) {\n        require(publicSale, \"Sale not started.\");\n        uint elapsed = block.timestamp - saleStartTime;\n        if (elapsed > saleDuration) {\n            return 0;\n        } else {\n            return ((saleDuration - elapsed) * price) / saleDuration;\n        }\n    }\n    \n    // SALE_LIMIT is 1337 \n    // Rest i.e. (TOKEN_LIMIT - SALE_LIMIT) are reserved for community distribution (not shown)\n    function mint() external payable returns (uint) {\n        require(publicSale, \"Sale not started.\");\n        require(numSales < SALE_LIMIT, \"Sale limit reached.\");\n        numSales++;\n        uint salePrice = getPrice();\n        require((address(this)).balance >= salePrice, \"Insufficient funds to purchase.\");\n        if ((address(this)).balance >= salePrice) {\n            payable(msg.sender).transfer((address(this)).balance - salePrice);\n        }\n        return _mint(msg.sender);\n    }\n\n    // TOKEN_LIMIT is 13337\n    function _mint(address _to) internal returns (uint) {\n        require(numTokens < TOKEN_LIMIT, \"Token limit reached.\");\n        // Lower indexed/numbered NFTs have rare traits and may be considered\n        // as more valuable by buyers => Therefore randomize\n        uint id = randomIndex();\n        if (isContract(_to)) {\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), id, \"\");\n            require(retval == MAGIC_ERC721_RECEIVED);\n        }\n        require(idToOwner[id] == address(0), \"Cannot add, already owned.\");\n        idToOwner[id] = _to;\n        numTokens = numTokens + 1;\n        beneficiary.transfer((address(this)).balance);\n        return id;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "May allow anyone to start the sale"
      },
      {
        "choice": "B",
        "answer": "May put the NFT sale proceeds at risk"
      },
      {
        "choice": "C",
        "answer": "May burn the newly minted NFTs"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-3.md"
  },
  {
    "question": "2] Given that lower indexed/numbered CryptoSAFU NFTs have rarer traits (and are considered more valuable as commented in `_mint`), the implementation of _InSecureumNFT_ is susceptible to the following exploits",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureumNFT_ contract snippet. This is the same contract snippet you will see for all the 8 questions in this quiz.\n\n_InSecureumNFT_ is a NFT project that aims to distribute CryptoSAFU NFTs to its community where most of them are fairdropped based on past contributions and a few are sold. CryptoSAFUs with lower IDs have more unique traits, may be valued higher and therefore require a random distribution for fairness. Assume that all strictly required ERC721 functionality (not shown) and any other required functionality (not shown) are implemented correctly. Only functionality specific to the sale and minting of NFTs is shown in this contract snippet.\n```\npragma solidity 0.8.0;\n\ninterface ERC721TokenReceiver{function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);}\n\n// Assume that all strictly required ERC721 functionality (not shown) is implemented correctly\n// Assume that any other required functionality (not shown) is implemented correctly\ncontract InSecureumNFT {\n    bytes4 internal constant MAGIC_ERC721_RECEIVED = 0x150b7a02;\n    uint public constant TOKEN_LIMIT = 10; // 10 for testing, 13337 for production\n    uint public constant SALE_LIMIT = 5; // 5 for testing, 1337 for production\n\n    mapping (uint256 => address) internal idToOwner;\n    uint internal numTokens = 0;\n    uint internal numSales = 0;\n    address payable internal deployer;\n    address payable internal beneficiary;\n    bool public publicSale = false;\n    uint private price;\n    uint public saleStartTime;\n    uint public constant saleDuration = 13*13337; // 13337 blocks assuming 13s block times \n    uint internal nonce = 0;\n    uint[TOKEN_LIMIT] internal indices;\n \n    constructor(address payable _beneficiary) {\n        deployer = payable(msg.sender);\n        beneficiary = _beneficiary;\n    }\n\n    function startSale(uint _price) external {\n        require(msg.sender == deployer || _price != 0, \"Only deployer and price cannot be zero\");\n        price = _price;\n        saleStartTime = block.timestamp;\n        publicSale = true;\n    }\n\n    function isContract(address _addr) internal view returns (bool addressCheck) {\n        uint256 size;\n        assembly { size := extcodesize(_addr) }\n        addressCheck = size > 0;\n    }\n\n    function randomIndex() internal returns (uint) {\n        uint totalSize = TOKEN_LIMIT - numTokens;\n        uint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;\n        uint value = 0;\n        if (indices[index] != 0) {\n            value = indices[index];\n        } else {\n            value = index;\n        }\n        if (indices[totalSize - 1] == 0) {\n            indices[index] = totalSize - 1;\n        } else {\n            indices[index] = indices[totalSize - 1];\n        }\n        nonce += 1;\n        return (value + 1);\n    }\n\n    // Calculate the mint price\n    function getPrice() public view returns (uint) {\n        require(publicSale, \"Sale not started.\");\n        uint elapsed = block.timestamp - saleStartTime;\n        if (elapsed > saleDuration) {\n            return 0;\n        } else {\n            return ((saleDuration - elapsed) * price) / saleDuration;\n        }\n    }\n    \n    // SALE_LIMIT is 1337 \n    // Rest i.e. (TOKEN_LIMIT - SALE_LIMIT) are reserved for community distribution (not shown)\n    function mint() external payable returns (uint) {\n        require(publicSale, \"Sale not started.\");\n        require(numSales < SALE_LIMIT, \"Sale limit reached.\");\n        numSales++;\n        uint salePrice = getPrice();\n        require((address(this)).balance >= salePrice, \"Insufficient funds to purchase.\");\n        if ((address(this)).balance >= salePrice) {\n            payable(msg.sender).transfer((address(this)).balance - salePrice);\n        }\n        return _mint(msg.sender);\n    }\n\n    // TOKEN_LIMIT is 13337\n    function _mint(address _to) internal returns (uint) {\n        require(numTokens < TOKEN_LIMIT, \"Token limit reached.\");\n        // Lower indexed/numbered NFTs have rare traits and may be considered\n        // as more valuable by buyers => Therefore randomize\n        uint id = randomIndex();\n        if (isContract(_to)) {\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), id, \"\");\n            require(retval == MAGIC_ERC721_RECEIVED);\n        }\n        require(idToOwner[id] == address(0), \"Cannot add, already owned.\");\n        idToOwner[id] = _to;\n        numTokens = numTokens + 1;\n        beneficiary.transfer((address(this)).balance);\n        return id;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Buyers can repeatedly mint and revert until they receive desired NFT"
      },
      {
        "choice": "B",
        "answer": "Buyers can generate addresses to mint until they receive desired NFT"
      },
      {
        "choice": "C",
        "answer": "Miners can manipulate _block.timestamp_ to facilitate minting of desired NFT"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C"
    ],
    "race": "RACE-3.md"
  },
  {
    "question": "3] The _getPrice()_ function",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureumNFT_ contract snippet. This is the same contract snippet you will see for all the 8 questions in this quiz.\n\n_InSecureumNFT_ is a NFT project that aims to distribute CryptoSAFU NFTs to its community where most of them are fairdropped based on past contributions and a few are sold. CryptoSAFUs with lower IDs have more unique traits, may be valued higher and therefore require a random distribution for fairness. Assume that all strictly required ERC721 functionality (not shown) and any other required functionality (not shown) are implemented correctly. Only functionality specific to the sale and minting of NFTs is shown in this contract snippet.\n```\npragma solidity 0.8.0;\n\ninterface ERC721TokenReceiver{function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);}\n\n// Assume that all strictly required ERC721 functionality (not shown) is implemented correctly\n// Assume that any other required functionality (not shown) is implemented correctly\ncontract InSecureumNFT {\n    bytes4 internal constant MAGIC_ERC721_RECEIVED = 0x150b7a02;\n    uint public constant TOKEN_LIMIT = 10; // 10 for testing, 13337 for production\n    uint public constant SALE_LIMIT = 5; // 5 for testing, 1337 for production\n\n    mapping (uint256 => address) internal idToOwner;\n    uint internal numTokens = 0;\n    uint internal numSales = 0;\n    address payable internal deployer;\n    address payable internal beneficiary;\n    bool public publicSale = false;\n    uint private price;\n    uint public saleStartTime;\n    uint public constant saleDuration = 13*13337; // 13337 blocks assuming 13s block times \n    uint internal nonce = 0;\n    uint[TOKEN_LIMIT] internal indices;\n \n    constructor(address payable _beneficiary) {\n        deployer = payable(msg.sender);\n        beneficiary = _beneficiary;\n    }\n\n    function startSale(uint _price) external {\n        require(msg.sender == deployer || _price != 0, \"Only deployer and price cannot be zero\");\n        price = _price;\n        saleStartTime = block.timestamp;\n        publicSale = true;\n    }\n\n    function isContract(address _addr) internal view returns (bool addressCheck) {\n        uint256 size;\n        assembly { size := extcodesize(_addr) }\n        addressCheck = size > 0;\n    }\n\n    function randomIndex() internal returns (uint) {\n        uint totalSize = TOKEN_LIMIT - numTokens;\n        uint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;\n        uint value = 0;\n        if (indices[index] != 0) {\n            value = indices[index];\n        } else {\n            value = index;\n        }\n        if (indices[totalSize - 1] == 0) {\n            indices[index] = totalSize - 1;\n        } else {\n            indices[index] = indices[totalSize - 1];\n        }\n        nonce += 1;\n        return (value + 1);\n    }\n\n    // Calculate the mint price\n    function getPrice() public view returns (uint) {\n        require(publicSale, \"Sale not started.\");\n        uint elapsed = block.timestamp - saleStartTime;\n        if (elapsed > saleDuration) {\n            return 0;\n        } else {\n            return ((saleDuration - elapsed) * price) / saleDuration;\n        }\n    }\n    \n    // SALE_LIMIT is 1337 \n    // Rest i.e. (TOKEN_LIMIT - SALE_LIMIT) are reserved for community distribution (not shown)\n    function mint() external payable returns (uint) {\n        require(publicSale, \"Sale not started.\");\n        require(numSales < SALE_LIMIT, \"Sale limit reached.\");\n        numSales++;\n        uint salePrice = getPrice();\n        require((address(this)).balance >= salePrice, \"Insufficient funds to purchase.\");\n        if ((address(this)).balance >= salePrice) {\n            payable(msg.sender).transfer((address(this)).balance - salePrice);\n        }\n        return _mint(msg.sender);\n    }\n\n    // TOKEN_LIMIT is 13337\n    function _mint(address _to) internal returns (uint) {\n        require(numTokens < TOKEN_LIMIT, \"Token limit reached.\");\n        // Lower indexed/numbered NFTs have rare traits and may be considered\n        // as more valuable by buyers => Therefore randomize\n        uint id = randomIndex();\n        if (isContract(_to)) {\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), id, \"\");\n            require(retval == MAGIC_ERC721_RECEIVED);\n        }\n        require(idToOwner[id] == address(0), \"Cannot add, already owned.\");\n        idToOwner[id] = _to;\n        numTokens = numTokens + 1;\n        beneficiary.transfer((address(this)).balance);\n        return id;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Is expected to reduce the mint price over time after sale starts"
      },
      {
        "choice": "B",
        "answer": "Allows free mints after ~13337 blocks from when _startSale()_ is called"
      },
      {
        "choice": "C",
        "answer": "Visibility should be changed to _external_"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B"
    ],
    "race": "RACE-3.md"
  },
  {
    "question": "4] _InSecureumNFT_ contract is",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureumNFT_ contract snippet. This is the same contract snippet you will see for all the 8 questions in this quiz.\n\n_InSecureumNFT_ is a NFT project that aims to distribute CryptoSAFU NFTs to its community where most of them are fairdropped based on past contributions and a few are sold. CryptoSAFUs with lower IDs have more unique traits, may be valued higher and therefore require a random distribution for fairness. Assume that all strictly required ERC721 functionality (not shown) and any other required functionality (not shown) are implemented correctly. Only functionality specific to the sale and minting of NFTs is shown in this contract snippet.\n```\npragma solidity 0.8.0;\n\ninterface ERC721TokenReceiver{function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);}\n\n// Assume that all strictly required ERC721 functionality (not shown) is implemented correctly\n// Assume that any other required functionality (not shown) is implemented correctly\ncontract InSecureumNFT {\n    bytes4 internal constant MAGIC_ERC721_RECEIVED = 0x150b7a02;\n    uint public constant TOKEN_LIMIT = 10; // 10 for testing, 13337 for production\n    uint public constant SALE_LIMIT = 5; // 5 for testing, 1337 for production\n\n    mapping (uint256 => address) internal idToOwner;\n    uint internal numTokens = 0;\n    uint internal numSales = 0;\n    address payable internal deployer;\n    address payable internal beneficiary;\n    bool public publicSale = false;\n    uint private price;\n    uint public saleStartTime;\n    uint public constant saleDuration = 13*13337; // 13337 blocks assuming 13s block times \n    uint internal nonce = 0;\n    uint[TOKEN_LIMIT] internal indices;\n \n    constructor(address payable _beneficiary) {\n        deployer = payable(msg.sender);\n        beneficiary = _beneficiary;\n    }\n\n    function startSale(uint _price) external {\n        require(msg.sender == deployer || _price != 0, \"Only deployer and price cannot be zero\");\n        price = _price;\n        saleStartTime = block.timestamp;\n        publicSale = true;\n    }\n\n    function isContract(address _addr) internal view returns (bool addressCheck) {\n        uint256 size;\n        assembly { size := extcodesize(_addr) }\n        addressCheck = size > 0;\n    }\n\n    function randomIndex() internal returns (uint) {\n        uint totalSize = TOKEN_LIMIT - numTokens;\n        uint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;\n        uint value = 0;\n        if (indices[index] != 0) {\n            value = indices[index];\n        } else {\n            value = index;\n        }\n        if (indices[totalSize - 1] == 0) {\n            indices[index] = totalSize - 1;\n        } else {\n            indices[index] = indices[totalSize - 1];\n        }\n        nonce += 1;\n        return (value + 1);\n    }\n\n    // Calculate the mint price\n    function getPrice() public view returns (uint) {\n        require(publicSale, \"Sale not started.\");\n        uint elapsed = block.timestamp - saleStartTime;\n        if (elapsed > saleDuration) {\n            return 0;\n        } else {\n            return ((saleDuration - elapsed) * price) / saleDuration;\n        }\n    }\n    \n    // SALE_LIMIT is 1337 \n    // Rest i.e. (TOKEN_LIMIT - SALE_LIMIT) are reserved for community distribution (not shown)\n    function mint() external payable returns (uint) {\n        require(publicSale, \"Sale not started.\");\n        require(numSales < SALE_LIMIT, \"Sale limit reached.\");\n        numSales++;\n        uint salePrice = getPrice();\n        require((address(this)).balance >= salePrice, \"Insufficient funds to purchase.\");\n        if ((address(this)).balance >= salePrice) {\n            payable(msg.sender).transfer((address(this)).balance - salePrice);\n        }\n        return _mint(msg.sender);\n    }\n\n    // TOKEN_LIMIT is 13337\n    function _mint(address _to) internal returns (uint) {\n        require(numTokens < TOKEN_LIMIT, \"Token limit reached.\");\n        // Lower indexed/numbered NFTs have rare traits and may be considered\n        // as more valuable by buyers => Therefore randomize\n        uint id = randomIndex();\n        if (isContract(_to)) {\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), id, \"\");\n            require(retval == MAGIC_ERC721_RECEIVED);\n        }\n        require(idToOwner[id] == address(0), \"Cannot add, already owned.\");\n        idToOwner[id] = _to;\n        numTokens = numTokens + 1;\n        beneficiary.transfer((address(this)).balance);\n        return id;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Not susceptible to reentrancy given the absence of external contract calls"
      },
      {
        "choice": "B",
        "answer": "Not susceptible to integer overflow/wrapping given the compiler version used and the absence of unchecked blocks"
      },
      {
        "choice": "C",
        "answer": "Susceptible to reentrancy during minting"
      },
      {
        "choice": "D",
        "answer": "Perfectly safe for production \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C"
    ],
    "race": "RACE-3.md"
  },
  {
    "question": "5] Assuming _InSecureumNFT_ contract is deployed in production (i.e. live for users) on mainnet without any changes to shown code",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureumNFT_ contract snippet. This is the same contract snippet you will see for all the 8 questions in this quiz.\n\n_InSecureumNFT_ is a NFT project that aims to distribute CryptoSAFU NFTs to its community where most of them are fairdropped based on past contributions and a few are sold. CryptoSAFUs with lower IDs have more unique traits, may be valued higher and therefore require a random distribution for fairness. Assume that all strictly required ERC721 functionality (not shown) and any other required functionality (not shown) are implemented correctly. Only functionality specific to the sale and minting of NFTs is shown in this contract snippet.\n```\npragma solidity 0.8.0;\n\ninterface ERC721TokenReceiver{function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);}\n\n// Assume that all strictly required ERC721 functionality (not shown) is implemented correctly\n// Assume that any other required functionality (not shown) is implemented correctly\ncontract InSecureumNFT {\n    bytes4 internal constant MAGIC_ERC721_RECEIVED = 0x150b7a02;\n    uint public constant TOKEN_LIMIT = 10; // 10 for testing, 13337 for production\n    uint public constant SALE_LIMIT = 5; // 5 for testing, 1337 for production\n\n    mapping (uint256 => address) internal idToOwner;\n    uint internal numTokens = 0;\n    uint internal numSales = 0;\n    address payable internal deployer;\n    address payable internal beneficiary;\n    bool public publicSale = false;\n    uint private price;\n    uint public saleStartTime;\n    uint public constant saleDuration = 13*13337; // 13337 blocks assuming 13s block times \n    uint internal nonce = 0;\n    uint[TOKEN_LIMIT] internal indices;\n \n    constructor(address payable _beneficiary) {\n        deployer = payable(msg.sender);\n        beneficiary = _beneficiary;\n    }\n\n    function startSale(uint _price) external {\n        require(msg.sender == deployer || _price != 0, \"Only deployer and price cannot be zero\");\n        price = _price;\n        saleStartTime = block.timestamp;\n        publicSale = true;\n    }\n\n    function isContract(address _addr) internal view returns (bool addressCheck) {\n        uint256 size;\n        assembly { size := extcodesize(_addr) }\n        addressCheck = size > 0;\n    }\n\n    function randomIndex() internal returns (uint) {\n        uint totalSize = TOKEN_LIMIT - numTokens;\n        uint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;\n        uint value = 0;\n        if (indices[index] != 0) {\n            value = indices[index];\n        } else {\n            value = index;\n        }\n        if (indices[totalSize - 1] == 0) {\n            indices[index] = totalSize - 1;\n        } else {\n            indices[index] = indices[totalSize - 1];\n        }\n        nonce += 1;\n        return (value + 1);\n    }\n\n    // Calculate the mint price\n    function getPrice() public view returns (uint) {\n        require(publicSale, \"Sale not started.\");\n        uint elapsed = block.timestamp - saleStartTime;\n        if (elapsed > saleDuration) {\n            return 0;\n        } else {\n            return ((saleDuration - elapsed) * price) / saleDuration;\n        }\n    }\n    \n    // SALE_LIMIT is 1337 \n    // Rest i.e. (TOKEN_LIMIT - SALE_LIMIT) are reserved for community distribution (not shown)\n    function mint() external payable returns (uint) {\n        require(publicSale, \"Sale not started.\");\n        require(numSales < SALE_LIMIT, \"Sale limit reached.\");\n        numSales++;\n        uint salePrice = getPrice();\n        require((address(this)).balance >= salePrice, \"Insufficient funds to purchase.\");\n        if ((address(this)).balance >= salePrice) {\n            payable(msg.sender).transfer((address(this)).balance - salePrice);\n        }\n        return _mint(msg.sender);\n    }\n\n    // TOKEN_LIMIT is 13337\n    function _mint(address _to) internal returns (uint) {\n        require(numTokens < TOKEN_LIMIT, \"Token limit reached.\");\n        // Lower indexed/numbered NFTs have rare traits and may be considered\n        // as more valuable by buyers => Therefore randomize\n        uint id = randomIndex();\n        if (isContract(_to)) {\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), id, \"\");\n            require(retval == MAGIC_ERC721_RECEIVED);\n        }\n        require(idToOwner[id] == address(0), \"Cannot add, already owned.\");\n        idToOwner[id] = _to;\n        numTokens = numTokens + 1;\n        beneficiary.transfer((address(this)).balance);\n        return id;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Use of evident test configuration will cause fewer NFTs to be minted than expected in production"
      },
      {
        "choice": "B",
        "answer": "Illustrates the lack of best-practice for test parameterization to be removed or kept separate from production code"
      },
      {
        "choice": "C",
        "answer": "It will behave as documented in code to mint the expected number of NFTs in production"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B"
    ],
    "race": "RACE-3.md"
  },
  {
    "question": "6] The function _startSale()_",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureumNFT_ contract snippet. This is the same contract snippet you will see for all the 8 questions in this quiz.\n\n_InSecureumNFT_ is a NFT project that aims to distribute CryptoSAFU NFTs to its community where most of them are fairdropped based on past contributions and a few are sold. CryptoSAFUs with lower IDs have more unique traits, may be valued higher and therefore require a random distribution for fairness. Assume that all strictly required ERC721 functionality (not shown) and any other required functionality (not shown) are implemented correctly. Only functionality specific to the sale and minting of NFTs is shown in this contract snippet.\n```\npragma solidity 0.8.0;\n\ninterface ERC721TokenReceiver{function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);}\n\n// Assume that all strictly required ERC721 functionality (not shown) is implemented correctly\n// Assume that any other required functionality (not shown) is implemented correctly\ncontract InSecureumNFT {\n    bytes4 internal constant MAGIC_ERC721_RECEIVED = 0x150b7a02;\n    uint public constant TOKEN_LIMIT = 10; // 10 for testing, 13337 for production\n    uint public constant SALE_LIMIT = 5; // 5 for testing, 1337 for production\n\n    mapping (uint256 => address) internal idToOwner;\n    uint internal numTokens = 0;\n    uint internal numSales = 0;\n    address payable internal deployer;\n    address payable internal beneficiary;\n    bool public publicSale = false;\n    uint private price;\n    uint public saleStartTime;\n    uint public constant saleDuration = 13*13337; // 13337 blocks assuming 13s block times \n    uint internal nonce = 0;\n    uint[TOKEN_LIMIT] internal indices;\n \n    constructor(address payable _beneficiary) {\n        deployer = payable(msg.sender);\n        beneficiary = _beneficiary;\n    }\n\n    function startSale(uint _price) external {\n        require(msg.sender == deployer || _price != 0, \"Only deployer and price cannot be zero\");\n        price = _price;\n        saleStartTime = block.timestamp;\n        publicSale = true;\n    }\n\n    function isContract(address _addr) internal view returns (bool addressCheck) {\n        uint256 size;\n        assembly { size := extcodesize(_addr) }\n        addressCheck = size > 0;\n    }\n\n    function randomIndex() internal returns (uint) {\n        uint totalSize = TOKEN_LIMIT - numTokens;\n        uint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;\n        uint value = 0;\n        if (indices[index] != 0) {\n            value = indices[index];\n        } else {\n            value = index;\n        }\n        if (indices[totalSize - 1] == 0) {\n            indices[index] = totalSize - 1;\n        } else {\n            indices[index] = indices[totalSize - 1];\n        }\n        nonce += 1;\n        return (value + 1);\n    }\n\n    // Calculate the mint price\n    function getPrice() public view returns (uint) {\n        require(publicSale, \"Sale not started.\");\n        uint elapsed = block.timestamp - saleStartTime;\n        if (elapsed > saleDuration) {\n            return 0;\n        } else {\n            return ((saleDuration - elapsed) * price) / saleDuration;\n        }\n    }\n    \n    // SALE_LIMIT is 1337 \n    // Rest i.e. (TOKEN_LIMIT - SALE_LIMIT) are reserved for community distribution (not shown)\n    function mint() external payable returns (uint) {\n        require(publicSale, \"Sale not started.\");\n        require(numSales < SALE_LIMIT, \"Sale limit reached.\");\n        numSales++;\n        uint salePrice = getPrice();\n        require((address(this)).balance >= salePrice, \"Insufficient funds to purchase.\");\n        if ((address(this)).balance >= salePrice) {\n            payable(msg.sender).transfer((address(this)).balance - salePrice);\n        }\n        return _mint(msg.sender);\n    }\n\n    // TOKEN_LIMIT is 13337\n    function _mint(address _to) internal returns (uint) {\n        require(numTokens < TOKEN_LIMIT, \"Token limit reached.\");\n        // Lower indexed/numbered NFTs have rare traits and may be considered\n        // as more valuable by buyers => Therefore randomize\n        uint id = randomIndex();\n        if (isContract(_to)) {\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), id, \"\");\n            require(retval == MAGIC_ERC721_RECEIVED);\n        }\n        require(idToOwner[id] == address(0), \"Cannot add, already owned.\");\n        idToOwner[id] = _to;\n        numTokens = numTokens + 1;\n        beneficiary.transfer((address(this)).balance);\n        return id;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "May be successfully called/executed by anyone"
      },
      {
        "choice": "B",
        "answer": "May be successfully called/executed with `_price` of 0"
      },
      {
        "choice": "C",
        "answer": "Must be called for minting to happen successfully"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C"
    ],
    "race": "RACE-3.md"
  },
  {
    "question": "7] The minting of NFTs",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureumNFT_ contract snippet. This is the same contract snippet you will see for all the 8 questions in this quiz.\n\n_InSecureumNFT_ is a NFT project that aims to distribute CryptoSAFU NFTs to its community where most of them are fairdropped based on past contributions and a few are sold. CryptoSAFUs with lower IDs have more unique traits, may be valued higher and therefore require a random distribution for fairness. Assume that all strictly required ERC721 functionality (not shown) and any other required functionality (not shown) are implemented correctly. Only functionality specific to the sale and minting of NFTs is shown in this contract snippet.\n```\npragma solidity 0.8.0;\n\ninterface ERC721TokenReceiver{function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);}\n\n// Assume that all strictly required ERC721 functionality (not shown) is implemented correctly\n// Assume that any other required functionality (not shown) is implemented correctly\ncontract InSecureumNFT {\n    bytes4 internal constant MAGIC_ERC721_RECEIVED = 0x150b7a02;\n    uint public constant TOKEN_LIMIT = 10; // 10 for testing, 13337 for production\n    uint public constant SALE_LIMIT = 5; // 5 for testing, 1337 for production\n\n    mapping (uint256 => address) internal idToOwner;\n    uint internal numTokens = 0;\n    uint internal numSales = 0;\n    address payable internal deployer;\n    address payable internal beneficiary;\n    bool public publicSale = false;\n    uint private price;\n    uint public saleStartTime;\n    uint public constant saleDuration = 13*13337; // 13337 blocks assuming 13s block times \n    uint internal nonce = 0;\n    uint[TOKEN_LIMIT] internal indices;\n \n    constructor(address payable _beneficiary) {\n        deployer = payable(msg.sender);\n        beneficiary = _beneficiary;\n    }\n\n    function startSale(uint _price) external {\n        require(msg.sender == deployer || _price != 0, \"Only deployer and price cannot be zero\");\n        price = _price;\n        saleStartTime = block.timestamp;\n        publicSale = true;\n    }\n\n    function isContract(address _addr) internal view returns (bool addressCheck) {\n        uint256 size;\n        assembly { size := extcodesize(_addr) }\n        addressCheck = size > 0;\n    }\n\n    function randomIndex() internal returns (uint) {\n        uint totalSize = TOKEN_LIMIT - numTokens;\n        uint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;\n        uint value = 0;\n        if (indices[index] != 0) {\n            value = indices[index];\n        } else {\n            value = index;\n        }\n        if (indices[totalSize - 1] == 0) {\n            indices[index] = totalSize - 1;\n        } else {\n            indices[index] = indices[totalSize - 1];\n        }\n        nonce += 1;\n        return (value + 1);\n    }\n\n    // Calculate the mint price\n    function getPrice() public view returns (uint) {\n        require(publicSale, \"Sale not started.\");\n        uint elapsed = block.timestamp - saleStartTime;\n        if (elapsed > saleDuration) {\n            return 0;\n        } else {\n            return ((saleDuration - elapsed) * price) / saleDuration;\n        }\n    }\n    \n    // SALE_LIMIT is 1337 \n    // Rest i.e. (TOKEN_LIMIT - SALE_LIMIT) are reserved for community distribution (not shown)\n    function mint() external payable returns (uint) {\n        require(publicSale, \"Sale not started.\");\n        require(numSales < SALE_LIMIT, \"Sale limit reached.\");\n        numSales++;\n        uint salePrice = getPrice();\n        require((address(this)).balance >= salePrice, \"Insufficient funds to purchase.\");\n        if ((address(this)).balance >= salePrice) {\n            payable(msg.sender).transfer((address(this)).balance - salePrice);\n        }\n        return _mint(msg.sender);\n    }\n\n    // TOKEN_LIMIT is 13337\n    function _mint(address _to) internal returns (uint) {\n        require(numTokens < TOKEN_LIMIT, \"Token limit reached.\");\n        // Lower indexed/numbered NFTs have rare traits and may be considered\n        // as more valuable by buyers => Therefore randomize\n        uint id = randomIndex();\n        if (isContract(_to)) {\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), id, \"\");\n            require(retval == MAGIC_ERC721_RECEIVED);\n        }\n        require(idToOwner[id] == address(0), \"Cannot add, already owned.\");\n        idToOwner[id] = _to;\n        numTokens = numTokens + 1;\n        beneficiary.transfer((address(this)).balance);\n        return id;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Requires an exact amount of ETH to be paid by the buyer"
      },
      {
        "choice": "B",
        "answer": "Refunds excess ETH paid by buyer back to the buyer"
      },
      {
        "choice": "C",
        "answer": "Transfers the NFT _salePrice_ to the _beneficiary_ address"
      },
      {
        "choice": "D",
        "answer": "May be optimized to prevent any zero ETH transfers in its refund mechanism \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C",
      "D"
    ],
    "race": "RACE-3.md"
  },
  {
    "question": "8] The NFT sale",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureumNFT_ contract snippet. This is the same contract snippet you will see for all the 8 questions in this quiz.\n\n_InSecureumNFT_ is a NFT project that aims to distribute CryptoSAFU NFTs to its community where most of them are fairdropped based on past contributions and a few are sold. CryptoSAFUs with lower IDs have more unique traits, may be valued higher and therefore require a random distribution for fairness. Assume that all strictly required ERC721 functionality (not shown) and any other required functionality (not shown) are implemented correctly. Only functionality specific to the sale and minting of NFTs is shown in this contract snippet.\n```\npragma solidity 0.8.0;\n\ninterface ERC721TokenReceiver{function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);}\n\n// Assume that all strictly required ERC721 functionality (not shown) is implemented correctly\n// Assume that any other required functionality (not shown) is implemented correctly\ncontract InSecureumNFT {\n    bytes4 internal constant MAGIC_ERC721_RECEIVED = 0x150b7a02;\n    uint public constant TOKEN_LIMIT = 10; // 10 for testing, 13337 for production\n    uint public constant SALE_LIMIT = 5; // 5 for testing, 1337 for production\n\n    mapping (uint256 => address) internal idToOwner;\n    uint internal numTokens = 0;\n    uint internal numSales = 0;\n    address payable internal deployer;\n    address payable internal beneficiary;\n    bool public publicSale = false;\n    uint private price;\n    uint public saleStartTime;\n    uint public constant saleDuration = 13*13337; // 13337 blocks assuming 13s block times \n    uint internal nonce = 0;\n    uint[TOKEN_LIMIT] internal indices;\n \n    constructor(address payable _beneficiary) {\n        deployer = payable(msg.sender);\n        beneficiary = _beneficiary;\n    }\n\n    function startSale(uint _price) external {\n        require(msg.sender == deployer || _price != 0, \"Only deployer and price cannot be zero\");\n        price = _price;\n        saleStartTime = block.timestamp;\n        publicSale = true;\n    }\n\n    function isContract(address _addr) internal view returns (bool addressCheck) {\n        uint256 size;\n        assembly { size := extcodesize(_addr) }\n        addressCheck = size > 0;\n    }\n\n    function randomIndex() internal returns (uint) {\n        uint totalSize = TOKEN_LIMIT - numTokens;\n        uint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;\n        uint value = 0;\n        if (indices[index] != 0) {\n            value = indices[index];\n        } else {\n            value = index;\n        }\n        if (indices[totalSize - 1] == 0) {\n            indices[index] = totalSize - 1;\n        } else {\n            indices[index] = indices[totalSize - 1];\n        }\n        nonce += 1;\n        return (value + 1);\n    }\n\n    // Calculate the mint price\n    function getPrice() public view returns (uint) {\n        require(publicSale, \"Sale not started.\");\n        uint elapsed = block.timestamp - saleStartTime;\n        if (elapsed > saleDuration) {\n            return 0;\n        } else {\n            return ((saleDuration - elapsed) * price) / saleDuration;\n        }\n    }\n    \n    // SALE_LIMIT is 1337 \n    // Rest i.e. (TOKEN_LIMIT - SALE_LIMIT) are reserved for community distribution (not shown)\n    function mint() external payable returns (uint) {\n        require(publicSale, \"Sale not started.\");\n        require(numSales < SALE_LIMIT, \"Sale limit reached.\");\n        numSales++;\n        uint salePrice = getPrice();\n        require((address(this)).balance >= salePrice, \"Insufficient funds to purchase.\");\n        if ((address(this)).balance >= salePrice) {\n            payable(msg.sender).transfer((address(this)).balance - salePrice);\n        }\n        return _mint(msg.sender);\n    }\n\n    // TOKEN_LIMIT is 13337\n    function _mint(address _to) internal returns (uint) {\n        require(numTokens < TOKEN_LIMIT, \"Token limit reached.\");\n        // Lower indexed/numbered NFTs have rare traits and may be considered\n        // as more valuable by buyers => Therefore randomize\n        uint id = randomIndex();\n        if (isContract(_to)) {\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), id, \"\");\n            require(retval == MAGIC_ERC721_RECEIVED);\n        }\n        require(idToOwner[id] == address(0), \"Cannot add, already owned.\");\n        idToOwner[id] = _to;\n        numTokens = numTokens + 1;\n        beneficiary.transfer((address(this)).balance);\n        return id;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "May be restarted by anyone any number of times"
      },
      {
        "choice": "B",
        "answer": "Can be started exactly once by _deployer_"
      },
      {
        "choice": "C",
        "answer": "Is missing an additional check on _publicSale_"
      },
      {
        "choice": "D",
        "answer": "Is missing an event emit in _startSale_ \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "C",
      "D"
    ],
    "race": "RACE-3.md"
  },
  {
    "question": "1] _InSecureum_ implements",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureum_ contract. This is the same contract you will see for all the 8 questions in this quiz. _InSecureum_ is adapted from a widely used ERC20 contract. The question is below the shown contract.\n\n```\npragma solidity 0.8.10;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\";\n\ncontract InSecureum is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 8;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][sender];\n        if (currentAllowance != type(uint256).max) {\n            unchecked {\n                _approve(sender, _msgSender(), currentAllowance - amount);\n            }\n        }\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance > subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        return true;\n    }\nfunction _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) external virtual {\n        _totalSupply += amount;\n        _balances[account] = amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        require(_balances[account] >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = _balances[account] - amount;\n        }\n        _totalSupply -= amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(spender != address(0), \"ERC20: approve from the zero address\");\n        require(owner != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] += amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Atypical decimals value"
      },
      {
        "choice": "B",
        "answer": "Non-standard _decreaseAllowance_ and _increaseAllowance_"
      },
      {
        "choice": "C",
        "answer": "Non-standard _transfer_"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B"
    ],
    "race": "RACE-4.md"
  },
  {
    "question": "2] In _InSecureum_",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureum_ contract. This is the same contract you will see for all the 8 questions in this quiz. _InSecureum_ is adapted from a widely used ERC20 contract. The question is below the shown contract.\n\n```\npragma solidity 0.8.10;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\";\n\ncontract InSecureum is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 8;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][sender];\n        if (currentAllowance != type(uint256).max) {\n            unchecked {\n                _approve(sender, _msgSender(), currentAllowance - amount);\n            }\n        }\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance > subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        return true;\n    }\nfunction _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) external virtual {\n        _totalSupply += amount;\n        _balances[account] = amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        require(_balances[account] >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = _balances[account] - amount;\n        }\n        _totalSupply -= amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(spender != address(0), \"ERC20: approve from the zero address\");\n        require(owner != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] += amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "`_decimals()` can have _pure_ state mutability instead of _view_"
      },
      {
        "choice": "B",
        "answer": "`_burn()` can have _external_ visibility instead of _internal_"
      },
      {
        "choice": "C",
        "answer": "`_mint()` should have _internal_ visibility instead of _external_"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "C"
    ],
    "race": "RACE-4.md"
  },
  {
    "question": "3] _InSecureum_ _transferFrom()_",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureum_ contract. This is the same contract you will see for all the 8 questions in this quiz. _InSecureum_ is adapted from a widely used ERC20 contract. The question is below the shown contract.\n\n```\npragma solidity 0.8.10;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\";\n\ncontract InSecureum is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 8;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][sender];\n        if (currentAllowance != type(uint256).max) {\n            unchecked {\n                _approve(sender, _msgSender(), currentAllowance - amount);\n            }\n        }\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance > subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        return true;\n    }\nfunction _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) external virtual {\n        _totalSupply += amount;\n        _balances[account] = amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        require(_balances[account] >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = _balances[account] - amount;\n        }\n        _totalSupply -= amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(spender != address(0), \"ERC20: approve from the zero address\");\n        require(owner != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] += amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Is susceptible to an integer underflow"
      },
      {
        "choice": "B",
        "answer": "Has an incorrect allowance check"
      },
      {
        "choice": "C",
        "answer": "Has an optimisation indicative of unlimited approvals"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C"
    ],
    "race": "RACE-4.md"
  },
  {
    "question": "4] In _InSecureum_",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureum_ contract. This is the same contract you will see for all the 8 questions in this quiz. _InSecureum_ is adapted from a widely used ERC20 contract. The question is below the shown contract.\n\n```\npragma solidity 0.8.10;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\";\n\ncontract InSecureum is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 8;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][sender];\n        if (currentAllowance != type(uint256).max) {\n            unchecked {\n                _approve(sender, _msgSender(), currentAllowance - amount);\n            }\n        }\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance > subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        return true;\n    }\nfunction _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) external virtual {\n        _totalSupply += amount;\n        _balances[account] = amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        require(_balances[account] >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = _balances[account] - amount;\n        }\n        _totalSupply -= amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(spender != address(0), \"ERC20: approve from the zero address\");\n        require(owner != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] += amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "_increaseAllowance_ is susceptible to an integer overflow"
      },
      {
        "choice": "B",
        "answer": "_decreaseAllowance_ is susceptible to an integer overflow"
      },
      {
        "choice": "C",
        "answer": "_decreaseAllowance_ does not allow reducing allowance to zero"
      },
      {
        "choice": "D",
        "answer": "_decreaseAllowance_ can be optimised with `unchecked{}` \n \n \n"
      }
    ],
    "correctAnswers": [
      "C",
      "D"
    ],
    "race": "RACE-4.md"
  },
  {
    "question": "5] _InSecureum_ `_transfer()`",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureum_ contract. This is the same contract you will see for all the 8 questions in this quiz. _InSecureum_ is adapted from a widely used ERC20 contract. The question is below the shown contract.\n\n```\npragma solidity 0.8.10;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\";\n\ncontract InSecureum is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 8;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][sender];\n        if (currentAllowance != type(uint256).max) {\n            unchecked {\n                _approve(sender, _msgSender(), currentAllowance - amount);\n            }\n        }\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance > subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        return true;\n    }\nfunction _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) external virtual {\n        _totalSupply += amount;\n        _balances[account] = amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        require(_balances[account] >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = _balances[account] - amount;\n        }\n        _totalSupply -= amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(spender != address(0), \"ERC20: approve from the zero address\");\n        require(owner != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] += amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Is missing a zero-address validation"
      },
      {
        "choice": "B",
        "answer": "Is susceptible to an integer overflow"
      },
      {
        "choice": "C",
        "answer": "Is susceptible to an integer underflow"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-4.md"
  },
  {
    "question": "6] _InSecureum_ `_mint()`",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureum_ contract. This is the same contract you will see for all the 8 questions in this quiz. _InSecureum_ is adapted from a widely used ERC20 contract. The question is below the shown contract.\n\n```\npragma solidity 0.8.10;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\";\n\ncontract InSecureum is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 8;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][sender];\n        if (currentAllowance != type(uint256).max) {\n            unchecked {\n                _approve(sender, _msgSender(), currentAllowance - amount);\n            }\n        }\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance > subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        return true;\n    }\nfunction _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) external virtual {\n        _totalSupply += amount;\n        _balances[account] = amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        require(_balances[account] >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = _balances[account] - amount;\n        }\n        _totalSupply -= amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(spender != address(0), \"ERC20: approve from the zero address\");\n        require(owner != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] += amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Is missing a zero-address validation"
      },
      {
        "choice": "B",
        "answer": "Has an incorrect event emission"
      },
      {
        "choice": "C",
        "answer": "Has an incorrect update of account balance"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "C"
    ],
    "race": "RACE-4.md"
  },
  {
    "question": "7] _InSecureum_ `_burn()`",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureum_ contract. This is the same contract you will see for all the 8 questions in this quiz. _InSecureum_ is adapted from a widely used ERC20 contract. The question is below the shown contract.\n\n```\npragma solidity 0.8.10;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\";\n\ncontract InSecureum is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 8;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][sender];\n        if (currentAllowance != type(uint256).max) {\n            unchecked {\n                _approve(sender, _msgSender(), currentAllowance - amount);\n            }\n        }\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance > subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        return true;\n    }\nfunction _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) external virtual {\n        _totalSupply += amount;\n        _balances[account] = amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        require(_balances[account] >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = _balances[account] - amount;\n        }\n        _totalSupply -= amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(spender != address(0), \"ERC20: approve from the zero address\");\n        require(owner != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] += amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Is missing a zero-address validation"
      },
      {
        "choice": "B",
        "answer": "Has an incorrect event emission"
      },
      {
        "choice": "C",
        "answer": "Has an incorrect update of account balance"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-4.md"
  },
  {
    "question": "8] _InSecureum_ `_approve()`",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureum_ contract. This is the same contract you will see for all the 8 questions in this quiz. _InSecureum_ is adapted from a widely used ERC20 contract. The question is below the shown contract.\n\n```\npragma solidity 0.8.10;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\";\n\ncontract InSecureum is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 8;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][sender];\n        if (currentAllowance != type(uint256).max) {\n            unchecked {\n                _approve(sender, _msgSender(), currentAllowance - amount);\n            }\n        }\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance > subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        return true;\n    }\nfunction _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) external virtual {\n        _totalSupply += amount;\n        _balances[account] = amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        require(_balances[account] >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = _balances[account] - amount;\n        }\n        _totalSupply -= amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(spender != address(0), \"ERC20: approve from the zero address\");\n        require(owner != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] += amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Is missing a zero-address validation"
      },
      {
        "choice": "B",
        "answer": "Has incorrect error messages"
      },
      {
        "choice": "C",
        "answer": "Has an incorrect update of allowance"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C"
    ],
    "race": "RACE-4.md"
  },
  {
    "question": "1] _InSecureum_ _balanceOf()_",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureum_ contract. This is the same contract you will see for all the 8 questions in this quiz. _InSecureum_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity ^0.8.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/IERC1155.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165.sol\";\n\n\ncontract InSecureum is Context, ERC165, IERC1155, IERC1155MetadataURI {\n\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    string private _uri;\n\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public view virtual override returns (uint256[] memory) {\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n        return batchBalances;\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        address operator = _msgSender();\n        uint256 fromBalance = _balances[id][from];\n        unchecked {\n             fromBalance = fromBalance - amount;\n        }\n        _balances[id][from] = fromBalance;\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, from, to, id, amount);\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        address operator = _msgSender();\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n            uint256 fromBalance = _balances[id][from];\n            fromBalance = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n        emit TransferBatch(operator, from, to, ids, amounts);\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        address operator = _msgSender();\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        address operator = _msgSender();\n        require(operator != address(0), \"ERC1155: mint from the zero address\");\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n        emit TransferBatch(operator, address(0), to, amounts, ids);\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        address operator = _msgSender();\n        uint256 fromBalance = _balances[id][from];\n        _balances[id][from] = fromBalance - amount;\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        address operator = _msgSender();\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n \n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (isContract(to)) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response == IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (isContract(to)) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length == 0;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "May be optimised by caching state variable in local variable"
      },
      {
        "choice": "B",
        "answer": "May be optimised by changing state mutability from _view_ to _pure_"
      },
      {
        "choice": "C",
        "answer": "May be optimised by changing its visibility to _external_"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-5.md"
  },
  {
    "question": "2] In _InSecureum_, array lengths mismatch check is missing in",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureum_ contract. This is the same contract you will see for all the 8 questions in this quiz. _InSecureum_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity ^0.8.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/IERC1155.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165.sol\";\n\n\ncontract InSecureum is Context, ERC165, IERC1155, IERC1155MetadataURI {\n\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    string private _uri;\n\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public view virtual override returns (uint256[] memory) {\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n        return batchBalances;\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        address operator = _msgSender();\n        uint256 fromBalance = _balances[id][from];\n        unchecked {\n             fromBalance = fromBalance - amount;\n        }\n        _balances[id][from] = fromBalance;\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, from, to, id, amount);\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        address operator = _msgSender();\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n            uint256 fromBalance = _balances[id][from];\n            fromBalance = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n        emit TransferBatch(operator, from, to, ids, amounts);\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        address operator = _msgSender();\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        address operator = _msgSender();\n        require(operator != address(0), \"ERC1155: mint from the zero address\");\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n        emit TransferBatch(operator, address(0), to, amounts, ids);\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        address operator = _msgSender();\n        uint256 fromBalance = _balances[id][from];\n        _balances[id][from] = fromBalance - amount;\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        address operator = _msgSender();\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n \n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (isContract(to)) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response == IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (isContract(to)) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length == 0;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "_balanceOfBatch()_"
      },
      {
        "choice": "B",
        "answer": "`_safeBatchTransferFrom()`"
      },
      {
        "choice": "C",
        "answer": "`_mintBatch()`"
      },
      {
        "choice": "D",
        "answer": "`_burnBatch()` \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C",
      "D"
    ],
    "race": "RACE-5.md"
  },
  {
    "question": "3] The security concern(s) with _InSecureum_ `_safeTransferFrom()` is/are",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureum_ contract. This is the same contract you will see for all the 8 questions in this quiz. _InSecureum_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity ^0.8.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/IERC1155.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165.sol\";\n\n\ncontract InSecureum is Context, ERC165, IERC1155, IERC1155MetadataURI {\n\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    string private _uri;\n\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public view virtual override returns (uint256[] memory) {\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n        return batchBalances;\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        address operator = _msgSender();\n        uint256 fromBalance = _balances[id][from];\n        unchecked {\n             fromBalance = fromBalance - amount;\n        }\n        _balances[id][from] = fromBalance;\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, from, to, id, amount);\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        address operator = _msgSender();\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n            uint256 fromBalance = _balances[id][from];\n            fromBalance = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n        emit TransferBatch(operator, from, to, ids, amounts);\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        address operator = _msgSender();\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        address operator = _msgSender();\n        require(operator != address(0), \"ERC1155: mint from the zero address\");\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n        emit TransferBatch(operator, address(0), to, amounts, ids);\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        address operator = _msgSender();\n        uint256 fromBalance = _balances[id][from];\n        _balances[id][from] = fromBalance - amount;\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        address operator = _msgSender();\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n \n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (isContract(to)) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response == IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (isContract(to)) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length == 0;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Incorrect visibility"
      },
      {
        "choice": "B",
        "answer": "Susceptibility to an integer underflow"
      },
      {
        "choice": "C",
        "answer": "Missing zero-address validation"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C"
    ],
    "race": "RACE-5.md"
  },
  {
    "question": "4] The security concern(s) with _InSecureum_ `_safeBatchTransferFrom()` is/are",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureum_ contract. This is the same contract you will see for all the 8 questions in this quiz. _InSecureum_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity ^0.8.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/IERC1155.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165.sol\";\n\n\ncontract InSecureum is Context, ERC165, IERC1155, IERC1155MetadataURI {\n\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    string private _uri;\n\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public view virtual override returns (uint256[] memory) {\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n        return batchBalances;\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        address operator = _msgSender();\n        uint256 fromBalance = _balances[id][from];\n        unchecked {\n             fromBalance = fromBalance - amount;\n        }\n        _balances[id][from] = fromBalance;\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, from, to, id, amount);\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        address operator = _msgSender();\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n            uint256 fromBalance = _balances[id][from];\n            fromBalance = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n        emit TransferBatch(operator, from, to, ids, amounts);\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        address operator = _msgSender();\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        address operator = _msgSender();\n        require(operator != address(0), \"ERC1155: mint from the zero address\");\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n        emit TransferBatch(operator, address(0), to, amounts, ids);\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        address operator = _msgSender();\n        uint256 fromBalance = _balances[id][from];\n        _balances[id][from] = fromBalance - amount;\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        address operator = _msgSender();\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n \n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (isContract(to)) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response == IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (isContract(to)) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length == 0;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Missing array lengths mismatch check"
      },
      {
        "choice": "B",
        "answer": "Susceptibility to an integer underflow"
      },
      {
        "choice": "C",
        "answer": "Incorrect balance update"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "C"
    ],
    "race": "RACE-5.md"
  },
  {
    "question": "5] The security concern(s) with _InSecureum_ `_mintBatch()` is/are",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureum_ contract. This is the same contract you will see for all the 8 questions in this quiz. _InSecureum_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity ^0.8.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/IERC1155.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165.sol\";\n\n\ncontract InSecureum is Context, ERC165, IERC1155, IERC1155MetadataURI {\n\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    string private _uri;\n\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public view virtual override returns (uint256[] memory) {\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n        return batchBalances;\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        address operator = _msgSender();\n        uint256 fromBalance = _balances[id][from];\n        unchecked {\n             fromBalance = fromBalance - amount;\n        }\n        _balances[id][from] = fromBalance;\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, from, to, id, amount);\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        address operator = _msgSender();\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n            uint256 fromBalance = _balances[id][from];\n            fromBalance = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n        emit TransferBatch(operator, from, to, ids, amounts);\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        address operator = _msgSender();\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        address operator = _msgSender();\n        require(operator != address(0), \"ERC1155: mint from the zero address\");\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n        emit TransferBatch(operator, address(0), to, amounts, ids);\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        address operator = _msgSender();\n        uint256 fromBalance = _balances[id][from];\n        _balances[id][from] = fromBalance - amount;\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        address operator = _msgSender();\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n \n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (isContract(to)) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response == IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (isContract(to)) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length == 0;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Missing array lengths mismatch check"
      },
      {
        "choice": "B",
        "answer": "Incorrect event emission"
      },
      {
        "choice": "C",
        "answer": "Allows burning of tokens"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C"
    ],
    "race": "RACE-5.md"
  },
  {
    "question": "6] The security concern(s) with _InSecureum_ `_burn()` is/are",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureum_ contract. This is the same contract you will see for all the 8 questions in this quiz. _InSecureum_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity ^0.8.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/IERC1155.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165.sol\";\n\n\ncontract InSecureum is Context, ERC165, IERC1155, IERC1155MetadataURI {\n\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    string private _uri;\n\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public view virtual override returns (uint256[] memory) {\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n        return batchBalances;\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        address operator = _msgSender();\n        uint256 fromBalance = _balances[id][from];\n        unchecked {\n             fromBalance = fromBalance - amount;\n        }\n        _balances[id][from] = fromBalance;\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, from, to, id, amount);\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        address operator = _msgSender();\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n            uint256 fromBalance = _balances[id][from];\n            fromBalance = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n        emit TransferBatch(operator, from, to, ids, amounts);\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        address operator = _msgSender();\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        address operator = _msgSender();\n        require(operator != address(0), \"ERC1155: mint from the zero address\");\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n        emit TransferBatch(operator, address(0), to, amounts, ids);\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        address operator = _msgSender();\n        uint256 fromBalance = _balances[id][from];\n        _balances[id][from] = fromBalance - amount;\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        address operator = _msgSender();\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n \n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (isContract(to)) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response == IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (isContract(to)) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length == 0;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Missing zero-address validation"
      },
      {
        "choice": "B",
        "answer": "Susceptibility to an integer underflow"
      },
      {
        "choice": "C",
        "answer": "Incorrect balance update"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-5.md"
  },
  {
    "question": "7] The security concern(s) with _InSecureum_ `_doSafeTransferAcceptanceCheck()` is/are",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureum_ contract. This is the same contract you will see for all the 8 questions in this quiz. _InSecureum_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity ^0.8.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/IERC1155.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165.sol\";\n\n\ncontract InSecureum is Context, ERC165, IERC1155, IERC1155MetadataURI {\n\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    string private _uri;\n\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public view virtual override returns (uint256[] memory) {\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n        return batchBalances;\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        address operator = _msgSender();\n        uint256 fromBalance = _balances[id][from];\n        unchecked {\n             fromBalance = fromBalance - amount;\n        }\n        _balances[id][from] = fromBalance;\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, from, to, id, amount);\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        address operator = _msgSender();\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n            uint256 fromBalance = _balances[id][from];\n            fromBalance = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n        emit TransferBatch(operator, from, to, ids, amounts);\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        address operator = _msgSender();\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        address operator = _msgSender();\n        require(operator != address(0), \"ERC1155: mint from the zero address\");\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n        emit TransferBatch(operator, address(0), to, amounts, ids);\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        address operator = _msgSender();\n        uint256 fromBalance = _balances[id][from];\n        _balances[id][from] = fromBalance - amount;\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        address operator = _msgSender();\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n \n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (isContract(to)) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response == IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (isContract(to)) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length == 0;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "_isContract_ check on incorrect address"
      },
      {
        "choice": "B",
        "answer": "Incorrect check on return value"
      },
      {
        "choice": "C",
        "answer": "Call to incorrect _isContract_ implementation"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C"
    ],
    "race": "RACE-5.md"
  },
  {
    "question": "8] The security concern(s) with _InSecureum_ _isContract()_ implementation is/are",
    "context": "**Note**: All 8 questions in this quiz are based on the _InSecureum_ contract. This is the same contract you will see for all the 8 questions in this quiz. _InSecureum_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity ^0.8.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/IERC1155.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165.sol\";\n\n\ncontract InSecureum is Context, ERC165, IERC1155, IERC1155MetadataURI {\n\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    string private _uri;\n\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public view virtual override returns (uint256[] memory) {\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n        return batchBalances;\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        address operator = _msgSender();\n        uint256 fromBalance = _balances[id][from];\n        unchecked {\n             fromBalance = fromBalance - amount;\n        }\n        _balances[id][from] = fromBalance;\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, from, to, id, amount);\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        address operator = _msgSender();\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n            uint256 fromBalance = _balances[id][from];\n            fromBalance = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n        emit TransferBatch(operator, from, to, ids, amounts);\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        address operator = _msgSender();\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        address operator = _msgSender();\n        require(operator != address(0), \"ERC1155: mint from the zero address\");\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n        emit TransferBatch(operator, address(0), to, amounts, ids);\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        address operator = _msgSender();\n        uint256 fromBalance = _balances[id][from];\n        _balances[id][from] = fromBalance - amount;\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        address operator = _msgSender();\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n \n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (isContract(to)) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response == IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (isContract(to)) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length == 0;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Incorrect visibility"
      },
      {
        "choice": "B",
        "answer": "Incorrect operator in the comparison"
      },
      {
        "choice": "C",
        "answer": "Unnecessary because Ethereum only has Contract accounts"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n ---\n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-5.md"
  },
  {
    "question": "1] The security concern(s) with _InSecureumLand_ is/are",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumLand_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumLand_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n\ncontract InSecureumLand is ERC721Enumerable, Ownable, ReentrancyGuard, VRFConsumerBase {\n   using SafeERC20 for IERC20;\n\n   // attributes\n   string private baseURI;\n   address public operator;\n   bool public publicSaleActive;\n   uint256 public publicSaleStartTime;\n   uint256 public publicSalePriceLoweringDuration;\n   uint256 public publicSaleStartPrice;\n   uint256 public publicSaleEndingPrice;\n   uint256 public currentNumLandsMintedPublicSale;\n   uint256 public mintIndexPublicSaleAndContributors;\n   address public tokenContract;\n   bool private isKycCheckRequired;\n   bytes32 public kycMerkleRoot;\n   uint256 public maxMintPerTx;\n   uint256 public maxMintPerAddress;\n   mapping(address => uint256) public mintedPerAddress;\n   bool public claimableActive;\n   bool public adminClaimStarted;\n   address public alphaContract;\n   mapping(uint256 => bool) public alphaClaimed;\n   uint256 public alphaClaimedAmount;\n   address public betaContract;\n   mapping(uint256 => bool) public betaClaimed;\n   uint256 public betaClaimedAmount;\n   uint256 public betaNftIdCurrent;\n   bool public contributorsClaimActive;\n   mapping(address => uint256) public contributors;\n   uint256 public futureLandsNftIdCurrent;\n   address public futureMinter;\n   Metadata[] public metadataHashes;\n   bytes32 public keyHash;\n   uint256 public fee;\n   uint256 public publicSaleAndContributorsOffset;\n   uint256 public alphaOffset;\n   uint256 public betaOffset;\n   mapping(bytes32 => bool) public isRandomRequestForPublicSaleAndContributors;\n   bool public publicSaleAndContributorsRandomnessRequested;\n   bool public ownerClaimRandomnessRequested;\n   \n   // constants\n   uint256 immutable public MAX_LANDS;\n   uint256 immutable public MAX_LANDS_WITH_FUTURE;\n   uint256 immutable public MAX_ALPHA_NFT_AMOUNT;\n   uint256 immutable public MAX_BETA_NFT_AMOUNT;\n   uint256 immutable public MAX_PUBLIC_SALE_AMOUNT;\n   uint256 immutable public RESERVED_CONTRIBUTORS_AMOUNT;\n   uint256 immutable public MAX_FUTURE_LANDS;\n   uint256 constant public MAX_MINT_PER_BLOCK = 150;\n\n   // structs\n   struct LandAmount {\n       uint256 alpha;\n       uint256 beta;\n       uint256 publicSale;\n       uint256 future;\n   }\n\n   struct ContributorAmount {\n       address contributor;\n       uint256 amount;\n   }\n\n   struct Metadata {\n       bytes32 metadataHash;\n       bytes32 shuffledArrayHash;\n       uint256 startIndex;\n       uint256 endIndex;\n   }\n\n   struct ContractAddresses {\n       address alphaContract;\n       address betaContract;\n       address tokenContract;\n   }\n\n   // modifiers\n   modifier whenPublicSaleActive() {\n       require(publicSaleActive, \"Public sale is not active\");\n       _;\n   }\n\n   modifier whenContributorsClaimActive() {\n       require(contributorsClaimActive, \"Contributors Claim is not active\");\n       _;\n   }\n\n   modifier whenClaimableActive() {\n       require(claimableActive && !adminClaimStarted, \"Claimable state is not active\");\n       _;\n   }\n\n   modifier checkMetadataRange(Metadata memory _landMetadata){\n       require(_landMetadata.endIndex < MAX_LANDS_WITH_FUTURE, \"Range upper bound cannot exceed MAX_LANDS_WITH_FUTURE - 1\");\n       _;\n   }\n\n   modifier onlyContributors(address _contributor){\n       require(contributors[_contributor] >= 0, \"Only contributors can call this method\");\n       _;\n   }\n\n   modifier onlyOperator() {\n       require(operator == msg.sender , \"Only operator can call this method\");\n       _;\n   }\n\n   modifier onlyFutureMinter() {\n       require(futureMinter == msg.sender , \"Only futureMinter can call this method\");\n       _;\n   }\n\n   modifier checkFirstMetadataRange(uint256 index, uint256 startIndex, uint256 endIndex) {\n       if(index == 0){\n           require(startIndex == 0, \"For first metadata range lower bound should be 0\");\n           require(endIndex == MAX_LANDS - 1, \"For first metadata range upper bound should be MAX_LANDS - 1\");\n       }\n       _;\n   }\n\n   // events\n   event LandPublicSaleStart(\n       uint256 indexed _saleDuration,\n       uint256 indexed _saleStartTime\n   );\n   event LandPublicSaleStop(\n       uint256 indexed _currentPrice,\n       uint256 indexed _timeElapsed\n   );\n   event ClaimableStateChanged(bool indexed claimableActive);\n   event ContributorsClaimStart(uint256 _timestamp);\n   event ContributorsClaimStop(uint256 _timestamp);\n   event StartingIndexSetPublicSale(uint256 indexed _startingIndex);\n   event StartingIndexSetAlphaBeta(uint256 indexed _alphaOffset, uint256 indexed _betaOffset);\n   event PublicSaleMint(address indexed sender, uint256 indexed numLands, uint256 indexed mintPrice);\n\n   constructor(string memory name, string memory symbol,\n       ContractAddresses memory addresses,\n       LandAmount memory amount,\n       ContributorAmount[] memory _contributors,\n       address _vrfCoordinator, address _linkTokenAddress,\n       bytes32 _vrfKeyHash, uint256 _vrfFee,\n       address _operator\n   ) ERC721(name, symbol) VRFConsumerBase(_vrfCoordinator, _linkTokenAddress) {\n       alphaContract = addresses.alphaContract;\n       betaContract = addresses.betaContract;\n       tokenContract = addresses.tokenContract;\n\n       MAX_ALPHA_NFT_AMOUNT = amount.alpha;\n       MAX_BETA_NFT_AMOUNT = amount.beta;\n       MAX_PUBLIC_SALE_AMOUNT = amount.publicSale;\n       MAX_FUTURE_LANDS = amount.future;\n\n       betaNftIdCurrent = amount.alpha; //beta starts after alpha\n       mintIndexPublicSaleAndContributors = amount.alpha + amount.beta; //public sale starts after beta\n\n       uint256 tempSum;\n       for(uint256 i; i<_contributors.length; ++i){\n           contributors[_contributors[i].contributor] = _contributors[i].amount;\n           tempSum += _contributors[i].amount;\n       }\n       RESERVED_CONTRIBUTORS_AMOUNT = tempSum;\n       MAX_LANDS = amount.alpha + amount.beta + amount.publicSale + RESERVED_CONTRIBUTORS_AMOUNT;\n       MAX_LANDS_WITH_FUTURE = MAX_LANDS + amount.future;\n       futureLandsNftIdCurrent = MAX_LANDS; //future starts after public sale\n       keyHash  = _vrfKeyHash;\n       fee = _vrfFee;\n       operator = _operator;\n   }\n\n   function _baseURI() internal view override returns (string memory) {\n       return baseURI;\n   }\n\n   function setBaseURI(string memory uri) external onlyOperator {\n       baseURI = uri;\n   }\n\n   function setOperator(address _operator) external onlyOwner {\n       operator = _operator;\n   }\n\n   function setMaxMintPerTx(uint256 _maxMintPerTx) external onlyOperator {\n       maxMintPerTx = _maxMintPerTx;\n   }\n\n   function setMaxMintPerAddress(uint256 _maxMintPerAddress) external onlyOperator {\n       maxMintPerAddress = _maxMintPerAddress;\n   }\n\n   function setKycCheckRequired(bool _isKycCheckRequired) external onlyOperator {\n       isKycCheckRequired = _isKycCheckRequired;\n   }\n\n   function setKycMerkleRoot(bytes32 _kycMerkleRoot) external onlyOperator {\n       kycMerkleRoot = _kycMerkleRoot;\n   }\n\n   // Public Sale Methods\n   function startPublicSale(\n       uint256 _publicSalePriceLoweringDuration,\n       uint256 _publicSaleStartPrice,\n       uint256 _publicSaleEndingPrice,\n       uint256 _maxMintPerTx,\n       uint256 _maxMintPerAddress,\n       bool _isKycCheckRequired\n   ) external onlyOperator {\n       require(!publicSaleActive, \"Public sale has already begun\");\n       \n       publicSalePriceLoweringDuration = _publicSalePriceLoweringDuration;\n       publicSaleStartPrice = _publicSaleStartPrice;\n       publicSaleEndingPrice = _publicSaleEndingPrice;\n       publicSaleStartTime = block.timestamp;\n       publicSaleActive = true;\n\n       maxMintPerTx = _maxMintPerTx;\n       maxMintPerAddress = _maxMintPerAddress;\n       isKycCheckRequired = _isKycCheckRequired;\n       emit LandPublicSaleStart(publicSalePriceLoweringDuration, publicSaleStartTime);\n   }\n\n   function stopPublicSale() external onlyOperator whenPublicSaleActive {\n       emit LandPublicSaleStop(getMintPrice(), getElapsedSaleTime());\n       publicSaleActive = false;\n   }\n\n   function getElapsedSaleTime() private view returns (uint256) {\n       return publicSaleStartTime > 0 ? block.timestamp - publicSaleStartTime : 0;\n   }\n\n   function getMintPrice() public view whenPublicSaleActive returns (uint256) {\n       uint256 elapsed = getElapsedSaleTime();\n       uint256 price;\n       if(elapsed < publicSalePriceLoweringDuration) {\n           // Linear decreasing function\n           price =\n               publicSaleStartPrice -\n                   ( ( publicSaleStartPrice - publicSaleEndingPrice ) * elapsed ) / publicSalePriceLoweringDuration ;\n       } else {\n           price = publicSaleEndingPrice;\n       }\n       return price;\n   }\n\n   function mintLands(uint256 numLands, bytes32[] calldata merkleProof) external whenPublicSaleActive nonReentrant {\n       require(numLands > 0, \"Must mint at least one beta\");\n       require(currentNumLandsMintedPublicSale + numLands <= MAX_PUBLIC_SALE_AMOUNT, \"Minting would exceed max supply\");\n       require(numLands <= maxMintPerTx, \"numLands should not exceed maxMintPerTx\");\n       require(numLands + mintedPerAddress[msg.sender] <= maxMintPerAddress, \"sender address cannot mint more than maxMintPerAddress lands\");\n       if(isKycCheckRequired) {\n           require(MerkleProof.verify(merkleProof, kycMerkleRoot, keccak256(abi.encodePacked(msg.sender))), \"Sender address is not in KYC allowlist\");\n       } else {\n           require(msg.sender == tx.origin, \"Minting from smart contracts is disallowed\");\n       }\n   \n       uint256 mintPrice = getMintPrice();\n       IERC20(tokenContract).safeTransferFrom(msg.sender, address(this), mintPrice * numLands);\n       mintedPerAddress[msg.sender] += numLands;\n       emit PublicSaleMint(msg.sender, numLands, mintPrice);\n       mintLandsCommon(numLands, msg.sender);\n   }\n\n   function mintLandsCommon(uint256 numLands, address recipient) private {\n       for (uint256 i; i < numLands; ++i) {\n           _safeMint(recipient, mintIndexPublicSaleAndContributors++);\n       }\n   }\n\n   function withdraw() external onlyOwner {\n       uint256 balance = address(this).balance;\n       if(balance > 0){\n           Address.sendValue(payable(owner()), balance);\n       }\n       balance = IERC20(tokenContract).balanceOf(address(this));\n       if(balance > 0){\n           IERC20(tokenContract).safeTransfer(owner(), balance);\n       }\n   }\n\n   // Alpha/Beta Claim Methods\n   function flipClaimableState() external onlyOperator {\n       claimableActive = !claimableActive;\n       emit ClaimableStateChanged(claimableActive);\n   }\n\n   function nftOwnerClaimLand(uint256[] calldata alphaTokenIds, uint256[] calldata betaTokenIds) external whenClaimableActive {\n       require(alphaTokenIds.length > 0 || betaTokenIds.length > 0, \"Should claim at least one land\");\n       require(alphaTokenIds.length + betaTokenIds.length <= MAX_MINT_PER_BLOCK, \"Input length should be <= MAX_MINT_PER_BLOCK\");\n\n       alphaClaimLand(alphaTokenIds);\n       betaClaimLand(betaTokenIds);\n   }\n\n   function alphaClaimLand(uint256[] calldata alphaTokenIds) private {\n       for(uint256 i; i < alphaTokenIds.length; ++i){\n           uint256 alphaTokenId = alphaTokenIds[i];\n           require(!alphaClaimed[alphaTokenId], \"ALPHA NFT already claimed\");\n           require(ERC721(alphaContract).ownerOf(alphaTokenId) == msg.sender, \"Must own all of the alpha defined by alphaTokenIds\");\n           \n           alphaClaimLandByTokenId(alphaTokenId);    \n       }\n   }\n\n   function alphaClaimLandByTokenId(uint256 alphaTokenId) private {\n       alphaClaimed[alphaTokenId] = true;\n       ++alphaClaimedAmount;        \n       _safeMint(msg.sender, alphaTokenId);\n   }\n\n   function betaClaimLand(uint256[] calldata betaTokenIds) private {\n       for(uint256 i; i < betaTokenIds.length; ++i){\n           uint256 betaTokenId = betaTokenIds[i];\n           require(!betaClaimed[betaTokenId], \"BETA NFT already claimed\");\n           require(ERC721(betaContract).ownerOf(betaTokenId) == msg.sender, \"Must own all of the beta defined by betaTokenIds\");\n           \n           betaClaimLandByTokenId(betaTokenId);    \n       }\n   }\n\n   function betaClaimLandByTokenId(uint256 betaTokenId) private {\n       betaClaimed[betaTokenId] = true;\n       ++betaClaimedAmount;\n       _safeMint(msg.sender, betaNftIdCurrent++);\n   }\n\n   // Contributors Claim Methods\n   function startContributorsClaimPeriod() onlyOperator external {\n       require(!contributorsClaimActive, \"Contributors claim is already active\");\n       contributorsClaimActive = true;\n       emit ContributorsClaimStart(block.timestamp);\n   }\n\n   function stopContributorsClaimPeriod() onlyOperator external whenContributorsClaimActive {\n       contributorsClaimActive = false;\n       emit ContributorsClaimStop(block.timestamp);\n   }\n\n   function contributorsClaimLand(uint256 amount, address recipient) external onlyContributors(msg.sender) whenContributorsClaimActive {\n       require(amount > 0, \"Must mint at least one land\");\n       require(amount <= MAX_MINT_PER_BLOCK, \"amount should not exceed MAX_MINT_PER_BLOCK\");\n       mintLandsCommon(amount, recipient);\n   }\n\n   function claimUnclaimedAndUnsoldLands(address recipient) external onlyOwner {\n       claimUnclaimedAndUnsoldLandsWithAmount(recipient, MAX_MINT_PER_BLOCK);\n   }\n\n   function claimUnclaimedAndUnsoldLandsWithAmount(address recipient, uint256 maxAmount) public onlyOwner {\n       require (publicSaleStartTime > 0 && !claimableActive && !publicSaleActive && !contributorsClaimActive,\n           \"Cannot claim the unclaimed if claimable or public sale are active\");\n       require(maxAmount <= MAX_MINT_PER_BLOCK, \"maxAmount cannot exceed MAX_MINT_PER_BLOCK\");\n       require(alphaClaimedAmount < MAX_ALPHA_NFT_AMOUNT || betaClaimedAmount < MAX_BETA_NFT_AMOUNT\n                   || mintIndexPublicSaleAndContributors < MAX_LANDS, \"Max NFT amount already claimed or sold\");\n\n       uint256 totalMinted;\n       adminClaimStarted = true;\n       //claim beta\n       if(betaClaimedAmount < MAX_BETA_NFT_AMOUNT) {\n           uint256 leftToBeMinted = MAX_BETA_NFT_AMOUNT - betaClaimedAmount;\n           uint256 toMint = leftToBeMinted < maxAmount ? leftToBeMinted :\n               maxAmount; //take the min\n\n           uint256 target = betaNftIdCurrent + toMint;\n           for(; betaNftIdCurrent < target; ++betaNftIdCurrent){\n               ++betaClaimedAmount;\n               ++totalMinted;\n               _safeMint(recipient, betaNftIdCurrent);\n           }\n       }\n\n       //claim alpha\n       if(alphaClaimedAmount < MAX_ALPHA_NFT_AMOUNT) {\n           uint256 leftToBeMinted = MAX_ALPHA_NFT_AMOUNT - alphaClaimedAmount;\n           uint256 toMint = maxAmount < leftToBeMinted + totalMinted ?\n                           maxAmount :\n                           leftToBeMinted + totalMinted; //summing totalMinted avoid to use another counter\n           \n           uint256 lastAlphaNft = MAX_ALPHA_NFT_AMOUNT - 1;\n           for(uint256 i; i <= lastAlphaNft && totalMinted < toMint; ++i) {\n               if(!alphaClaimed[i]){\n                   ++alphaClaimedAmount;\n                   ++totalMinted;\n                   alphaClaimed[i] = true;\n                   _safeMint(recipient, i);\n               }\n           }\n       }\n\n       //claim unsold\n       if(mintIndexPublicSaleAndContributors < MAX_LANDS){\n           uint256 leftToBeMinted = MAX_LANDS - mintIndexPublicSaleAndContributors;\n           uint256 toMint = maxAmount < leftToBeMinted + totalMinted ?\n                           maxAmount :\n                           leftToBeMinted + totalMinted; //summing totalMinted avoid to use another counter\n\n           for(; mintIndexPublicSaleAndContributors < MAX_LANDS && totalMinted < toMint; ++mintIndexPublicSaleAndContributors) {\n                   ++totalMinted;\n                   _safeMint(recipient, mintIndexPublicSaleAndContributors);\n           }              \n       }\n   }\n\n   //future\n   function setFutureMinter(address _futureMinter) external onlyOwner {\n       futureMinter = _futureMinter;\n   }\n\n   function mintFutureLands(address recipient) external onlyFutureMinter {\n       mintFutureLandsWithAmount(recipient, MAX_MINT_PER_BLOCK);\n   }\n\n   function mintFutureLandsWithAmount(address recipient, uint256 maxAmount) public onlyFutureMinter {\n       require(maxAmount <= MAX_MINT_PER_BLOCK, \"maxAmount cannot exceed MAX_MINT_PER_BLOCK\");    \n       require(futureLandsNftIdCurrent < MAX_LANDS_WITH_FUTURE, \"All future lands were already minted\");\n       for(uint256 claimed; claimed < maxAmount && futureLandsNftIdCurrent < MAX_LANDS_WITH_FUTURE; ++claimed){\n           _safeMint(recipient, futureLandsNftIdCurrent++);\n       }\n   }\n   \n   // metadata\n   function loadLandMetadata(Metadata memory _landMetadata)\n       external onlyOperator checkMetadataRange(_landMetadata)\n       checkFirstMetadataRange(metadataHashes.length, _landMetadata.startIndex, _landMetadata.endIndex)\n   {\n       metadataHashes.push(_landMetadata);\n   }\n\n   function putLandMetadataAtIndex(uint256 index, Metadata memory _landMetadata)\n       external onlyOperator checkMetadataRange(_landMetadata)\n       checkFirstMetadataRange(index, _landMetadata.startIndex, _landMetadata.endIndex)\n   {\n       metadataHashes[index] = _landMetadata;\n   }    \n\n   // randomness\n   function requestRandomnessForPublicSaleAndContributors() external onlyOperator returns (bytes32 requestId) {\n       require(!publicSaleAndContributorsRandomnessRequested, \"Public Sale And Contributors Offset already requested\");\n       publicSaleAndContributorsRandomnessRequested = true;\n       requestId = requestRandomnessPrivate();\n       isRandomRequestForPublicSaleAndContributors[requestId] = true;\n   }\n\n   function requestRandomnessForOwnerClaim() external onlyOperator returns (bytes32 requestId) {\n       require(!ownerClaimRandomnessRequested, \"Owner Claim Offset already requested\");\n       ownerClaimRandomnessRequested = true;\n       requestId = requestRandomnessPrivate();\n       isRandomRequestForPublicSaleAndContributors[requestId] = false;\n   }\n\n   function requestRandomnessPrivate() private returns (bytes32 requestId) {\n       require(\n           LINK.balanceOf(address(this)) >= fee,\n           \"Not enough LINK\"\n       );\n       return requestRandomness(keyHash, fee);\n   }\n\n   function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n       if(isRandomRequestForPublicSaleAndContributors[requestId]){\n           publicSaleAndContributorsOffset = (randomness % (MAX_PUBLIC_SALE_AMOUNT + RESERVED_CONTRIBUTORS_AMOUNT));\n           emit StartingIndexSetPublicSale(publicSaleAndContributorsOffset);\n       } else {\n           alphaOffset = (randomness % MAX_ALPHA_NFT_AMOUNT);\n           betaOffset = (randomness % MAX_BETA_NFT_AMOUNT);\n           emit StartingIndexSetAlphaBeta(alphaOffset, betaOffset);\n       }\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Single-step ownership change"
      },
      {
        "choice": "B",
        "answer": "Incorrectly implemented KYC check using Merkle proofs"
      },
      {
        "choice": "C",
        "answer": "Missing time-delayed change of critical parameters"
      },
      {
        "choice": "D",
        "answer": "Accidentally sent Ether gets locked in contract \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "C"
    ],
    "race": "RACE-6.md"
  },
  {
    "question": "2] The security concern(s) with _InSecureumLand_ _setOperator()_ is/are",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumLand_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumLand_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n\ncontract InSecureumLand is ERC721Enumerable, Ownable, ReentrancyGuard, VRFConsumerBase {\n   using SafeERC20 for IERC20;\n\n   // attributes\n   string private baseURI;\n   address public operator;\n   bool public publicSaleActive;\n   uint256 public publicSaleStartTime;\n   uint256 public publicSalePriceLoweringDuration;\n   uint256 public publicSaleStartPrice;\n   uint256 public publicSaleEndingPrice;\n   uint256 public currentNumLandsMintedPublicSale;\n   uint256 public mintIndexPublicSaleAndContributors;\n   address public tokenContract;\n   bool private isKycCheckRequired;\n   bytes32 public kycMerkleRoot;\n   uint256 public maxMintPerTx;\n   uint256 public maxMintPerAddress;\n   mapping(address => uint256) public mintedPerAddress;\n   bool public claimableActive;\n   bool public adminClaimStarted;\n   address public alphaContract;\n   mapping(uint256 => bool) public alphaClaimed;\n   uint256 public alphaClaimedAmount;\n   address public betaContract;\n   mapping(uint256 => bool) public betaClaimed;\n   uint256 public betaClaimedAmount;\n   uint256 public betaNftIdCurrent;\n   bool public contributorsClaimActive;\n   mapping(address => uint256) public contributors;\n   uint256 public futureLandsNftIdCurrent;\n   address public futureMinter;\n   Metadata[] public metadataHashes;\n   bytes32 public keyHash;\n   uint256 public fee;\n   uint256 public publicSaleAndContributorsOffset;\n   uint256 public alphaOffset;\n   uint256 public betaOffset;\n   mapping(bytes32 => bool) public isRandomRequestForPublicSaleAndContributors;\n   bool public publicSaleAndContributorsRandomnessRequested;\n   bool public ownerClaimRandomnessRequested;\n   \n   // constants\n   uint256 immutable public MAX_LANDS;\n   uint256 immutable public MAX_LANDS_WITH_FUTURE;\n   uint256 immutable public MAX_ALPHA_NFT_AMOUNT;\n   uint256 immutable public MAX_BETA_NFT_AMOUNT;\n   uint256 immutable public MAX_PUBLIC_SALE_AMOUNT;\n   uint256 immutable public RESERVED_CONTRIBUTORS_AMOUNT;\n   uint256 immutable public MAX_FUTURE_LANDS;\n   uint256 constant public MAX_MINT_PER_BLOCK = 150;\n\n   // structs\n   struct LandAmount {\n       uint256 alpha;\n       uint256 beta;\n       uint256 publicSale;\n       uint256 future;\n   }\n\n   struct ContributorAmount {\n       address contributor;\n       uint256 amount;\n   }\n\n   struct Metadata {\n       bytes32 metadataHash;\n       bytes32 shuffledArrayHash;\n       uint256 startIndex;\n       uint256 endIndex;\n   }\n\n   struct ContractAddresses {\n       address alphaContract;\n       address betaContract;\n       address tokenContract;\n   }\n\n   // modifiers\n   modifier whenPublicSaleActive() {\n       require(publicSaleActive, \"Public sale is not active\");\n       _;\n   }\n\n   modifier whenContributorsClaimActive() {\n       require(contributorsClaimActive, \"Contributors Claim is not active\");\n       _;\n   }\n\n   modifier whenClaimableActive() {\n       require(claimableActive && !adminClaimStarted, \"Claimable state is not active\");\n       _;\n   }\n\n   modifier checkMetadataRange(Metadata memory _landMetadata){\n       require(_landMetadata.endIndex < MAX_LANDS_WITH_FUTURE, \"Range upper bound cannot exceed MAX_LANDS_WITH_FUTURE - 1\");\n       _;\n   }\n\n   modifier onlyContributors(address _contributor){\n       require(contributors[_contributor] >= 0, \"Only contributors can call this method\");\n       _;\n   }\n\n   modifier onlyOperator() {\n       require(operator == msg.sender , \"Only operator can call this method\");\n       _;\n   }\n\n   modifier onlyFutureMinter() {\n       require(futureMinter == msg.sender , \"Only futureMinter can call this method\");\n       _;\n   }\n\n   modifier checkFirstMetadataRange(uint256 index, uint256 startIndex, uint256 endIndex) {\n       if(index == 0){\n           require(startIndex == 0, \"For first metadata range lower bound should be 0\");\n           require(endIndex == MAX_LANDS - 1, \"For first metadata range upper bound should be MAX_LANDS - 1\");\n       }\n       _;\n   }\n\n   // events\n   event LandPublicSaleStart(\n       uint256 indexed _saleDuration,\n       uint256 indexed _saleStartTime\n   );\n   event LandPublicSaleStop(\n       uint256 indexed _currentPrice,\n       uint256 indexed _timeElapsed\n   );\n   event ClaimableStateChanged(bool indexed claimableActive);\n   event ContributorsClaimStart(uint256 _timestamp);\n   event ContributorsClaimStop(uint256 _timestamp);\n   event StartingIndexSetPublicSale(uint256 indexed _startingIndex);\n   event StartingIndexSetAlphaBeta(uint256 indexed _alphaOffset, uint256 indexed _betaOffset);\n   event PublicSaleMint(address indexed sender, uint256 indexed numLands, uint256 indexed mintPrice);\n\n   constructor(string memory name, string memory symbol,\n       ContractAddresses memory addresses,\n       LandAmount memory amount,\n       ContributorAmount[] memory _contributors,\n       address _vrfCoordinator, address _linkTokenAddress,\n       bytes32 _vrfKeyHash, uint256 _vrfFee,\n       address _operator\n   ) ERC721(name, symbol) VRFConsumerBase(_vrfCoordinator, _linkTokenAddress) {\n       alphaContract = addresses.alphaContract;\n       betaContract = addresses.betaContract;\n       tokenContract = addresses.tokenContract;\n\n       MAX_ALPHA_NFT_AMOUNT = amount.alpha;\n       MAX_BETA_NFT_AMOUNT = amount.beta;\n       MAX_PUBLIC_SALE_AMOUNT = amount.publicSale;\n       MAX_FUTURE_LANDS = amount.future;\n\n       betaNftIdCurrent = amount.alpha; //beta starts after alpha\n       mintIndexPublicSaleAndContributors = amount.alpha + amount.beta; //public sale starts after beta\n\n       uint256 tempSum;\n       for(uint256 i; i<_contributors.length; ++i){\n           contributors[_contributors[i].contributor] = _contributors[i].amount;\n           tempSum += _contributors[i].amount;\n       }\n       RESERVED_CONTRIBUTORS_AMOUNT = tempSum;\n       MAX_LANDS = amount.alpha + amount.beta + amount.publicSale + RESERVED_CONTRIBUTORS_AMOUNT;\n       MAX_LANDS_WITH_FUTURE = MAX_LANDS + amount.future;\n       futureLandsNftIdCurrent = MAX_LANDS; //future starts after public sale\n       keyHash  = _vrfKeyHash;\n       fee = _vrfFee;\n       operator = _operator;\n   }\n\n   function _baseURI() internal view override returns (string memory) {\n       return baseURI;\n   }\n\n   function setBaseURI(string memory uri) external onlyOperator {\n       baseURI = uri;\n   }\n\n   function setOperator(address _operator) external onlyOwner {\n       operator = _operator;\n   }\n\n   function setMaxMintPerTx(uint256 _maxMintPerTx) external onlyOperator {\n       maxMintPerTx = _maxMintPerTx;\n   }\n\n   function setMaxMintPerAddress(uint256 _maxMintPerAddress) external onlyOperator {\n       maxMintPerAddress = _maxMintPerAddress;\n   }\n\n   function setKycCheckRequired(bool _isKycCheckRequired) external onlyOperator {\n       isKycCheckRequired = _isKycCheckRequired;\n   }\n\n   function setKycMerkleRoot(bytes32 _kycMerkleRoot) external onlyOperator {\n       kycMerkleRoot = _kycMerkleRoot;\n   }\n\n   // Public Sale Methods\n   function startPublicSale(\n       uint256 _publicSalePriceLoweringDuration,\n       uint256 _publicSaleStartPrice,\n       uint256 _publicSaleEndingPrice,\n       uint256 _maxMintPerTx,\n       uint256 _maxMintPerAddress,\n       bool _isKycCheckRequired\n   ) external onlyOperator {\n       require(!publicSaleActive, \"Public sale has already begun\");\n       \n       publicSalePriceLoweringDuration = _publicSalePriceLoweringDuration;\n       publicSaleStartPrice = _publicSaleStartPrice;\n       publicSaleEndingPrice = _publicSaleEndingPrice;\n       publicSaleStartTime = block.timestamp;\n       publicSaleActive = true;\n\n       maxMintPerTx = _maxMintPerTx;\n       maxMintPerAddress = _maxMintPerAddress;\n       isKycCheckRequired = _isKycCheckRequired;\n       emit LandPublicSaleStart(publicSalePriceLoweringDuration, publicSaleStartTime);\n   }\n\n   function stopPublicSale() external onlyOperator whenPublicSaleActive {\n       emit LandPublicSaleStop(getMintPrice(), getElapsedSaleTime());\n       publicSaleActive = false;\n   }\n\n   function getElapsedSaleTime() private view returns (uint256) {\n       return publicSaleStartTime > 0 ? block.timestamp - publicSaleStartTime : 0;\n   }\n\n   function getMintPrice() public view whenPublicSaleActive returns (uint256) {\n       uint256 elapsed = getElapsedSaleTime();\n       uint256 price;\n       if(elapsed < publicSalePriceLoweringDuration) {\n           // Linear decreasing function\n           price =\n               publicSaleStartPrice -\n                   ( ( publicSaleStartPrice - publicSaleEndingPrice ) * elapsed ) / publicSalePriceLoweringDuration ;\n       } else {\n           price = publicSaleEndingPrice;\n       }\n       return price;\n   }\n\n   function mintLands(uint256 numLands, bytes32[] calldata merkleProof) external whenPublicSaleActive nonReentrant {\n       require(numLands > 0, \"Must mint at least one beta\");\n       require(currentNumLandsMintedPublicSale + numLands <= MAX_PUBLIC_SALE_AMOUNT, \"Minting would exceed max supply\");\n       require(numLands <= maxMintPerTx, \"numLands should not exceed maxMintPerTx\");\n       require(numLands + mintedPerAddress[msg.sender] <= maxMintPerAddress, \"sender address cannot mint more than maxMintPerAddress lands\");\n       if(isKycCheckRequired) {\n           require(MerkleProof.verify(merkleProof, kycMerkleRoot, keccak256(abi.encodePacked(msg.sender))), \"Sender address is not in KYC allowlist\");\n       } else {\n           require(msg.sender == tx.origin, \"Minting from smart contracts is disallowed\");\n       }\n   \n       uint256 mintPrice = getMintPrice();\n       IERC20(tokenContract).safeTransferFrom(msg.sender, address(this), mintPrice * numLands);\n       mintedPerAddress[msg.sender] += numLands;\n       emit PublicSaleMint(msg.sender, numLands, mintPrice);\n       mintLandsCommon(numLands, msg.sender);\n   }\n\n   function mintLandsCommon(uint256 numLands, address recipient) private {\n       for (uint256 i; i < numLands; ++i) {\n           _safeMint(recipient, mintIndexPublicSaleAndContributors++);\n       }\n   }\n\n   function withdraw() external onlyOwner {\n       uint256 balance = address(this).balance;\n       if(balance > 0){\n           Address.sendValue(payable(owner()), balance);\n       }\n       balance = IERC20(tokenContract).balanceOf(address(this));\n       if(balance > 0){\n           IERC20(tokenContract).safeTransfer(owner(), balance);\n       }\n   }\n\n   // Alpha/Beta Claim Methods\n   function flipClaimableState() external onlyOperator {\n       claimableActive = !claimableActive;\n       emit ClaimableStateChanged(claimableActive);\n   }\n\n   function nftOwnerClaimLand(uint256[] calldata alphaTokenIds, uint256[] calldata betaTokenIds) external whenClaimableActive {\n       require(alphaTokenIds.length > 0 || betaTokenIds.length > 0, \"Should claim at least one land\");\n       require(alphaTokenIds.length + betaTokenIds.length <= MAX_MINT_PER_BLOCK, \"Input length should be <= MAX_MINT_PER_BLOCK\");\n\n       alphaClaimLand(alphaTokenIds);\n       betaClaimLand(betaTokenIds);\n   }\n\n   function alphaClaimLand(uint256[] calldata alphaTokenIds) private {\n       for(uint256 i; i < alphaTokenIds.length; ++i){\n           uint256 alphaTokenId = alphaTokenIds[i];\n           require(!alphaClaimed[alphaTokenId], \"ALPHA NFT already claimed\");\n           require(ERC721(alphaContract).ownerOf(alphaTokenId) == msg.sender, \"Must own all of the alpha defined by alphaTokenIds\");\n           \n           alphaClaimLandByTokenId(alphaTokenId);    \n       }\n   }\n\n   function alphaClaimLandByTokenId(uint256 alphaTokenId) private {\n       alphaClaimed[alphaTokenId] = true;\n       ++alphaClaimedAmount;        \n       _safeMint(msg.sender, alphaTokenId);\n   }\n\n   function betaClaimLand(uint256[] calldata betaTokenIds) private {\n       for(uint256 i; i < betaTokenIds.length; ++i){\n           uint256 betaTokenId = betaTokenIds[i];\n           require(!betaClaimed[betaTokenId], \"BETA NFT already claimed\");\n           require(ERC721(betaContract).ownerOf(betaTokenId) == msg.sender, \"Must own all of the beta defined by betaTokenIds\");\n           \n           betaClaimLandByTokenId(betaTokenId);    \n       }\n   }\n\n   function betaClaimLandByTokenId(uint256 betaTokenId) private {\n       betaClaimed[betaTokenId] = true;\n       ++betaClaimedAmount;\n       _safeMint(msg.sender, betaNftIdCurrent++);\n   }\n\n   // Contributors Claim Methods\n   function startContributorsClaimPeriod() onlyOperator external {\n       require(!contributorsClaimActive, \"Contributors claim is already active\");\n       contributorsClaimActive = true;\n       emit ContributorsClaimStart(block.timestamp);\n   }\n\n   function stopContributorsClaimPeriod() onlyOperator external whenContributorsClaimActive {\n       contributorsClaimActive = false;\n       emit ContributorsClaimStop(block.timestamp);\n   }\n\n   function contributorsClaimLand(uint256 amount, address recipient) external onlyContributors(msg.sender) whenContributorsClaimActive {\n       require(amount > 0, \"Must mint at least one land\");\n       require(amount <= MAX_MINT_PER_BLOCK, \"amount should not exceed MAX_MINT_PER_BLOCK\");\n       mintLandsCommon(amount, recipient);\n   }\n\n   function claimUnclaimedAndUnsoldLands(address recipient) external onlyOwner {\n       claimUnclaimedAndUnsoldLandsWithAmount(recipient, MAX_MINT_PER_BLOCK);\n   }\n\n   function claimUnclaimedAndUnsoldLandsWithAmount(address recipient, uint256 maxAmount) public onlyOwner {\n       require (publicSaleStartTime > 0 && !claimableActive && !publicSaleActive && !contributorsClaimActive,\n           \"Cannot claim the unclaimed if claimable or public sale are active\");\n       require(maxAmount <= MAX_MINT_PER_BLOCK, \"maxAmount cannot exceed MAX_MINT_PER_BLOCK\");\n       require(alphaClaimedAmount < MAX_ALPHA_NFT_AMOUNT || betaClaimedAmount < MAX_BETA_NFT_AMOUNT\n                   || mintIndexPublicSaleAndContributors < MAX_LANDS, \"Max NFT amount already claimed or sold\");\n\n       uint256 totalMinted;\n       adminClaimStarted = true;\n       //claim beta\n       if(betaClaimedAmount < MAX_BETA_NFT_AMOUNT) {\n           uint256 leftToBeMinted = MAX_BETA_NFT_AMOUNT - betaClaimedAmount;\n           uint256 toMint = leftToBeMinted < maxAmount ? leftToBeMinted :\n               maxAmount; //take the min\n\n           uint256 target = betaNftIdCurrent + toMint;\n           for(; betaNftIdCurrent < target; ++betaNftIdCurrent){\n               ++betaClaimedAmount;\n               ++totalMinted;\n               _safeMint(recipient, betaNftIdCurrent);\n           }\n       }\n\n       //claim alpha\n       if(alphaClaimedAmount < MAX_ALPHA_NFT_AMOUNT) {\n           uint256 leftToBeMinted = MAX_ALPHA_NFT_AMOUNT - alphaClaimedAmount;\n           uint256 toMint = maxAmount < leftToBeMinted + totalMinted ?\n                           maxAmount :\n                           leftToBeMinted + totalMinted; //summing totalMinted avoid to use another counter\n           \n           uint256 lastAlphaNft = MAX_ALPHA_NFT_AMOUNT - 1;\n           for(uint256 i; i <= lastAlphaNft && totalMinted < toMint; ++i) {\n               if(!alphaClaimed[i]){\n                   ++alphaClaimedAmount;\n                   ++totalMinted;\n                   alphaClaimed[i] = true;\n                   _safeMint(recipient, i);\n               }\n           }\n       }\n\n       //claim unsold\n       if(mintIndexPublicSaleAndContributors < MAX_LANDS){\n           uint256 leftToBeMinted = MAX_LANDS - mintIndexPublicSaleAndContributors;\n           uint256 toMint = maxAmount < leftToBeMinted + totalMinted ?\n                           maxAmount :\n                           leftToBeMinted + totalMinted; //summing totalMinted avoid to use another counter\n\n           for(; mintIndexPublicSaleAndContributors < MAX_LANDS && totalMinted < toMint; ++mintIndexPublicSaleAndContributors) {\n                   ++totalMinted;\n                   _safeMint(recipient, mintIndexPublicSaleAndContributors);\n           }              \n       }\n   }\n\n   //future\n   function setFutureMinter(address _futureMinter) external onlyOwner {\n       futureMinter = _futureMinter;\n   }\n\n   function mintFutureLands(address recipient) external onlyFutureMinter {\n       mintFutureLandsWithAmount(recipient, MAX_MINT_PER_BLOCK);\n   }\n\n   function mintFutureLandsWithAmount(address recipient, uint256 maxAmount) public onlyFutureMinter {\n       require(maxAmount <= MAX_MINT_PER_BLOCK, \"maxAmount cannot exceed MAX_MINT_PER_BLOCK\");    \n       require(futureLandsNftIdCurrent < MAX_LANDS_WITH_FUTURE, \"All future lands were already minted\");\n       for(uint256 claimed; claimed < maxAmount && futureLandsNftIdCurrent < MAX_LANDS_WITH_FUTURE; ++claimed){\n           _safeMint(recipient, futureLandsNftIdCurrent++);\n       }\n   }\n   \n   // metadata\n   function loadLandMetadata(Metadata memory _landMetadata)\n       external onlyOperator checkMetadataRange(_landMetadata)\n       checkFirstMetadataRange(metadataHashes.length, _landMetadata.startIndex, _landMetadata.endIndex)\n   {\n       metadataHashes.push(_landMetadata);\n   }\n\n   function putLandMetadataAtIndex(uint256 index, Metadata memory _landMetadata)\n       external onlyOperator checkMetadataRange(_landMetadata)\n       checkFirstMetadataRange(index, _landMetadata.startIndex, _landMetadata.endIndex)\n   {\n       metadataHashes[index] = _landMetadata;\n   }    \n\n   // randomness\n   function requestRandomnessForPublicSaleAndContributors() external onlyOperator returns (bytes32 requestId) {\n       require(!publicSaleAndContributorsRandomnessRequested, \"Public Sale And Contributors Offset already requested\");\n       publicSaleAndContributorsRandomnessRequested = true;\n       requestId = requestRandomnessPrivate();\n       isRandomRequestForPublicSaleAndContributors[requestId] = true;\n   }\n\n   function requestRandomnessForOwnerClaim() external onlyOperator returns (bytes32 requestId) {\n       require(!ownerClaimRandomnessRequested, \"Owner Claim Offset already requested\");\n       ownerClaimRandomnessRequested = true;\n       requestId = requestRandomnessPrivate();\n       isRandomRequestForPublicSaleAndContributors[requestId] = false;\n   }\n\n   function requestRandomnessPrivate() private returns (bytes32 requestId) {\n       require(\n           LINK.balanceOf(address(this)) >= fee,\n           \"Not enough LINK\"\n       );\n       return requestRandomness(keyHash, fee);\n   }\n\n   function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n       if(isRandomRequestForPublicSaleAndContributors[requestId]){\n           publicSaleAndContributorsOffset = (randomness % (MAX_PUBLIC_SALE_AMOUNT + RESERVED_CONTRIBUTORS_AMOUNT));\n           emit StartingIndexSetPublicSale(publicSaleAndContributorsOffset);\n       } else {\n           alphaOffset = (randomness % MAX_ALPHA_NFT_AMOUNT);\n           betaOffset = (randomness % MAX_BETA_NFT_AMOUNT);\n           emit StartingIndexSetAlphaBeta(alphaOffset, betaOffset);\n       }\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Missing zero-address validation"
      },
      {
        "choice": "B",
        "answer": "Missing event emission"
      },
      {
        "choice": "C",
        "answer": "Incorrect modifier"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B"
    ],
    "race": "RACE-6.md"
  },
  {
    "question": "3] The security concern(s) with _InSecureumLand_ _mintLands()_ is/are",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumLand_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumLand_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n\ncontract InSecureumLand is ERC721Enumerable, Ownable, ReentrancyGuard, VRFConsumerBase {\n   using SafeERC20 for IERC20;\n\n   // attributes\n   string private baseURI;\n   address public operator;\n   bool public publicSaleActive;\n   uint256 public publicSaleStartTime;\n   uint256 public publicSalePriceLoweringDuration;\n   uint256 public publicSaleStartPrice;\n   uint256 public publicSaleEndingPrice;\n   uint256 public currentNumLandsMintedPublicSale;\n   uint256 public mintIndexPublicSaleAndContributors;\n   address public tokenContract;\n   bool private isKycCheckRequired;\n   bytes32 public kycMerkleRoot;\n   uint256 public maxMintPerTx;\n   uint256 public maxMintPerAddress;\n   mapping(address => uint256) public mintedPerAddress;\n   bool public claimableActive;\n   bool public adminClaimStarted;\n   address public alphaContract;\n   mapping(uint256 => bool) public alphaClaimed;\n   uint256 public alphaClaimedAmount;\n   address public betaContract;\n   mapping(uint256 => bool) public betaClaimed;\n   uint256 public betaClaimedAmount;\n   uint256 public betaNftIdCurrent;\n   bool public contributorsClaimActive;\n   mapping(address => uint256) public contributors;\n   uint256 public futureLandsNftIdCurrent;\n   address public futureMinter;\n   Metadata[] public metadataHashes;\n   bytes32 public keyHash;\n   uint256 public fee;\n   uint256 public publicSaleAndContributorsOffset;\n   uint256 public alphaOffset;\n   uint256 public betaOffset;\n   mapping(bytes32 => bool) public isRandomRequestForPublicSaleAndContributors;\n   bool public publicSaleAndContributorsRandomnessRequested;\n   bool public ownerClaimRandomnessRequested;\n   \n   // constants\n   uint256 immutable public MAX_LANDS;\n   uint256 immutable public MAX_LANDS_WITH_FUTURE;\n   uint256 immutable public MAX_ALPHA_NFT_AMOUNT;\n   uint256 immutable public MAX_BETA_NFT_AMOUNT;\n   uint256 immutable public MAX_PUBLIC_SALE_AMOUNT;\n   uint256 immutable public RESERVED_CONTRIBUTORS_AMOUNT;\n   uint256 immutable public MAX_FUTURE_LANDS;\n   uint256 constant public MAX_MINT_PER_BLOCK = 150;\n\n   // structs\n   struct LandAmount {\n       uint256 alpha;\n       uint256 beta;\n       uint256 publicSale;\n       uint256 future;\n   }\n\n   struct ContributorAmount {\n       address contributor;\n       uint256 amount;\n   }\n\n   struct Metadata {\n       bytes32 metadataHash;\n       bytes32 shuffledArrayHash;\n       uint256 startIndex;\n       uint256 endIndex;\n   }\n\n   struct ContractAddresses {\n       address alphaContract;\n       address betaContract;\n       address tokenContract;\n   }\n\n   // modifiers\n   modifier whenPublicSaleActive() {\n       require(publicSaleActive, \"Public sale is not active\");\n       _;\n   }\n\n   modifier whenContributorsClaimActive() {\n       require(contributorsClaimActive, \"Contributors Claim is not active\");\n       _;\n   }\n\n   modifier whenClaimableActive() {\n       require(claimableActive && !adminClaimStarted, \"Claimable state is not active\");\n       _;\n   }\n\n   modifier checkMetadataRange(Metadata memory _landMetadata){\n       require(_landMetadata.endIndex < MAX_LANDS_WITH_FUTURE, \"Range upper bound cannot exceed MAX_LANDS_WITH_FUTURE - 1\");\n       _;\n   }\n\n   modifier onlyContributors(address _contributor){\n       require(contributors[_contributor] >= 0, \"Only contributors can call this method\");\n       _;\n   }\n\n   modifier onlyOperator() {\n       require(operator == msg.sender , \"Only operator can call this method\");\n       _;\n   }\n\n   modifier onlyFutureMinter() {\n       require(futureMinter == msg.sender , \"Only futureMinter can call this method\");\n       _;\n   }\n\n   modifier checkFirstMetadataRange(uint256 index, uint256 startIndex, uint256 endIndex) {\n       if(index == 0){\n           require(startIndex == 0, \"For first metadata range lower bound should be 0\");\n           require(endIndex == MAX_LANDS - 1, \"For first metadata range upper bound should be MAX_LANDS - 1\");\n       }\n       _;\n   }\n\n   // events\n   event LandPublicSaleStart(\n       uint256 indexed _saleDuration,\n       uint256 indexed _saleStartTime\n   );\n   event LandPublicSaleStop(\n       uint256 indexed _currentPrice,\n       uint256 indexed _timeElapsed\n   );\n   event ClaimableStateChanged(bool indexed claimableActive);\n   event ContributorsClaimStart(uint256 _timestamp);\n   event ContributorsClaimStop(uint256 _timestamp);\n   event StartingIndexSetPublicSale(uint256 indexed _startingIndex);\n   event StartingIndexSetAlphaBeta(uint256 indexed _alphaOffset, uint256 indexed _betaOffset);\n   event PublicSaleMint(address indexed sender, uint256 indexed numLands, uint256 indexed mintPrice);\n\n   constructor(string memory name, string memory symbol,\n       ContractAddresses memory addresses,\n       LandAmount memory amount,\n       ContributorAmount[] memory _contributors,\n       address _vrfCoordinator, address _linkTokenAddress,\n       bytes32 _vrfKeyHash, uint256 _vrfFee,\n       address _operator\n   ) ERC721(name, symbol) VRFConsumerBase(_vrfCoordinator, _linkTokenAddress) {\n       alphaContract = addresses.alphaContract;\n       betaContract = addresses.betaContract;\n       tokenContract = addresses.tokenContract;\n\n       MAX_ALPHA_NFT_AMOUNT = amount.alpha;\n       MAX_BETA_NFT_AMOUNT = amount.beta;\n       MAX_PUBLIC_SALE_AMOUNT = amount.publicSale;\n       MAX_FUTURE_LANDS = amount.future;\n\n       betaNftIdCurrent = amount.alpha; //beta starts after alpha\n       mintIndexPublicSaleAndContributors = amount.alpha + amount.beta; //public sale starts after beta\n\n       uint256 tempSum;\n       for(uint256 i; i<_contributors.length; ++i){\n           contributors[_contributors[i].contributor] = _contributors[i].amount;\n           tempSum += _contributors[i].amount;\n       }\n       RESERVED_CONTRIBUTORS_AMOUNT = tempSum;\n       MAX_LANDS = amount.alpha + amount.beta + amount.publicSale + RESERVED_CONTRIBUTORS_AMOUNT;\n       MAX_LANDS_WITH_FUTURE = MAX_LANDS + amount.future;\n       futureLandsNftIdCurrent = MAX_LANDS; //future starts after public sale\n       keyHash  = _vrfKeyHash;\n       fee = _vrfFee;\n       operator = _operator;\n   }\n\n   function _baseURI() internal view override returns (string memory) {\n       return baseURI;\n   }\n\n   function setBaseURI(string memory uri) external onlyOperator {\n       baseURI = uri;\n   }\n\n   function setOperator(address _operator) external onlyOwner {\n       operator = _operator;\n   }\n\n   function setMaxMintPerTx(uint256 _maxMintPerTx) external onlyOperator {\n       maxMintPerTx = _maxMintPerTx;\n   }\n\n   function setMaxMintPerAddress(uint256 _maxMintPerAddress) external onlyOperator {\n       maxMintPerAddress = _maxMintPerAddress;\n   }\n\n   function setKycCheckRequired(bool _isKycCheckRequired) external onlyOperator {\n       isKycCheckRequired = _isKycCheckRequired;\n   }\n\n   function setKycMerkleRoot(bytes32 _kycMerkleRoot) external onlyOperator {\n       kycMerkleRoot = _kycMerkleRoot;\n   }\n\n   // Public Sale Methods\n   function startPublicSale(\n       uint256 _publicSalePriceLoweringDuration,\n       uint256 _publicSaleStartPrice,\n       uint256 _publicSaleEndingPrice,\n       uint256 _maxMintPerTx,\n       uint256 _maxMintPerAddress,\n       bool _isKycCheckRequired\n   ) external onlyOperator {\n       require(!publicSaleActive, \"Public sale has already begun\");\n       \n       publicSalePriceLoweringDuration = _publicSalePriceLoweringDuration;\n       publicSaleStartPrice = _publicSaleStartPrice;\n       publicSaleEndingPrice = _publicSaleEndingPrice;\n       publicSaleStartTime = block.timestamp;\n       publicSaleActive = true;\n\n       maxMintPerTx = _maxMintPerTx;\n       maxMintPerAddress = _maxMintPerAddress;\n       isKycCheckRequired = _isKycCheckRequired;\n       emit LandPublicSaleStart(publicSalePriceLoweringDuration, publicSaleStartTime);\n   }\n\n   function stopPublicSale() external onlyOperator whenPublicSaleActive {\n       emit LandPublicSaleStop(getMintPrice(), getElapsedSaleTime());\n       publicSaleActive = false;\n   }\n\n   function getElapsedSaleTime() private view returns (uint256) {\n       return publicSaleStartTime > 0 ? block.timestamp - publicSaleStartTime : 0;\n   }\n\n   function getMintPrice() public view whenPublicSaleActive returns (uint256) {\n       uint256 elapsed = getElapsedSaleTime();\n       uint256 price;\n       if(elapsed < publicSalePriceLoweringDuration) {\n           // Linear decreasing function\n           price =\n               publicSaleStartPrice -\n                   ( ( publicSaleStartPrice - publicSaleEndingPrice ) * elapsed ) / publicSalePriceLoweringDuration ;\n       } else {\n           price = publicSaleEndingPrice;\n       }\n       return price;\n   }\n\n   function mintLands(uint256 numLands, bytes32[] calldata merkleProof) external whenPublicSaleActive nonReentrant {\n       require(numLands > 0, \"Must mint at least one beta\");\n       require(currentNumLandsMintedPublicSale + numLands <= MAX_PUBLIC_SALE_AMOUNT, \"Minting would exceed max supply\");\n       require(numLands <= maxMintPerTx, \"numLands should not exceed maxMintPerTx\");\n       require(numLands + mintedPerAddress[msg.sender] <= maxMintPerAddress, \"sender address cannot mint more than maxMintPerAddress lands\");\n       if(isKycCheckRequired) {\n           require(MerkleProof.verify(merkleProof, kycMerkleRoot, keccak256(abi.encodePacked(msg.sender))), \"Sender address is not in KYC allowlist\");\n       } else {\n           require(msg.sender == tx.origin, \"Minting from smart contracts is disallowed\");\n       }\n   \n       uint256 mintPrice = getMintPrice();\n       IERC20(tokenContract).safeTransferFrom(msg.sender, address(this), mintPrice * numLands);\n       mintedPerAddress[msg.sender] += numLands;\n       emit PublicSaleMint(msg.sender, numLands, mintPrice);\n       mintLandsCommon(numLands, msg.sender);\n   }\n\n   function mintLandsCommon(uint256 numLands, address recipient) private {\n       for (uint256 i; i < numLands; ++i) {\n           _safeMint(recipient, mintIndexPublicSaleAndContributors++);\n       }\n   }\n\n   function withdraw() external onlyOwner {\n       uint256 balance = address(this).balance;\n       if(balance > 0){\n           Address.sendValue(payable(owner()), balance);\n       }\n       balance = IERC20(tokenContract).balanceOf(address(this));\n       if(balance > 0){\n           IERC20(tokenContract).safeTransfer(owner(), balance);\n       }\n   }\n\n   // Alpha/Beta Claim Methods\n   function flipClaimableState() external onlyOperator {\n       claimableActive = !claimableActive;\n       emit ClaimableStateChanged(claimableActive);\n   }\n\n   function nftOwnerClaimLand(uint256[] calldata alphaTokenIds, uint256[] calldata betaTokenIds) external whenClaimableActive {\n       require(alphaTokenIds.length > 0 || betaTokenIds.length > 0, \"Should claim at least one land\");\n       require(alphaTokenIds.length + betaTokenIds.length <= MAX_MINT_PER_BLOCK, \"Input length should be <= MAX_MINT_PER_BLOCK\");\n\n       alphaClaimLand(alphaTokenIds);\n       betaClaimLand(betaTokenIds);\n   }\n\n   function alphaClaimLand(uint256[] calldata alphaTokenIds) private {\n       for(uint256 i; i < alphaTokenIds.length; ++i){\n           uint256 alphaTokenId = alphaTokenIds[i];\n           require(!alphaClaimed[alphaTokenId], \"ALPHA NFT already claimed\");\n           require(ERC721(alphaContract).ownerOf(alphaTokenId) == msg.sender, \"Must own all of the alpha defined by alphaTokenIds\");\n           \n           alphaClaimLandByTokenId(alphaTokenId);    \n       }\n   }\n\n   function alphaClaimLandByTokenId(uint256 alphaTokenId) private {\n       alphaClaimed[alphaTokenId] = true;\n       ++alphaClaimedAmount;        \n       _safeMint(msg.sender, alphaTokenId);\n   }\n\n   function betaClaimLand(uint256[] calldata betaTokenIds) private {\n       for(uint256 i; i < betaTokenIds.length; ++i){\n           uint256 betaTokenId = betaTokenIds[i];\n           require(!betaClaimed[betaTokenId], \"BETA NFT already claimed\");\n           require(ERC721(betaContract).ownerOf(betaTokenId) == msg.sender, \"Must own all of the beta defined by betaTokenIds\");\n           \n           betaClaimLandByTokenId(betaTokenId);    \n       }\n   }\n\n   function betaClaimLandByTokenId(uint256 betaTokenId) private {\n       betaClaimed[betaTokenId] = true;\n       ++betaClaimedAmount;\n       _safeMint(msg.sender, betaNftIdCurrent++);\n   }\n\n   // Contributors Claim Methods\n   function startContributorsClaimPeriod() onlyOperator external {\n       require(!contributorsClaimActive, \"Contributors claim is already active\");\n       contributorsClaimActive = true;\n       emit ContributorsClaimStart(block.timestamp);\n   }\n\n   function stopContributorsClaimPeriod() onlyOperator external whenContributorsClaimActive {\n       contributorsClaimActive = false;\n       emit ContributorsClaimStop(block.timestamp);\n   }\n\n   function contributorsClaimLand(uint256 amount, address recipient) external onlyContributors(msg.sender) whenContributorsClaimActive {\n       require(amount > 0, \"Must mint at least one land\");\n       require(amount <= MAX_MINT_PER_BLOCK, \"amount should not exceed MAX_MINT_PER_BLOCK\");\n       mintLandsCommon(amount, recipient);\n   }\n\n   function claimUnclaimedAndUnsoldLands(address recipient) external onlyOwner {\n       claimUnclaimedAndUnsoldLandsWithAmount(recipient, MAX_MINT_PER_BLOCK);\n   }\n\n   function claimUnclaimedAndUnsoldLandsWithAmount(address recipient, uint256 maxAmount) public onlyOwner {\n       require (publicSaleStartTime > 0 && !claimableActive && !publicSaleActive && !contributorsClaimActive,\n           \"Cannot claim the unclaimed if claimable or public sale are active\");\n       require(maxAmount <= MAX_MINT_PER_BLOCK, \"maxAmount cannot exceed MAX_MINT_PER_BLOCK\");\n       require(alphaClaimedAmount < MAX_ALPHA_NFT_AMOUNT || betaClaimedAmount < MAX_BETA_NFT_AMOUNT\n                   || mintIndexPublicSaleAndContributors < MAX_LANDS, \"Max NFT amount already claimed or sold\");\n\n       uint256 totalMinted;\n       adminClaimStarted = true;\n       //claim beta\n       if(betaClaimedAmount < MAX_BETA_NFT_AMOUNT) {\n           uint256 leftToBeMinted = MAX_BETA_NFT_AMOUNT - betaClaimedAmount;\n           uint256 toMint = leftToBeMinted < maxAmount ? leftToBeMinted :\n               maxAmount; //take the min\n\n           uint256 target = betaNftIdCurrent + toMint;\n           for(; betaNftIdCurrent < target; ++betaNftIdCurrent){\n               ++betaClaimedAmount;\n               ++totalMinted;\n               _safeMint(recipient, betaNftIdCurrent);\n           }\n       }\n\n       //claim alpha\n       if(alphaClaimedAmount < MAX_ALPHA_NFT_AMOUNT) {\n           uint256 leftToBeMinted = MAX_ALPHA_NFT_AMOUNT - alphaClaimedAmount;\n           uint256 toMint = maxAmount < leftToBeMinted + totalMinted ?\n                           maxAmount :\n                           leftToBeMinted + totalMinted; //summing totalMinted avoid to use another counter\n           \n           uint256 lastAlphaNft = MAX_ALPHA_NFT_AMOUNT - 1;\n           for(uint256 i; i <= lastAlphaNft && totalMinted < toMint; ++i) {\n               if(!alphaClaimed[i]){\n                   ++alphaClaimedAmount;\n                   ++totalMinted;\n                   alphaClaimed[i] = true;\n                   _safeMint(recipient, i);\n               }\n           }\n       }\n\n       //claim unsold\n       if(mintIndexPublicSaleAndContributors < MAX_LANDS){\n           uint256 leftToBeMinted = MAX_LANDS - mintIndexPublicSaleAndContributors;\n           uint256 toMint = maxAmount < leftToBeMinted + totalMinted ?\n                           maxAmount :\n                           leftToBeMinted + totalMinted; //summing totalMinted avoid to use another counter\n\n           for(; mintIndexPublicSaleAndContributors < MAX_LANDS && totalMinted < toMint; ++mintIndexPublicSaleAndContributors) {\n                   ++totalMinted;\n                   _safeMint(recipient, mintIndexPublicSaleAndContributors);\n           }              \n       }\n   }\n\n   //future\n   function setFutureMinter(address _futureMinter) external onlyOwner {\n       futureMinter = _futureMinter;\n   }\n\n   function mintFutureLands(address recipient) external onlyFutureMinter {\n       mintFutureLandsWithAmount(recipient, MAX_MINT_PER_BLOCK);\n   }\n\n   function mintFutureLandsWithAmount(address recipient, uint256 maxAmount) public onlyFutureMinter {\n       require(maxAmount <= MAX_MINT_PER_BLOCK, \"maxAmount cannot exceed MAX_MINT_PER_BLOCK\");    \n       require(futureLandsNftIdCurrent < MAX_LANDS_WITH_FUTURE, \"All future lands were already minted\");\n       for(uint256 claimed; claimed < maxAmount && futureLandsNftIdCurrent < MAX_LANDS_WITH_FUTURE; ++claimed){\n           _safeMint(recipient, futureLandsNftIdCurrent++);\n       }\n   }\n   \n   // metadata\n   function loadLandMetadata(Metadata memory _landMetadata)\n       external onlyOperator checkMetadataRange(_landMetadata)\n       checkFirstMetadataRange(metadataHashes.length, _landMetadata.startIndex, _landMetadata.endIndex)\n   {\n       metadataHashes.push(_landMetadata);\n   }\n\n   function putLandMetadataAtIndex(uint256 index, Metadata memory _landMetadata)\n       external onlyOperator checkMetadataRange(_landMetadata)\n       checkFirstMetadataRange(index, _landMetadata.startIndex, _landMetadata.endIndex)\n   {\n       metadataHashes[index] = _landMetadata;\n   }    \n\n   // randomness\n   function requestRandomnessForPublicSaleAndContributors() external onlyOperator returns (bytes32 requestId) {\n       require(!publicSaleAndContributorsRandomnessRequested, \"Public Sale And Contributors Offset already requested\");\n       publicSaleAndContributorsRandomnessRequested = true;\n       requestId = requestRandomnessPrivate();\n       isRandomRequestForPublicSaleAndContributors[requestId] = true;\n   }\n\n   function requestRandomnessForOwnerClaim() external onlyOperator returns (bytes32 requestId) {\n       require(!ownerClaimRandomnessRequested, \"Owner Claim Offset already requested\");\n       ownerClaimRandomnessRequested = true;\n       requestId = requestRandomnessPrivate();\n       isRandomRequestForPublicSaleAndContributors[requestId] = false;\n   }\n\n   function requestRandomnessPrivate() private returns (bytes32 requestId) {\n       require(\n           LINK.balanceOf(address(this)) >= fee,\n           \"Not enough LINK\"\n       );\n       return requestRandomness(keyHash, fee);\n   }\n\n   function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n       if(isRandomRequestForPublicSaleAndContributors[requestId]){\n           publicSaleAndContributorsOffset = (randomness % (MAX_PUBLIC_SALE_AMOUNT + RESERVED_CONTRIBUTORS_AMOUNT));\n           emit StartingIndexSetPublicSale(publicSaleAndContributorsOffset);\n       } else {\n           alphaOffset = (randomness % MAX_ALPHA_NFT_AMOUNT);\n           betaOffset = (randomness % MAX_BETA_NFT_AMOUNT);\n           emit StartingIndexSetAlphaBeta(alphaOffset, betaOffset);\n       }\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Minting could exceed max supply"
      },
      {
        "choice": "B",
        "answer": "Minting could exceed `maxMintPerTx`"
      },
      {
        "choice": "C",
        "answer": "Minting could exceed `maxMintPerAddress`"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "race": "RACE-6.md"
  },
  {
    "question": "4] Missing threshold check(s) on parameter(s) is/are a concern in",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumLand_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumLand_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n\ncontract InSecureumLand is ERC721Enumerable, Ownable, ReentrancyGuard, VRFConsumerBase {\n   using SafeERC20 for IERC20;\n\n   // attributes\n   string private baseURI;\n   address public operator;\n   bool public publicSaleActive;\n   uint256 public publicSaleStartTime;\n   uint256 public publicSalePriceLoweringDuration;\n   uint256 public publicSaleStartPrice;\n   uint256 public publicSaleEndingPrice;\n   uint256 public currentNumLandsMintedPublicSale;\n   uint256 public mintIndexPublicSaleAndContributors;\n   address public tokenContract;\n   bool private isKycCheckRequired;\n   bytes32 public kycMerkleRoot;\n   uint256 public maxMintPerTx;\n   uint256 public maxMintPerAddress;\n   mapping(address => uint256) public mintedPerAddress;\n   bool public claimableActive;\n   bool public adminClaimStarted;\n   address public alphaContract;\n   mapping(uint256 => bool) public alphaClaimed;\n   uint256 public alphaClaimedAmount;\n   address public betaContract;\n   mapping(uint256 => bool) public betaClaimed;\n   uint256 public betaClaimedAmount;\n   uint256 public betaNftIdCurrent;\n   bool public contributorsClaimActive;\n   mapping(address => uint256) public contributors;\n   uint256 public futureLandsNftIdCurrent;\n   address public futureMinter;\n   Metadata[] public metadataHashes;\n   bytes32 public keyHash;\n   uint256 public fee;\n   uint256 public publicSaleAndContributorsOffset;\n   uint256 public alphaOffset;\n   uint256 public betaOffset;\n   mapping(bytes32 => bool) public isRandomRequestForPublicSaleAndContributors;\n   bool public publicSaleAndContributorsRandomnessRequested;\n   bool public ownerClaimRandomnessRequested;\n   \n   // constants\n   uint256 immutable public MAX_LANDS;\n   uint256 immutable public MAX_LANDS_WITH_FUTURE;\n   uint256 immutable public MAX_ALPHA_NFT_AMOUNT;\n   uint256 immutable public MAX_BETA_NFT_AMOUNT;\n   uint256 immutable public MAX_PUBLIC_SALE_AMOUNT;\n   uint256 immutable public RESERVED_CONTRIBUTORS_AMOUNT;\n   uint256 immutable public MAX_FUTURE_LANDS;\n   uint256 constant public MAX_MINT_PER_BLOCK = 150;\n\n   // structs\n   struct LandAmount {\n       uint256 alpha;\n       uint256 beta;\n       uint256 publicSale;\n       uint256 future;\n   }\n\n   struct ContributorAmount {\n       address contributor;\n       uint256 amount;\n   }\n\n   struct Metadata {\n       bytes32 metadataHash;\n       bytes32 shuffledArrayHash;\n       uint256 startIndex;\n       uint256 endIndex;\n   }\n\n   struct ContractAddresses {\n       address alphaContract;\n       address betaContract;\n       address tokenContract;\n   }\n\n   // modifiers\n   modifier whenPublicSaleActive() {\n       require(publicSaleActive, \"Public sale is not active\");\n       _;\n   }\n\n   modifier whenContributorsClaimActive() {\n       require(contributorsClaimActive, \"Contributors Claim is not active\");\n       _;\n   }\n\n   modifier whenClaimableActive() {\n       require(claimableActive && !adminClaimStarted, \"Claimable state is not active\");\n       _;\n   }\n\n   modifier checkMetadataRange(Metadata memory _landMetadata){\n       require(_landMetadata.endIndex < MAX_LANDS_WITH_FUTURE, \"Range upper bound cannot exceed MAX_LANDS_WITH_FUTURE - 1\");\n       _;\n   }\n\n   modifier onlyContributors(address _contributor){\n       require(contributors[_contributor] >= 0, \"Only contributors can call this method\");\n       _;\n   }\n\n   modifier onlyOperator() {\n       require(operator == msg.sender , \"Only operator can call this method\");\n       _;\n   }\n\n   modifier onlyFutureMinter() {\n       require(futureMinter == msg.sender , \"Only futureMinter can call this method\");\n       _;\n   }\n\n   modifier checkFirstMetadataRange(uint256 index, uint256 startIndex, uint256 endIndex) {\n       if(index == 0){\n           require(startIndex == 0, \"For first metadata range lower bound should be 0\");\n           require(endIndex == MAX_LANDS - 1, \"For first metadata range upper bound should be MAX_LANDS - 1\");\n       }\n       _;\n   }\n\n   // events\n   event LandPublicSaleStart(\n       uint256 indexed _saleDuration,\n       uint256 indexed _saleStartTime\n   );\n   event LandPublicSaleStop(\n       uint256 indexed _currentPrice,\n       uint256 indexed _timeElapsed\n   );\n   event ClaimableStateChanged(bool indexed claimableActive);\n   event ContributorsClaimStart(uint256 _timestamp);\n   event ContributorsClaimStop(uint256 _timestamp);\n   event StartingIndexSetPublicSale(uint256 indexed _startingIndex);\n   event StartingIndexSetAlphaBeta(uint256 indexed _alphaOffset, uint256 indexed _betaOffset);\n   event PublicSaleMint(address indexed sender, uint256 indexed numLands, uint256 indexed mintPrice);\n\n   constructor(string memory name, string memory symbol,\n       ContractAddresses memory addresses,\n       LandAmount memory amount,\n       ContributorAmount[] memory _contributors,\n       address _vrfCoordinator, address _linkTokenAddress,\n       bytes32 _vrfKeyHash, uint256 _vrfFee,\n       address _operator\n   ) ERC721(name, symbol) VRFConsumerBase(_vrfCoordinator, _linkTokenAddress) {\n       alphaContract = addresses.alphaContract;\n       betaContract = addresses.betaContract;\n       tokenContract = addresses.tokenContract;\n\n       MAX_ALPHA_NFT_AMOUNT = amount.alpha;\n       MAX_BETA_NFT_AMOUNT = amount.beta;\n       MAX_PUBLIC_SALE_AMOUNT = amount.publicSale;\n       MAX_FUTURE_LANDS = amount.future;\n\n       betaNftIdCurrent = amount.alpha; //beta starts after alpha\n       mintIndexPublicSaleAndContributors = amount.alpha + amount.beta; //public sale starts after beta\n\n       uint256 tempSum;\n       for(uint256 i; i<_contributors.length; ++i){\n           contributors[_contributors[i].contributor] = _contributors[i].amount;\n           tempSum += _contributors[i].amount;\n       }\n       RESERVED_CONTRIBUTORS_AMOUNT = tempSum;\n       MAX_LANDS = amount.alpha + amount.beta + amount.publicSale + RESERVED_CONTRIBUTORS_AMOUNT;\n       MAX_LANDS_WITH_FUTURE = MAX_LANDS + amount.future;\n       futureLandsNftIdCurrent = MAX_LANDS; //future starts after public sale\n       keyHash  = _vrfKeyHash;\n       fee = _vrfFee;\n       operator = _operator;\n   }\n\n   function _baseURI() internal view override returns (string memory) {\n       return baseURI;\n   }\n\n   function setBaseURI(string memory uri) external onlyOperator {\n       baseURI = uri;\n   }\n\n   function setOperator(address _operator) external onlyOwner {\n       operator = _operator;\n   }\n\n   function setMaxMintPerTx(uint256 _maxMintPerTx) external onlyOperator {\n       maxMintPerTx = _maxMintPerTx;\n   }\n\n   function setMaxMintPerAddress(uint256 _maxMintPerAddress) external onlyOperator {\n       maxMintPerAddress = _maxMintPerAddress;\n   }\n\n   function setKycCheckRequired(bool _isKycCheckRequired) external onlyOperator {\n       isKycCheckRequired = _isKycCheckRequired;\n   }\n\n   function setKycMerkleRoot(bytes32 _kycMerkleRoot) external onlyOperator {\n       kycMerkleRoot = _kycMerkleRoot;\n   }\n\n   // Public Sale Methods\n   function startPublicSale(\n       uint256 _publicSalePriceLoweringDuration,\n       uint256 _publicSaleStartPrice,\n       uint256 _publicSaleEndingPrice,\n       uint256 _maxMintPerTx,\n       uint256 _maxMintPerAddress,\n       bool _isKycCheckRequired\n   ) external onlyOperator {\n       require(!publicSaleActive, \"Public sale has already begun\");\n       \n       publicSalePriceLoweringDuration = _publicSalePriceLoweringDuration;\n       publicSaleStartPrice = _publicSaleStartPrice;\n       publicSaleEndingPrice = _publicSaleEndingPrice;\n       publicSaleStartTime = block.timestamp;\n       publicSaleActive = true;\n\n       maxMintPerTx = _maxMintPerTx;\n       maxMintPerAddress = _maxMintPerAddress;\n       isKycCheckRequired = _isKycCheckRequired;\n       emit LandPublicSaleStart(publicSalePriceLoweringDuration, publicSaleStartTime);\n   }\n\n   function stopPublicSale() external onlyOperator whenPublicSaleActive {\n       emit LandPublicSaleStop(getMintPrice(), getElapsedSaleTime());\n       publicSaleActive = false;\n   }\n\n   function getElapsedSaleTime() private view returns (uint256) {\n       return publicSaleStartTime > 0 ? block.timestamp - publicSaleStartTime : 0;\n   }\n\n   function getMintPrice() public view whenPublicSaleActive returns (uint256) {\n       uint256 elapsed = getElapsedSaleTime();\n       uint256 price;\n       if(elapsed < publicSalePriceLoweringDuration) {\n           // Linear decreasing function\n           price =\n               publicSaleStartPrice -\n                   ( ( publicSaleStartPrice - publicSaleEndingPrice ) * elapsed ) / publicSalePriceLoweringDuration ;\n       } else {\n           price = publicSaleEndingPrice;\n       }\n       return price;\n   }\n\n   function mintLands(uint256 numLands, bytes32[] calldata merkleProof) external whenPublicSaleActive nonReentrant {\n       require(numLands > 0, \"Must mint at least one beta\");\n       require(currentNumLandsMintedPublicSale + numLands <= MAX_PUBLIC_SALE_AMOUNT, \"Minting would exceed max supply\");\n       require(numLands <= maxMintPerTx, \"numLands should not exceed maxMintPerTx\");\n       require(numLands + mintedPerAddress[msg.sender] <= maxMintPerAddress, \"sender address cannot mint more than maxMintPerAddress lands\");\n       if(isKycCheckRequired) {\n           require(MerkleProof.verify(merkleProof, kycMerkleRoot, keccak256(abi.encodePacked(msg.sender))), \"Sender address is not in KYC allowlist\");\n       } else {\n           require(msg.sender == tx.origin, \"Minting from smart contracts is disallowed\");\n       }\n   \n       uint256 mintPrice = getMintPrice();\n       IERC20(tokenContract).safeTransferFrom(msg.sender, address(this), mintPrice * numLands);\n       mintedPerAddress[msg.sender] += numLands;\n       emit PublicSaleMint(msg.sender, numLands, mintPrice);\n       mintLandsCommon(numLands, msg.sender);\n   }\n\n   function mintLandsCommon(uint256 numLands, address recipient) private {\n       for (uint256 i; i < numLands; ++i) {\n           _safeMint(recipient, mintIndexPublicSaleAndContributors++);\n       }\n   }\n\n   function withdraw() external onlyOwner {\n       uint256 balance = address(this).balance;\n       if(balance > 0){\n           Address.sendValue(payable(owner()), balance);\n       }\n       balance = IERC20(tokenContract).balanceOf(address(this));\n       if(balance > 0){\n           IERC20(tokenContract).safeTransfer(owner(), balance);\n       }\n   }\n\n   // Alpha/Beta Claim Methods\n   function flipClaimableState() external onlyOperator {\n       claimableActive = !claimableActive;\n       emit ClaimableStateChanged(claimableActive);\n   }\n\n   function nftOwnerClaimLand(uint256[] calldata alphaTokenIds, uint256[] calldata betaTokenIds) external whenClaimableActive {\n       require(alphaTokenIds.length > 0 || betaTokenIds.length > 0, \"Should claim at least one land\");\n       require(alphaTokenIds.length + betaTokenIds.length <= MAX_MINT_PER_BLOCK, \"Input length should be <= MAX_MINT_PER_BLOCK\");\n\n       alphaClaimLand(alphaTokenIds);\n       betaClaimLand(betaTokenIds);\n   }\n\n   function alphaClaimLand(uint256[] calldata alphaTokenIds) private {\n       for(uint256 i; i < alphaTokenIds.length; ++i){\n           uint256 alphaTokenId = alphaTokenIds[i];\n           require(!alphaClaimed[alphaTokenId], \"ALPHA NFT already claimed\");\n           require(ERC721(alphaContract).ownerOf(alphaTokenId) == msg.sender, \"Must own all of the alpha defined by alphaTokenIds\");\n           \n           alphaClaimLandByTokenId(alphaTokenId);    \n       }\n   }\n\n   function alphaClaimLandByTokenId(uint256 alphaTokenId) private {\n       alphaClaimed[alphaTokenId] = true;\n       ++alphaClaimedAmount;        \n       _safeMint(msg.sender, alphaTokenId);\n   }\n\n   function betaClaimLand(uint256[] calldata betaTokenIds) private {\n       for(uint256 i; i < betaTokenIds.length; ++i){\n           uint256 betaTokenId = betaTokenIds[i];\n           require(!betaClaimed[betaTokenId], \"BETA NFT already claimed\");\n           require(ERC721(betaContract).ownerOf(betaTokenId) == msg.sender, \"Must own all of the beta defined by betaTokenIds\");\n           \n           betaClaimLandByTokenId(betaTokenId);    \n       }\n   }\n\n   function betaClaimLandByTokenId(uint256 betaTokenId) private {\n       betaClaimed[betaTokenId] = true;\n       ++betaClaimedAmount;\n       _safeMint(msg.sender, betaNftIdCurrent++);\n   }\n\n   // Contributors Claim Methods\n   function startContributorsClaimPeriod() onlyOperator external {\n       require(!contributorsClaimActive, \"Contributors claim is already active\");\n       contributorsClaimActive = true;\n       emit ContributorsClaimStart(block.timestamp);\n   }\n\n   function stopContributorsClaimPeriod() onlyOperator external whenContributorsClaimActive {\n       contributorsClaimActive = false;\n       emit ContributorsClaimStop(block.timestamp);\n   }\n\n   function contributorsClaimLand(uint256 amount, address recipient) external onlyContributors(msg.sender) whenContributorsClaimActive {\n       require(amount > 0, \"Must mint at least one land\");\n       require(amount <= MAX_MINT_PER_BLOCK, \"amount should not exceed MAX_MINT_PER_BLOCK\");\n       mintLandsCommon(amount, recipient);\n   }\n\n   function claimUnclaimedAndUnsoldLands(address recipient) external onlyOwner {\n       claimUnclaimedAndUnsoldLandsWithAmount(recipient, MAX_MINT_PER_BLOCK);\n   }\n\n   function claimUnclaimedAndUnsoldLandsWithAmount(address recipient, uint256 maxAmount) public onlyOwner {\n       require (publicSaleStartTime > 0 && !claimableActive && !publicSaleActive && !contributorsClaimActive,\n           \"Cannot claim the unclaimed if claimable or public sale are active\");\n       require(maxAmount <= MAX_MINT_PER_BLOCK, \"maxAmount cannot exceed MAX_MINT_PER_BLOCK\");\n       require(alphaClaimedAmount < MAX_ALPHA_NFT_AMOUNT || betaClaimedAmount < MAX_BETA_NFT_AMOUNT\n                   || mintIndexPublicSaleAndContributors < MAX_LANDS, \"Max NFT amount already claimed or sold\");\n\n       uint256 totalMinted;\n       adminClaimStarted = true;\n       //claim beta\n       if(betaClaimedAmount < MAX_BETA_NFT_AMOUNT) {\n           uint256 leftToBeMinted = MAX_BETA_NFT_AMOUNT - betaClaimedAmount;\n           uint256 toMint = leftToBeMinted < maxAmount ? leftToBeMinted :\n               maxAmount; //take the min\n\n           uint256 target = betaNftIdCurrent + toMint;\n           for(; betaNftIdCurrent < target; ++betaNftIdCurrent){\n               ++betaClaimedAmount;\n               ++totalMinted;\n               _safeMint(recipient, betaNftIdCurrent);\n           }\n       }\n\n       //claim alpha\n       if(alphaClaimedAmount < MAX_ALPHA_NFT_AMOUNT) {\n           uint256 leftToBeMinted = MAX_ALPHA_NFT_AMOUNT - alphaClaimedAmount;\n           uint256 toMint = maxAmount < leftToBeMinted + totalMinted ?\n                           maxAmount :\n                           leftToBeMinted + totalMinted; //summing totalMinted avoid to use another counter\n           \n           uint256 lastAlphaNft = MAX_ALPHA_NFT_AMOUNT - 1;\n           for(uint256 i; i <= lastAlphaNft && totalMinted < toMint; ++i) {\n               if(!alphaClaimed[i]){\n                   ++alphaClaimedAmount;\n                   ++totalMinted;\n                   alphaClaimed[i] = true;\n                   _safeMint(recipient, i);\n               }\n           }\n       }\n\n       //claim unsold\n       if(mintIndexPublicSaleAndContributors < MAX_LANDS){\n           uint256 leftToBeMinted = MAX_LANDS - mintIndexPublicSaleAndContributors;\n           uint256 toMint = maxAmount < leftToBeMinted + totalMinted ?\n                           maxAmount :\n                           leftToBeMinted + totalMinted; //summing totalMinted avoid to use another counter\n\n           for(; mintIndexPublicSaleAndContributors < MAX_LANDS && totalMinted < toMint; ++mintIndexPublicSaleAndContributors) {\n                   ++totalMinted;\n                   _safeMint(recipient, mintIndexPublicSaleAndContributors);\n           }              \n       }\n   }\n\n   //future\n   function setFutureMinter(address _futureMinter) external onlyOwner {\n       futureMinter = _futureMinter;\n   }\n\n   function mintFutureLands(address recipient) external onlyFutureMinter {\n       mintFutureLandsWithAmount(recipient, MAX_MINT_PER_BLOCK);\n   }\n\n   function mintFutureLandsWithAmount(address recipient, uint256 maxAmount) public onlyFutureMinter {\n       require(maxAmount <= MAX_MINT_PER_BLOCK, \"maxAmount cannot exceed MAX_MINT_PER_BLOCK\");    \n       require(futureLandsNftIdCurrent < MAX_LANDS_WITH_FUTURE, \"All future lands were already minted\");\n       for(uint256 claimed; claimed < maxAmount && futureLandsNftIdCurrent < MAX_LANDS_WITH_FUTURE; ++claimed){\n           _safeMint(recipient, futureLandsNftIdCurrent++);\n       }\n   }\n   \n   // metadata\n   function loadLandMetadata(Metadata memory _landMetadata)\n       external onlyOperator checkMetadataRange(_landMetadata)\n       checkFirstMetadataRange(metadataHashes.length, _landMetadata.startIndex, _landMetadata.endIndex)\n   {\n       metadataHashes.push(_landMetadata);\n   }\n\n   function putLandMetadataAtIndex(uint256 index, Metadata memory _landMetadata)\n       external onlyOperator checkMetadataRange(_landMetadata)\n       checkFirstMetadataRange(index, _landMetadata.startIndex, _landMetadata.endIndex)\n   {\n       metadataHashes[index] = _landMetadata;\n   }    \n\n   // randomness\n   function requestRandomnessForPublicSaleAndContributors() external onlyOperator returns (bytes32 requestId) {\n       require(!publicSaleAndContributorsRandomnessRequested, \"Public Sale And Contributors Offset already requested\");\n       publicSaleAndContributorsRandomnessRequested = true;\n       requestId = requestRandomnessPrivate();\n       isRandomRequestForPublicSaleAndContributors[requestId] = true;\n   }\n\n   function requestRandomnessForOwnerClaim() external onlyOperator returns (bytes32 requestId) {\n       require(!ownerClaimRandomnessRequested, \"Owner Claim Offset already requested\");\n       ownerClaimRandomnessRequested = true;\n       requestId = requestRandomnessPrivate();\n       isRandomRequestForPublicSaleAndContributors[requestId] = false;\n   }\n\n   function requestRandomnessPrivate() private returns (bytes32 requestId) {\n       require(\n           LINK.balanceOf(address(this)) >= fee,\n           \"Not enough LINK\"\n       );\n       return requestRandomness(keyHash, fee);\n   }\n\n   function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n       if(isRandomRequestForPublicSaleAndContributors[requestId]){\n           publicSaleAndContributorsOffset = (randomness % (MAX_PUBLIC_SALE_AMOUNT + RESERVED_CONTRIBUTORS_AMOUNT));\n           emit StartingIndexSetPublicSale(publicSaleAndContributorsOffset);\n       } else {\n           alphaOffset = (randomness % MAX_ALPHA_NFT_AMOUNT);\n           betaOffset = (randomness % MAX_BETA_NFT_AMOUNT);\n           emit StartingIndexSetAlphaBeta(alphaOffset, betaOffset);\n       }\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "`mintLands`"
      },
      {
        "choice": "B",
        "answer": "`startPublicSale`"
      },
      {
        "choice": "C",
        "answer": "`contributorsClaimLand`"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C"
    ],
    "race": "RACE-6.md"
  },
  {
    "question": "5] The security concern(s) with _InSecureumLand_ contributors claim functions is/are",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumLand_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumLand_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n\ncontract InSecureumLand is ERC721Enumerable, Ownable, ReentrancyGuard, VRFConsumerBase {\n   using SafeERC20 for IERC20;\n\n   // attributes\n   string private baseURI;\n   address public operator;\n   bool public publicSaleActive;\n   uint256 public publicSaleStartTime;\n   uint256 public publicSalePriceLoweringDuration;\n   uint256 public publicSaleStartPrice;\n   uint256 public publicSaleEndingPrice;\n   uint256 public currentNumLandsMintedPublicSale;\n   uint256 public mintIndexPublicSaleAndContributors;\n   address public tokenContract;\n   bool private isKycCheckRequired;\n   bytes32 public kycMerkleRoot;\n   uint256 public maxMintPerTx;\n   uint256 public maxMintPerAddress;\n   mapping(address => uint256) public mintedPerAddress;\n   bool public claimableActive;\n   bool public adminClaimStarted;\n   address public alphaContract;\n   mapping(uint256 => bool) public alphaClaimed;\n   uint256 public alphaClaimedAmount;\n   address public betaContract;\n   mapping(uint256 => bool) public betaClaimed;\n   uint256 public betaClaimedAmount;\n   uint256 public betaNftIdCurrent;\n   bool public contributorsClaimActive;\n   mapping(address => uint256) public contributors;\n   uint256 public futureLandsNftIdCurrent;\n   address public futureMinter;\n   Metadata[] public metadataHashes;\n   bytes32 public keyHash;\n   uint256 public fee;\n   uint256 public publicSaleAndContributorsOffset;\n   uint256 public alphaOffset;\n   uint256 public betaOffset;\n   mapping(bytes32 => bool) public isRandomRequestForPublicSaleAndContributors;\n   bool public publicSaleAndContributorsRandomnessRequested;\n   bool public ownerClaimRandomnessRequested;\n   \n   // constants\n   uint256 immutable public MAX_LANDS;\n   uint256 immutable public MAX_LANDS_WITH_FUTURE;\n   uint256 immutable public MAX_ALPHA_NFT_AMOUNT;\n   uint256 immutable public MAX_BETA_NFT_AMOUNT;\n   uint256 immutable public MAX_PUBLIC_SALE_AMOUNT;\n   uint256 immutable public RESERVED_CONTRIBUTORS_AMOUNT;\n   uint256 immutable public MAX_FUTURE_LANDS;\n   uint256 constant public MAX_MINT_PER_BLOCK = 150;\n\n   // structs\n   struct LandAmount {\n       uint256 alpha;\n       uint256 beta;\n       uint256 publicSale;\n       uint256 future;\n   }\n\n   struct ContributorAmount {\n       address contributor;\n       uint256 amount;\n   }\n\n   struct Metadata {\n       bytes32 metadataHash;\n       bytes32 shuffledArrayHash;\n       uint256 startIndex;\n       uint256 endIndex;\n   }\n\n   struct ContractAddresses {\n       address alphaContract;\n       address betaContract;\n       address tokenContract;\n   }\n\n   // modifiers\n   modifier whenPublicSaleActive() {\n       require(publicSaleActive, \"Public sale is not active\");\n       _;\n   }\n\n   modifier whenContributorsClaimActive() {\n       require(contributorsClaimActive, \"Contributors Claim is not active\");\n       _;\n   }\n\n   modifier whenClaimableActive() {\n       require(claimableActive && !adminClaimStarted, \"Claimable state is not active\");\n       _;\n   }\n\n   modifier checkMetadataRange(Metadata memory _landMetadata){\n       require(_landMetadata.endIndex < MAX_LANDS_WITH_FUTURE, \"Range upper bound cannot exceed MAX_LANDS_WITH_FUTURE - 1\");\n       _;\n   }\n\n   modifier onlyContributors(address _contributor){\n       require(contributors[_contributor] >= 0, \"Only contributors can call this method\");\n       _;\n   }\n\n   modifier onlyOperator() {\n       require(operator == msg.sender , \"Only operator can call this method\");\n       _;\n   }\n\n   modifier onlyFutureMinter() {\n       require(futureMinter == msg.sender , \"Only futureMinter can call this method\");\n       _;\n   }\n\n   modifier checkFirstMetadataRange(uint256 index, uint256 startIndex, uint256 endIndex) {\n       if(index == 0){\n           require(startIndex == 0, \"For first metadata range lower bound should be 0\");\n           require(endIndex == MAX_LANDS - 1, \"For first metadata range upper bound should be MAX_LANDS - 1\");\n       }\n       _;\n   }\n\n   // events\n   event LandPublicSaleStart(\n       uint256 indexed _saleDuration,\n       uint256 indexed _saleStartTime\n   );\n   event LandPublicSaleStop(\n       uint256 indexed _currentPrice,\n       uint256 indexed _timeElapsed\n   );\n   event ClaimableStateChanged(bool indexed claimableActive);\n   event ContributorsClaimStart(uint256 _timestamp);\n   event ContributorsClaimStop(uint256 _timestamp);\n   event StartingIndexSetPublicSale(uint256 indexed _startingIndex);\n   event StartingIndexSetAlphaBeta(uint256 indexed _alphaOffset, uint256 indexed _betaOffset);\n   event PublicSaleMint(address indexed sender, uint256 indexed numLands, uint256 indexed mintPrice);\n\n   constructor(string memory name, string memory symbol,\n       ContractAddresses memory addresses,\n       LandAmount memory amount,\n       ContributorAmount[] memory _contributors,\n       address _vrfCoordinator, address _linkTokenAddress,\n       bytes32 _vrfKeyHash, uint256 _vrfFee,\n       address _operator\n   ) ERC721(name, symbol) VRFConsumerBase(_vrfCoordinator, _linkTokenAddress) {\n       alphaContract = addresses.alphaContract;\n       betaContract = addresses.betaContract;\n       tokenContract = addresses.tokenContract;\n\n       MAX_ALPHA_NFT_AMOUNT = amount.alpha;\n       MAX_BETA_NFT_AMOUNT = amount.beta;\n       MAX_PUBLIC_SALE_AMOUNT = amount.publicSale;\n       MAX_FUTURE_LANDS = amount.future;\n\n       betaNftIdCurrent = amount.alpha; //beta starts after alpha\n       mintIndexPublicSaleAndContributors = amount.alpha + amount.beta; //public sale starts after beta\n\n       uint256 tempSum;\n       for(uint256 i; i<_contributors.length; ++i){\n           contributors[_contributors[i].contributor] = _contributors[i].amount;\n           tempSum += _contributors[i].amount;\n       }\n       RESERVED_CONTRIBUTORS_AMOUNT = tempSum;\n       MAX_LANDS = amount.alpha + amount.beta + amount.publicSale + RESERVED_CONTRIBUTORS_AMOUNT;\n       MAX_LANDS_WITH_FUTURE = MAX_LANDS + amount.future;\n       futureLandsNftIdCurrent = MAX_LANDS; //future starts after public sale\n       keyHash  = _vrfKeyHash;\n       fee = _vrfFee;\n       operator = _operator;\n   }\n\n   function _baseURI() internal view override returns (string memory) {\n       return baseURI;\n   }\n\n   function setBaseURI(string memory uri) external onlyOperator {\n       baseURI = uri;\n   }\n\n   function setOperator(address _operator) external onlyOwner {\n       operator = _operator;\n   }\n\n   function setMaxMintPerTx(uint256 _maxMintPerTx) external onlyOperator {\n       maxMintPerTx = _maxMintPerTx;\n   }\n\n   function setMaxMintPerAddress(uint256 _maxMintPerAddress) external onlyOperator {\n       maxMintPerAddress = _maxMintPerAddress;\n   }\n\n   function setKycCheckRequired(bool _isKycCheckRequired) external onlyOperator {\n       isKycCheckRequired = _isKycCheckRequired;\n   }\n\n   function setKycMerkleRoot(bytes32 _kycMerkleRoot) external onlyOperator {\n       kycMerkleRoot = _kycMerkleRoot;\n   }\n\n   // Public Sale Methods\n   function startPublicSale(\n       uint256 _publicSalePriceLoweringDuration,\n       uint256 _publicSaleStartPrice,\n       uint256 _publicSaleEndingPrice,\n       uint256 _maxMintPerTx,\n       uint256 _maxMintPerAddress,\n       bool _isKycCheckRequired\n   ) external onlyOperator {\n       require(!publicSaleActive, \"Public sale has already begun\");\n       \n       publicSalePriceLoweringDuration = _publicSalePriceLoweringDuration;\n       publicSaleStartPrice = _publicSaleStartPrice;\n       publicSaleEndingPrice = _publicSaleEndingPrice;\n       publicSaleStartTime = block.timestamp;\n       publicSaleActive = true;\n\n       maxMintPerTx = _maxMintPerTx;\n       maxMintPerAddress = _maxMintPerAddress;\n       isKycCheckRequired = _isKycCheckRequired;\n       emit LandPublicSaleStart(publicSalePriceLoweringDuration, publicSaleStartTime);\n   }\n\n   function stopPublicSale() external onlyOperator whenPublicSaleActive {\n       emit LandPublicSaleStop(getMintPrice(), getElapsedSaleTime());\n       publicSaleActive = false;\n   }\n\n   function getElapsedSaleTime() private view returns (uint256) {\n       return publicSaleStartTime > 0 ? block.timestamp - publicSaleStartTime : 0;\n   }\n\n   function getMintPrice() public view whenPublicSaleActive returns (uint256) {\n       uint256 elapsed = getElapsedSaleTime();\n       uint256 price;\n       if(elapsed < publicSalePriceLoweringDuration) {\n           // Linear decreasing function\n           price =\n               publicSaleStartPrice -\n                   ( ( publicSaleStartPrice - publicSaleEndingPrice ) * elapsed ) / publicSalePriceLoweringDuration ;\n       } else {\n           price = publicSaleEndingPrice;\n       }\n       return price;\n   }\n\n   function mintLands(uint256 numLands, bytes32[] calldata merkleProof) external whenPublicSaleActive nonReentrant {\n       require(numLands > 0, \"Must mint at least one beta\");\n       require(currentNumLandsMintedPublicSale + numLands <= MAX_PUBLIC_SALE_AMOUNT, \"Minting would exceed max supply\");\n       require(numLands <= maxMintPerTx, \"numLands should not exceed maxMintPerTx\");\n       require(numLands + mintedPerAddress[msg.sender] <= maxMintPerAddress, \"sender address cannot mint more than maxMintPerAddress lands\");\n       if(isKycCheckRequired) {\n           require(MerkleProof.verify(merkleProof, kycMerkleRoot, keccak256(abi.encodePacked(msg.sender))), \"Sender address is not in KYC allowlist\");\n       } else {\n           require(msg.sender == tx.origin, \"Minting from smart contracts is disallowed\");\n       }\n   \n       uint256 mintPrice = getMintPrice();\n       IERC20(tokenContract).safeTransferFrom(msg.sender, address(this), mintPrice * numLands);\n       mintedPerAddress[msg.sender] += numLands;\n       emit PublicSaleMint(msg.sender, numLands, mintPrice);\n       mintLandsCommon(numLands, msg.sender);\n   }\n\n   function mintLandsCommon(uint256 numLands, address recipient) private {\n       for (uint256 i; i < numLands; ++i) {\n           _safeMint(recipient, mintIndexPublicSaleAndContributors++);\n       }\n   }\n\n   function withdraw() external onlyOwner {\n       uint256 balance = address(this).balance;\n       if(balance > 0){\n           Address.sendValue(payable(owner()), balance);\n       }\n       balance = IERC20(tokenContract).balanceOf(address(this));\n       if(balance > 0){\n           IERC20(tokenContract).safeTransfer(owner(), balance);\n       }\n   }\n\n   // Alpha/Beta Claim Methods\n   function flipClaimableState() external onlyOperator {\n       claimableActive = !claimableActive;\n       emit ClaimableStateChanged(claimableActive);\n   }\n\n   function nftOwnerClaimLand(uint256[] calldata alphaTokenIds, uint256[] calldata betaTokenIds) external whenClaimableActive {\n       require(alphaTokenIds.length > 0 || betaTokenIds.length > 0, \"Should claim at least one land\");\n       require(alphaTokenIds.length + betaTokenIds.length <= MAX_MINT_PER_BLOCK, \"Input length should be <= MAX_MINT_PER_BLOCK\");\n\n       alphaClaimLand(alphaTokenIds);\n       betaClaimLand(betaTokenIds);\n   }\n\n   function alphaClaimLand(uint256[] calldata alphaTokenIds) private {\n       for(uint256 i; i < alphaTokenIds.length; ++i){\n           uint256 alphaTokenId = alphaTokenIds[i];\n           require(!alphaClaimed[alphaTokenId], \"ALPHA NFT already claimed\");\n           require(ERC721(alphaContract).ownerOf(alphaTokenId) == msg.sender, \"Must own all of the alpha defined by alphaTokenIds\");\n           \n           alphaClaimLandByTokenId(alphaTokenId);    \n       }\n   }\n\n   function alphaClaimLandByTokenId(uint256 alphaTokenId) private {\n       alphaClaimed[alphaTokenId] = true;\n       ++alphaClaimedAmount;        \n       _safeMint(msg.sender, alphaTokenId);\n   }\n\n   function betaClaimLand(uint256[] calldata betaTokenIds) private {\n       for(uint256 i; i < betaTokenIds.length; ++i){\n           uint256 betaTokenId = betaTokenIds[i];\n           require(!betaClaimed[betaTokenId], \"BETA NFT already claimed\");\n           require(ERC721(betaContract).ownerOf(betaTokenId) == msg.sender, \"Must own all of the beta defined by betaTokenIds\");\n           \n           betaClaimLandByTokenId(betaTokenId);    \n       }\n   }\n\n   function betaClaimLandByTokenId(uint256 betaTokenId) private {\n       betaClaimed[betaTokenId] = true;\n       ++betaClaimedAmount;\n       _safeMint(msg.sender, betaNftIdCurrent++);\n   }\n\n   // Contributors Claim Methods\n   function startContributorsClaimPeriod() onlyOperator external {\n       require(!contributorsClaimActive, \"Contributors claim is already active\");\n       contributorsClaimActive = true;\n       emit ContributorsClaimStart(block.timestamp);\n   }\n\n   function stopContributorsClaimPeriod() onlyOperator external whenContributorsClaimActive {\n       contributorsClaimActive = false;\n       emit ContributorsClaimStop(block.timestamp);\n   }\n\n   function contributorsClaimLand(uint256 amount, address recipient) external onlyContributors(msg.sender) whenContributorsClaimActive {\n       require(amount > 0, \"Must mint at least one land\");\n       require(amount <= MAX_MINT_PER_BLOCK, \"amount should not exceed MAX_MINT_PER_BLOCK\");\n       mintLandsCommon(amount, recipient);\n   }\n\n   function claimUnclaimedAndUnsoldLands(address recipient) external onlyOwner {\n       claimUnclaimedAndUnsoldLandsWithAmount(recipient, MAX_MINT_PER_BLOCK);\n   }\n\n   function claimUnclaimedAndUnsoldLandsWithAmount(address recipient, uint256 maxAmount) public onlyOwner {\n       require (publicSaleStartTime > 0 && !claimableActive && !publicSaleActive && !contributorsClaimActive,\n           \"Cannot claim the unclaimed if claimable or public sale are active\");\n       require(maxAmount <= MAX_MINT_PER_BLOCK, \"maxAmount cannot exceed MAX_MINT_PER_BLOCK\");\n       require(alphaClaimedAmount < MAX_ALPHA_NFT_AMOUNT || betaClaimedAmount < MAX_BETA_NFT_AMOUNT\n                   || mintIndexPublicSaleAndContributors < MAX_LANDS, \"Max NFT amount already claimed or sold\");\n\n       uint256 totalMinted;\n       adminClaimStarted = true;\n       //claim beta\n       if(betaClaimedAmount < MAX_BETA_NFT_AMOUNT) {\n           uint256 leftToBeMinted = MAX_BETA_NFT_AMOUNT - betaClaimedAmount;\n           uint256 toMint = leftToBeMinted < maxAmount ? leftToBeMinted :\n               maxAmount; //take the min\n\n           uint256 target = betaNftIdCurrent + toMint;\n           for(; betaNftIdCurrent < target; ++betaNftIdCurrent){\n               ++betaClaimedAmount;\n               ++totalMinted;\n               _safeMint(recipient, betaNftIdCurrent);\n           }\n       }\n\n       //claim alpha\n       if(alphaClaimedAmount < MAX_ALPHA_NFT_AMOUNT) {\n           uint256 leftToBeMinted = MAX_ALPHA_NFT_AMOUNT - alphaClaimedAmount;\n           uint256 toMint = maxAmount < leftToBeMinted + totalMinted ?\n                           maxAmount :\n                           leftToBeMinted + totalMinted; //summing totalMinted avoid to use another counter\n           \n           uint256 lastAlphaNft = MAX_ALPHA_NFT_AMOUNT - 1;\n           for(uint256 i; i <= lastAlphaNft && totalMinted < toMint; ++i) {\n               if(!alphaClaimed[i]){\n                   ++alphaClaimedAmount;\n                   ++totalMinted;\n                   alphaClaimed[i] = true;\n                   _safeMint(recipient, i);\n               }\n           }\n       }\n\n       //claim unsold\n       if(mintIndexPublicSaleAndContributors < MAX_LANDS){\n           uint256 leftToBeMinted = MAX_LANDS - mintIndexPublicSaleAndContributors;\n           uint256 toMint = maxAmount < leftToBeMinted + totalMinted ?\n                           maxAmount :\n                           leftToBeMinted + totalMinted; //summing totalMinted avoid to use another counter\n\n           for(; mintIndexPublicSaleAndContributors < MAX_LANDS && totalMinted < toMint; ++mintIndexPublicSaleAndContributors) {\n                   ++totalMinted;\n                   _safeMint(recipient, mintIndexPublicSaleAndContributors);\n           }              \n       }\n   }\n\n   //future\n   function setFutureMinter(address _futureMinter) external onlyOwner {\n       futureMinter = _futureMinter;\n   }\n\n   function mintFutureLands(address recipient) external onlyFutureMinter {\n       mintFutureLandsWithAmount(recipient, MAX_MINT_PER_BLOCK);\n   }\n\n   function mintFutureLandsWithAmount(address recipient, uint256 maxAmount) public onlyFutureMinter {\n       require(maxAmount <= MAX_MINT_PER_BLOCK, \"maxAmount cannot exceed MAX_MINT_PER_BLOCK\");    \n       require(futureLandsNftIdCurrent < MAX_LANDS_WITH_FUTURE, \"All future lands were already minted\");\n       for(uint256 claimed; claimed < maxAmount && futureLandsNftIdCurrent < MAX_LANDS_WITH_FUTURE; ++claimed){\n           _safeMint(recipient, futureLandsNftIdCurrent++);\n       }\n   }\n   \n   // metadata\n   function loadLandMetadata(Metadata memory _landMetadata)\n       external onlyOperator checkMetadataRange(_landMetadata)\n       checkFirstMetadataRange(metadataHashes.length, _landMetadata.startIndex, _landMetadata.endIndex)\n   {\n       metadataHashes.push(_landMetadata);\n   }\n\n   function putLandMetadataAtIndex(uint256 index, Metadata memory _landMetadata)\n       external onlyOperator checkMetadataRange(_landMetadata)\n       checkFirstMetadataRange(index, _landMetadata.startIndex, _landMetadata.endIndex)\n   {\n       metadataHashes[index] = _landMetadata;\n   }    \n\n   // randomness\n   function requestRandomnessForPublicSaleAndContributors() external onlyOperator returns (bytes32 requestId) {\n       require(!publicSaleAndContributorsRandomnessRequested, \"Public Sale And Contributors Offset already requested\");\n       publicSaleAndContributorsRandomnessRequested = true;\n       requestId = requestRandomnessPrivate();\n       isRandomRequestForPublicSaleAndContributors[requestId] = true;\n   }\n\n   function requestRandomnessForOwnerClaim() external onlyOperator returns (bytes32 requestId) {\n       require(!ownerClaimRandomnessRequested, \"Owner Claim Offset already requested\");\n       ownerClaimRandomnessRequested = true;\n       requestId = requestRandomnessPrivate();\n       isRandomRequestForPublicSaleAndContributors[requestId] = false;\n   }\n\n   function requestRandomnessPrivate() private returns (bytes32 requestId) {\n       require(\n           LINK.balanceOf(address(this)) >= fee,\n           \"Not enough LINK\"\n       );\n       return requestRandomness(keyHash, fee);\n   }\n\n   function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n       if(isRandomRequestForPublicSaleAndContributors[requestId]){\n           publicSaleAndContributorsOffset = (randomness % (MAX_PUBLIC_SALE_AMOUNT + RESERVED_CONTRIBUTORS_AMOUNT));\n           emit StartingIndexSetPublicSale(publicSaleAndContributorsOffset);\n       } else {\n           alphaOffset = (randomness % MAX_ALPHA_NFT_AMOUNT);\n           betaOffset = (randomness % MAX_BETA_NFT_AMOUNT);\n           emit StartingIndexSetAlphaBeta(alphaOffset, betaOffset);\n       }\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Anyone can call `startContributorsClaimPeriod`"
      },
      {
        "choice": "B",
        "answer": "Anyone can call `stopContributorsClaimPeriod`"
      },
      {
        "choice": "C",
        "answer": "Anyone can call `contributorsClaimLand`"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-6.md"
  },
  {
    "question": "6] The security concern(s) with _InSecureumLand_ random number usage is/are",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumLand_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumLand_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n\ncontract InSecureumLand is ERC721Enumerable, Ownable, ReentrancyGuard, VRFConsumerBase {\n   using SafeERC20 for IERC20;\n\n   // attributes\n   string private baseURI;\n   address public operator;\n   bool public publicSaleActive;\n   uint256 public publicSaleStartTime;\n   uint256 public publicSalePriceLoweringDuration;\n   uint256 public publicSaleStartPrice;\n   uint256 public publicSaleEndingPrice;\n   uint256 public currentNumLandsMintedPublicSale;\n   uint256 public mintIndexPublicSaleAndContributors;\n   address public tokenContract;\n   bool private isKycCheckRequired;\n   bytes32 public kycMerkleRoot;\n   uint256 public maxMintPerTx;\n   uint256 public maxMintPerAddress;\n   mapping(address => uint256) public mintedPerAddress;\n   bool public claimableActive;\n   bool public adminClaimStarted;\n   address public alphaContract;\n   mapping(uint256 => bool) public alphaClaimed;\n   uint256 public alphaClaimedAmount;\n   address public betaContract;\n   mapping(uint256 => bool) public betaClaimed;\n   uint256 public betaClaimedAmount;\n   uint256 public betaNftIdCurrent;\n   bool public contributorsClaimActive;\n   mapping(address => uint256) public contributors;\n   uint256 public futureLandsNftIdCurrent;\n   address public futureMinter;\n   Metadata[] public metadataHashes;\n   bytes32 public keyHash;\n   uint256 public fee;\n   uint256 public publicSaleAndContributorsOffset;\n   uint256 public alphaOffset;\n   uint256 public betaOffset;\n   mapping(bytes32 => bool) public isRandomRequestForPublicSaleAndContributors;\n   bool public publicSaleAndContributorsRandomnessRequested;\n   bool public ownerClaimRandomnessRequested;\n   \n   // constants\n   uint256 immutable public MAX_LANDS;\n   uint256 immutable public MAX_LANDS_WITH_FUTURE;\n   uint256 immutable public MAX_ALPHA_NFT_AMOUNT;\n   uint256 immutable public MAX_BETA_NFT_AMOUNT;\n   uint256 immutable public MAX_PUBLIC_SALE_AMOUNT;\n   uint256 immutable public RESERVED_CONTRIBUTORS_AMOUNT;\n   uint256 immutable public MAX_FUTURE_LANDS;\n   uint256 constant public MAX_MINT_PER_BLOCK = 150;\n\n   // structs\n   struct LandAmount {\n       uint256 alpha;\n       uint256 beta;\n       uint256 publicSale;\n       uint256 future;\n   }\n\n   struct ContributorAmount {\n       address contributor;\n       uint256 amount;\n   }\n\n   struct Metadata {\n       bytes32 metadataHash;\n       bytes32 shuffledArrayHash;\n       uint256 startIndex;\n       uint256 endIndex;\n   }\n\n   struct ContractAddresses {\n       address alphaContract;\n       address betaContract;\n       address tokenContract;\n   }\n\n   // modifiers\n   modifier whenPublicSaleActive() {\n       require(publicSaleActive, \"Public sale is not active\");\n       _;\n   }\n\n   modifier whenContributorsClaimActive() {\n       require(contributorsClaimActive, \"Contributors Claim is not active\");\n       _;\n   }\n\n   modifier whenClaimableActive() {\n       require(claimableActive && !adminClaimStarted, \"Claimable state is not active\");\n       _;\n   }\n\n   modifier checkMetadataRange(Metadata memory _landMetadata){\n       require(_landMetadata.endIndex < MAX_LANDS_WITH_FUTURE, \"Range upper bound cannot exceed MAX_LANDS_WITH_FUTURE - 1\");\n       _;\n   }\n\n   modifier onlyContributors(address _contributor){\n       require(contributors[_contributor] >= 0, \"Only contributors can call this method\");\n       _;\n   }\n\n   modifier onlyOperator() {\n       require(operator == msg.sender , \"Only operator can call this method\");\n       _;\n   }\n\n   modifier onlyFutureMinter() {\n       require(futureMinter == msg.sender , \"Only futureMinter can call this method\");\n       _;\n   }\n\n   modifier checkFirstMetadataRange(uint256 index, uint256 startIndex, uint256 endIndex) {\n       if(index == 0){\n           require(startIndex == 0, \"For first metadata range lower bound should be 0\");\n           require(endIndex == MAX_LANDS - 1, \"For first metadata range upper bound should be MAX_LANDS - 1\");\n       }\n       _;\n   }\n\n   // events\n   event LandPublicSaleStart(\n       uint256 indexed _saleDuration,\n       uint256 indexed _saleStartTime\n   );\n   event LandPublicSaleStop(\n       uint256 indexed _currentPrice,\n       uint256 indexed _timeElapsed\n   );\n   event ClaimableStateChanged(bool indexed claimableActive);\n   event ContributorsClaimStart(uint256 _timestamp);\n   event ContributorsClaimStop(uint256 _timestamp);\n   event StartingIndexSetPublicSale(uint256 indexed _startingIndex);\n   event StartingIndexSetAlphaBeta(uint256 indexed _alphaOffset, uint256 indexed _betaOffset);\n   event PublicSaleMint(address indexed sender, uint256 indexed numLands, uint256 indexed mintPrice);\n\n   constructor(string memory name, string memory symbol,\n       ContractAddresses memory addresses,\n       LandAmount memory amount,\n       ContributorAmount[] memory _contributors,\n       address _vrfCoordinator, address _linkTokenAddress,\n       bytes32 _vrfKeyHash, uint256 _vrfFee,\n       address _operator\n   ) ERC721(name, symbol) VRFConsumerBase(_vrfCoordinator, _linkTokenAddress) {\n       alphaContract = addresses.alphaContract;\n       betaContract = addresses.betaContract;\n       tokenContract = addresses.tokenContract;\n\n       MAX_ALPHA_NFT_AMOUNT = amount.alpha;\n       MAX_BETA_NFT_AMOUNT = amount.beta;\n       MAX_PUBLIC_SALE_AMOUNT = amount.publicSale;\n       MAX_FUTURE_LANDS = amount.future;\n\n       betaNftIdCurrent = amount.alpha; //beta starts after alpha\n       mintIndexPublicSaleAndContributors = amount.alpha + amount.beta; //public sale starts after beta\n\n       uint256 tempSum;\n       for(uint256 i; i<_contributors.length; ++i){\n           contributors[_contributors[i].contributor] = _contributors[i].amount;\n           tempSum += _contributors[i].amount;\n       }\n       RESERVED_CONTRIBUTORS_AMOUNT = tempSum;\n       MAX_LANDS = amount.alpha + amount.beta + amount.publicSale + RESERVED_CONTRIBUTORS_AMOUNT;\n       MAX_LANDS_WITH_FUTURE = MAX_LANDS + amount.future;\n       futureLandsNftIdCurrent = MAX_LANDS; //future starts after public sale\n       keyHash  = _vrfKeyHash;\n       fee = _vrfFee;\n       operator = _operator;\n   }\n\n   function _baseURI() internal view override returns (string memory) {\n       return baseURI;\n   }\n\n   function setBaseURI(string memory uri) external onlyOperator {\n       baseURI = uri;\n   }\n\n   function setOperator(address _operator) external onlyOwner {\n       operator = _operator;\n   }\n\n   function setMaxMintPerTx(uint256 _maxMintPerTx) external onlyOperator {\n       maxMintPerTx = _maxMintPerTx;\n   }\n\n   function setMaxMintPerAddress(uint256 _maxMintPerAddress) external onlyOperator {\n       maxMintPerAddress = _maxMintPerAddress;\n   }\n\n   function setKycCheckRequired(bool _isKycCheckRequired) external onlyOperator {\n       isKycCheckRequired = _isKycCheckRequired;\n   }\n\n   function setKycMerkleRoot(bytes32 _kycMerkleRoot) external onlyOperator {\n       kycMerkleRoot = _kycMerkleRoot;\n   }\n\n   // Public Sale Methods\n   function startPublicSale(\n       uint256 _publicSalePriceLoweringDuration,\n       uint256 _publicSaleStartPrice,\n       uint256 _publicSaleEndingPrice,\n       uint256 _maxMintPerTx,\n       uint256 _maxMintPerAddress,\n       bool _isKycCheckRequired\n   ) external onlyOperator {\n       require(!publicSaleActive, \"Public sale has already begun\");\n       \n       publicSalePriceLoweringDuration = _publicSalePriceLoweringDuration;\n       publicSaleStartPrice = _publicSaleStartPrice;\n       publicSaleEndingPrice = _publicSaleEndingPrice;\n       publicSaleStartTime = block.timestamp;\n       publicSaleActive = true;\n\n       maxMintPerTx = _maxMintPerTx;\n       maxMintPerAddress = _maxMintPerAddress;\n       isKycCheckRequired = _isKycCheckRequired;\n       emit LandPublicSaleStart(publicSalePriceLoweringDuration, publicSaleStartTime);\n   }\n\n   function stopPublicSale() external onlyOperator whenPublicSaleActive {\n       emit LandPublicSaleStop(getMintPrice(), getElapsedSaleTime());\n       publicSaleActive = false;\n   }\n\n   function getElapsedSaleTime() private view returns (uint256) {\n       return publicSaleStartTime > 0 ? block.timestamp - publicSaleStartTime : 0;\n   }\n\n   function getMintPrice() public view whenPublicSaleActive returns (uint256) {\n       uint256 elapsed = getElapsedSaleTime();\n       uint256 price;\n       if(elapsed < publicSalePriceLoweringDuration) {\n           // Linear decreasing function\n           price =\n               publicSaleStartPrice -\n                   ( ( publicSaleStartPrice - publicSaleEndingPrice ) * elapsed ) / publicSalePriceLoweringDuration ;\n       } else {\n           price = publicSaleEndingPrice;\n       }\n       return price;\n   }\n\n   function mintLands(uint256 numLands, bytes32[] calldata merkleProof) external whenPublicSaleActive nonReentrant {\n       require(numLands > 0, \"Must mint at least one beta\");\n       require(currentNumLandsMintedPublicSale + numLands <= MAX_PUBLIC_SALE_AMOUNT, \"Minting would exceed max supply\");\n       require(numLands <= maxMintPerTx, \"numLands should not exceed maxMintPerTx\");\n       require(numLands + mintedPerAddress[msg.sender] <= maxMintPerAddress, \"sender address cannot mint more than maxMintPerAddress lands\");\n       if(isKycCheckRequired) {\n           require(MerkleProof.verify(merkleProof, kycMerkleRoot, keccak256(abi.encodePacked(msg.sender))), \"Sender address is not in KYC allowlist\");\n       } else {\n           require(msg.sender == tx.origin, \"Minting from smart contracts is disallowed\");\n       }\n   \n       uint256 mintPrice = getMintPrice();\n       IERC20(tokenContract).safeTransferFrom(msg.sender, address(this), mintPrice * numLands);\n       mintedPerAddress[msg.sender] += numLands;\n       emit PublicSaleMint(msg.sender, numLands, mintPrice);\n       mintLandsCommon(numLands, msg.sender);\n   }\n\n   function mintLandsCommon(uint256 numLands, address recipient) private {\n       for (uint256 i; i < numLands; ++i) {\n           _safeMint(recipient, mintIndexPublicSaleAndContributors++);\n       }\n   }\n\n   function withdraw() external onlyOwner {\n       uint256 balance = address(this).balance;\n       if(balance > 0){\n           Address.sendValue(payable(owner()), balance);\n       }\n       balance = IERC20(tokenContract).balanceOf(address(this));\n       if(balance > 0){\n           IERC20(tokenContract).safeTransfer(owner(), balance);\n       }\n   }\n\n   // Alpha/Beta Claim Methods\n   function flipClaimableState() external onlyOperator {\n       claimableActive = !claimableActive;\n       emit ClaimableStateChanged(claimableActive);\n   }\n\n   function nftOwnerClaimLand(uint256[] calldata alphaTokenIds, uint256[] calldata betaTokenIds) external whenClaimableActive {\n       require(alphaTokenIds.length > 0 || betaTokenIds.length > 0, \"Should claim at least one land\");\n       require(alphaTokenIds.length + betaTokenIds.length <= MAX_MINT_PER_BLOCK, \"Input length should be <= MAX_MINT_PER_BLOCK\");\n\n       alphaClaimLand(alphaTokenIds);\n       betaClaimLand(betaTokenIds);\n   }\n\n   function alphaClaimLand(uint256[] calldata alphaTokenIds) private {\n       for(uint256 i; i < alphaTokenIds.length; ++i){\n           uint256 alphaTokenId = alphaTokenIds[i];\n           require(!alphaClaimed[alphaTokenId], \"ALPHA NFT already claimed\");\n           require(ERC721(alphaContract).ownerOf(alphaTokenId) == msg.sender, \"Must own all of the alpha defined by alphaTokenIds\");\n           \n           alphaClaimLandByTokenId(alphaTokenId);    \n       }\n   }\n\n   function alphaClaimLandByTokenId(uint256 alphaTokenId) private {\n       alphaClaimed[alphaTokenId] = true;\n       ++alphaClaimedAmount;        \n       _safeMint(msg.sender, alphaTokenId);\n   }\n\n   function betaClaimLand(uint256[] calldata betaTokenIds) private {\n       for(uint256 i; i < betaTokenIds.length; ++i){\n           uint256 betaTokenId = betaTokenIds[i];\n           require(!betaClaimed[betaTokenId], \"BETA NFT already claimed\");\n           require(ERC721(betaContract).ownerOf(betaTokenId) == msg.sender, \"Must own all of the beta defined by betaTokenIds\");\n           \n           betaClaimLandByTokenId(betaTokenId);    \n       }\n   }\n\n   function betaClaimLandByTokenId(uint256 betaTokenId) private {\n       betaClaimed[betaTokenId] = true;\n       ++betaClaimedAmount;\n       _safeMint(msg.sender, betaNftIdCurrent++);\n   }\n\n   // Contributors Claim Methods\n   function startContributorsClaimPeriod() onlyOperator external {\n       require(!contributorsClaimActive, \"Contributors claim is already active\");\n       contributorsClaimActive = true;\n       emit ContributorsClaimStart(block.timestamp);\n   }\n\n   function stopContributorsClaimPeriod() onlyOperator external whenContributorsClaimActive {\n       contributorsClaimActive = false;\n       emit ContributorsClaimStop(block.timestamp);\n   }\n\n   function contributorsClaimLand(uint256 amount, address recipient) external onlyContributors(msg.sender) whenContributorsClaimActive {\n       require(amount > 0, \"Must mint at least one land\");\n       require(amount <= MAX_MINT_PER_BLOCK, \"amount should not exceed MAX_MINT_PER_BLOCK\");\n       mintLandsCommon(amount, recipient);\n   }\n\n   function claimUnclaimedAndUnsoldLands(address recipient) external onlyOwner {\n       claimUnclaimedAndUnsoldLandsWithAmount(recipient, MAX_MINT_PER_BLOCK);\n   }\n\n   function claimUnclaimedAndUnsoldLandsWithAmount(address recipient, uint256 maxAmount) public onlyOwner {\n       require (publicSaleStartTime > 0 && !claimableActive && !publicSaleActive && !contributorsClaimActive,\n           \"Cannot claim the unclaimed if claimable or public sale are active\");\n       require(maxAmount <= MAX_MINT_PER_BLOCK, \"maxAmount cannot exceed MAX_MINT_PER_BLOCK\");\n       require(alphaClaimedAmount < MAX_ALPHA_NFT_AMOUNT || betaClaimedAmount < MAX_BETA_NFT_AMOUNT\n                   || mintIndexPublicSaleAndContributors < MAX_LANDS, \"Max NFT amount already claimed or sold\");\n\n       uint256 totalMinted;\n       adminClaimStarted = true;\n       //claim beta\n       if(betaClaimedAmount < MAX_BETA_NFT_AMOUNT) {\n           uint256 leftToBeMinted = MAX_BETA_NFT_AMOUNT - betaClaimedAmount;\n           uint256 toMint = leftToBeMinted < maxAmount ? leftToBeMinted :\n               maxAmount; //take the min\n\n           uint256 target = betaNftIdCurrent + toMint;\n           for(; betaNftIdCurrent < target; ++betaNftIdCurrent){\n               ++betaClaimedAmount;\n               ++totalMinted;\n               _safeMint(recipient, betaNftIdCurrent);\n           }\n       }\n\n       //claim alpha\n       if(alphaClaimedAmount < MAX_ALPHA_NFT_AMOUNT) {\n           uint256 leftToBeMinted = MAX_ALPHA_NFT_AMOUNT - alphaClaimedAmount;\n           uint256 toMint = maxAmount < leftToBeMinted + totalMinted ?\n                           maxAmount :\n                           leftToBeMinted + totalMinted; //summing totalMinted avoid to use another counter\n           \n           uint256 lastAlphaNft = MAX_ALPHA_NFT_AMOUNT - 1;\n           for(uint256 i; i <= lastAlphaNft && totalMinted < toMint; ++i) {\n               if(!alphaClaimed[i]){\n                   ++alphaClaimedAmount;\n                   ++totalMinted;\n                   alphaClaimed[i] = true;\n                   _safeMint(recipient, i);\n               }\n           }\n       }\n\n       //claim unsold\n       if(mintIndexPublicSaleAndContributors < MAX_LANDS){\n           uint256 leftToBeMinted = MAX_LANDS - mintIndexPublicSaleAndContributors;\n           uint256 toMint = maxAmount < leftToBeMinted + totalMinted ?\n                           maxAmount :\n                           leftToBeMinted + totalMinted; //summing totalMinted avoid to use another counter\n\n           for(; mintIndexPublicSaleAndContributors < MAX_LANDS && totalMinted < toMint; ++mintIndexPublicSaleAndContributors) {\n                   ++totalMinted;\n                   _safeMint(recipient, mintIndexPublicSaleAndContributors);\n           }              \n       }\n   }\n\n   //future\n   function setFutureMinter(address _futureMinter) external onlyOwner {\n       futureMinter = _futureMinter;\n   }\n\n   function mintFutureLands(address recipient) external onlyFutureMinter {\n       mintFutureLandsWithAmount(recipient, MAX_MINT_PER_BLOCK);\n   }\n\n   function mintFutureLandsWithAmount(address recipient, uint256 maxAmount) public onlyFutureMinter {\n       require(maxAmount <= MAX_MINT_PER_BLOCK, \"maxAmount cannot exceed MAX_MINT_PER_BLOCK\");    \n       require(futureLandsNftIdCurrent < MAX_LANDS_WITH_FUTURE, \"All future lands were already minted\");\n       for(uint256 claimed; claimed < maxAmount && futureLandsNftIdCurrent < MAX_LANDS_WITH_FUTURE; ++claimed){\n           _safeMint(recipient, futureLandsNftIdCurrent++);\n       }\n   }\n   \n   // metadata\n   function loadLandMetadata(Metadata memory _landMetadata)\n       external onlyOperator checkMetadataRange(_landMetadata)\n       checkFirstMetadataRange(metadataHashes.length, _landMetadata.startIndex, _landMetadata.endIndex)\n   {\n       metadataHashes.push(_landMetadata);\n   }\n\n   function putLandMetadataAtIndex(uint256 index, Metadata memory _landMetadata)\n       external onlyOperator checkMetadataRange(_landMetadata)\n       checkFirstMetadataRange(index, _landMetadata.startIndex, _landMetadata.endIndex)\n   {\n       metadataHashes[index] = _landMetadata;\n   }    \n\n   // randomness\n   function requestRandomnessForPublicSaleAndContributors() external onlyOperator returns (bytes32 requestId) {\n       require(!publicSaleAndContributorsRandomnessRequested, \"Public Sale And Contributors Offset already requested\");\n       publicSaleAndContributorsRandomnessRequested = true;\n       requestId = requestRandomnessPrivate();\n       isRandomRequestForPublicSaleAndContributors[requestId] = true;\n   }\n\n   function requestRandomnessForOwnerClaim() external onlyOperator returns (bytes32 requestId) {\n       require(!ownerClaimRandomnessRequested, \"Owner Claim Offset already requested\");\n       ownerClaimRandomnessRequested = true;\n       requestId = requestRandomnessPrivate();\n       isRandomRequestForPublicSaleAndContributors[requestId] = false;\n   }\n\n   function requestRandomnessPrivate() private returns (bytes32 requestId) {\n       require(\n           LINK.balanceOf(address(this)) >= fee,\n           \"Not enough LINK\"\n       );\n       return requestRandomness(keyHash, fee);\n   }\n\n   function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n       if(isRandomRequestForPublicSaleAndContributors[requestId]){\n           publicSaleAndContributorsOffset = (randomness % (MAX_PUBLIC_SALE_AMOUNT + RESERVED_CONTRIBUTORS_AMOUNT));\n           emit StartingIndexSetPublicSale(publicSaleAndContributorsOffset);\n       } else {\n           alphaOffset = (randomness % MAX_ALPHA_NFT_AMOUNT);\n           betaOffset = (randomness % MAX_BETA_NFT_AMOUNT);\n           emit StartingIndexSetAlphaBeta(alphaOffset, betaOffset);\n       }\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "It depends on miner-influenceable `block.timestamp`"
      },
      {
        "choice": "B",
        "answer": "It depends on miner-influenceable `blockhash`"
      },
      {
        "choice": "C",
        "answer": "It depends on deprecated Chainlink VRF v1"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-6.md"
  },
  {
    "question": "7] The documentation/readability concern(s) with _InSecureumLand_ is/are",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumLand_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumLand_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n\ncontract InSecureumLand is ERC721Enumerable, Ownable, ReentrancyGuard, VRFConsumerBase {\n   using SafeERC20 for IERC20;\n\n   // attributes\n   string private baseURI;\n   address public operator;\n   bool public publicSaleActive;\n   uint256 public publicSaleStartTime;\n   uint256 public publicSalePriceLoweringDuration;\n   uint256 public publicSaleStartPrice;\n   uint256 public publicSaleEndingPrice;\n   uint256 public currentNumLandsMintedPublicSale;\n   uint256 public mintIndexPublicSaleAndContributors;\n   address public tokenContract;\n   bool private isKycCheckRequired;\n   bytes32 public kycMerkleRoot;\n   uint256 public maxMintPerTx;\n   uint256 public maxMintPerAddress;\n   mapping(address => uint256) public mintedPerAddress;\n   bool public claimableActive;\n   bool public adminClaimStarted;\n   address public alphaContract;\n   mapping(uint256 => bool) public alphaClaimed;\n   uint256 public alphaClaimedAmount;\n   address public betaContract;\n   mapping(uint256 => bool) public betaClaimed;\n   uint256 public betaClaimedAmount;\n   uint256 public betaNftIdCurrent;\n   bool public contributorsClaimActive;\n   mapping(address => uint256) public contributors;\n   uint256 public futureLandsNftIdCurrent;\n   address public futureMinter;\n   Metadata[] public metadataHashes;\n   bytes32 public keyHash;\n   uint256 public fee;\n   uint256 public publicSaleAndContributorsOffset;\n   uint256 public alphaOffset;\n   uint256 public betaOffset;\n   mapping(bytes32 => bool) public isRandomRequestForPublicSaleAndContributors;\n   bool public publicSaleAndContributorsRandomnessRequested;\n   bool public ownerClaimRandomnessRequested;\n   \n   // constants\n   uint256 immutable public MAX_LANDS;\n   uint256 immutable public MAX_LANDS_WITH_FUTURE;\n   uint256 immutable public MAX_ALPHA_NFT_AMOUNT;\n   uint256 immutable public MAX_BETA_NFT_AMOUNT;\n   uint256 immutable public MAX_PUBLIC_SALE_AMOUNT;\n   uint256 immutable public RESERVED_CONTRIBUTORS_AMOUNT;\n   uint256 immutable public MAX_FUTURE_LANDS;\n   uint256 constant public MAX_MINT_PER_BLOCK = 150;\n\n   // structs\n   struct LandAmount {\n       uint256 alpha;\n       uint256 beta;\n       uint256 publicSale;\n       uint256 future;\n   }\n\n   struct ContributorAmount {\n       address contributor;\n       uint256 amount;\n   }\n\n   struct Metadata {\n       bytes32 metadataHash;\n       bytes32 shuffledArrayHash;\n       uint256 startIndex;\n       uint256 endIndex;\n   }\n\n   struct ContractAddresses {\n       address alphaContract;\n       address betaContract;\n       address tokenContract;\n   }\n\n   // modifiers\n   modifier whenPublicSaleActive() {\n       require(publicSaleActive, \"Public sale is not active\");\n       _;\n   }\n\n   modifier whenContributorsClaimActive() {\n       require(contributorsClaimActive, \"Contributors Claim is not active\");\n       _;\n   }\n\n   modifier whenClaimableActive() {\n       require(claimableActive && !adminClaimStarted, \"Claimable state is not active\");\n       _;\n   }\n\n   modifier checkMetadataRange(Metadata memory _landMetadata){\n       require(_landMetadata.endIndex < MAX_LANDS_WITH_FUTURE, \"Range upper bound cannot exceed MAX_LANDS_WITH_FUTURE - 1\");\n       _;\n   }\n\n   modifier onlyContributors(address _contributor){\n       require(contributors[_contributor] >= 0, \"Only contributors can call this method\");\n       _;\n   }\n\n   modifier onlyOperator() {\n       require(operator == msg.sender , \"Only operator can call this method\");\n       _;\n   }\n\n   modifier onlyFutureMinter() {\n       require(futureMinter == msg.sender , \"Only futureMinter can call this method\");\n       _;\n   }\n\n   modifier checkFirstMetadataRange(uint256 index, uint256 startIndex, uint256 endIndex) {\n       if(index == 0){\n           require(startIndex == 0, \"For first metadata range lower bound should be 0\");\n           require(endIndex == MAX_LANDS - 1, \"For first metadata range upper bound should be MAX_LANDS - 1\");\n       }\n       _;\n   }\n\n   // events\n   event LandPublicSaleStart(\n       uint256 indexed _saleDuration,\n       uint256 indexed _saleStartTime\n   );\n   event LandPublicSaleStop(\n       uint256 indexed _currentPrice,\n       uint256 indexed _timeElapsed\n   );\n   event ClaimableStateChanged(bool indexed claimableActive);\n   event ContributorsClaimStart(uint256 _timestamp);\n   event ContributorsClaimStop(uint256 _timestamp);\n   event StartingIndexSetPublicSale(uint256 indexed _startingIndex);\n   event StartingIndexSetAlphaBeta(uint256 indexed _alphaOffset, uint256 indexed _betaOffset);\n   event PublicSaleMint(address indexed sender, uint256 indexed numLands, uint256 indexed mintPrice);\n\n   constructor(string memory name, string memory symbol,\n       ContractAddresses memory addresses,\n       LandAmount memory amount,\n       ContributorAmount[] memory _contributors,\n       address _vrfCoordinator, address _linkTokenAddress,\n       bytes32 _vrfKeyHash, uint256 _vrfFee,\n       address _operator\n   ) ERC721(name, symbol) VRFConsumerBase(_vrfCoordinator, _linkTokenAddress) {\n       alphaContract = addresses.alphaContract;\n       betaContract = addresses.betaContract;\n       tokenContract = addresses.tokenContract;\n\n       MAX_ALPHA_NFT_AMOUNT = amount.alpha;\n       MAX_BETA_NFT_AMOUNT = amount.beta;\n       MAX_PUBLIC_SALE_AMOUNT = amount.publicSale;\n       MAX_FUTURE_LANDS = amount.future;\n\n       betaNftIdCurrent = amount.alpha; //beta starts after alpha\n       mintIndexPublicSaleAndContributors = amount.alpha + amount.beta; //public sale starts after beta\n\n       uint256 tempSum;\n       for(uint256 i; i<_contributors.length; ++i){\n           contributors[_contributors[i].contributor] = _contributors[i].amount;\n           tempSum += _contributors[i].amount;\n       }\n       RESERVED_CONTRIBUTORS_AMOUNT = tempSum;\n       MAX_LANDS = amount.alpha + amount.beta + amount.publicSale + RESERVED_CONTRIBUTORS_AMOUNT;\n       MAX_LANDS_WITH_FUTURE = MAX_LANDS + amount.future;\n       futureLandsNftIdCurrent = MAX_LANDS; //future starts after public sale\n       keyHash  = _vrfKeyHash;\n       fee = _vrfFee;\n       operator = _operator;\n   }\n\n   function _baseURI() internal view override returns (string memory) {\n       return baseURI;\n   }\n\n   function setBaseURI(string memory uri) external onlyOperator {\n       baseURI = uri;\n   }\n\n   function setOperator(address _operator) external onlyOwner {\n       operator = _operator;\n   }\n\n   function setMaxMintPerTx(uint256 _maxMintPerTx) external onlyOperator {\n       maxMintPerTx = _maxMintPerTx;\n   }\n\n   function setMaxMintPerAddress(uint256 _maxMintPerAddress) external onlyOperator {\n       maxMintPerAddress = _maxMintPerAddress;\n   }\n\n   function setKycCheckRequired(bool _isKycCheckRequired) external onlyOperator {\n       isKycCheckRequired = _isKycCheckRequired;\n   }\n\n   function setKycMerkleRoot(bytes32 _kycMerkleRoot) external onlyOperator {\n       kycMerkleRoot = _kycMerkleRoot;\n   }\n\n   // Public Sale Methods\n   function startPublicSale(\n       uint256 _publicSalePriceLoweringDuration,\n       uint256 _publicSaleStartPrice,\n       uint256 _publicSaleEndingPrice,\n       uint256 _maxMintPerTx,\n       uint256 _maxMintPerAddress,\n       bool _isKycCheckRequired\n   ) external onlyOperator {\n       require(!publicSaleActive, \"Public sale has already begun\");\n       \n       publicSalePriceLoweringDuration = _publicSalePriceLoweringDuration;\n       publicSaleStartPrice = _publicSaleStartPrice;\n       publicSaleEndingPrice = _publicSaleEndingPrice;\n       publicSaleStartTime = block.timestamp;\n       publicSaleActive = true;\n\n       maxMintPerTx = _maxMintPerTx;\n       maxMintPerAddress = _maxMintPerAddress;\n       isKycCheckRequired = _isKycCheckRequired;\n       emit LandPublicSaleStart(publicSalePriceLoweringDuration, publicSaleStartTime);\n   }\n\n   function stopPublicSale() external onlyOperator whenPublicSaleActive {\n       emit LandPublicSaleStop(getMintPrice(), getElapsedSaleTime());\n       publicSaleActive = false;\n   }\n\n   function getElapsedSaleTime() private view returns (uint256) {\n       return publicSaleStartTime > 0 ? block.timestamp - publicSaleStartTime : 0;\n   }\n\n   function getMintPrice() public view whenPublicSaleActive returns (uint256) {\n       uint256 elapsed = getElapsedSaleTime();\n       uint256 price;\n       if(elapsed < publicSalePriceLoweringDuration) {\n           // Linear decreasing function\n           price =\n               publicSaleStartPrice -\n                   ( ( publicSaleStartPrice - publicSaleEndingPrice ) * elapsed ) / publicSalePriceLoweringDuration ;\n       } else {\n           price = publicSaleEndingPrice;\n       }\n       return price;\n   }\n\n   function mintLands(uint256 numLands, bytes32[] calldata merkleProof) external whenPublicSaleActive nonReentrant {\n       require(numLands > 0, \"Must mint at least one beta\");\n       require(currentNumLandsMintedPublicSale + numLands <= MAX_PUBLIC_SALE_AMOUNT, \"Minting would exceed max supply\");\n       require(numLands <= maxMintPerTx, \"numLands should not exceed maxMintPerTx\");\n       require(numLands + mintedPerAddress[msg.sender] <= maxMintPerAddress, \"sender address cannot mint more than maxMintPerAddress lands\");\n       if(isKycCheckRequired) {\n           require(MerkleProof.verify(merkleProof, kycMerkleRoot, keccak256(abi.encodePacked(msg.sender))), \"Sender address is not in KYC allowlist\");\n       } else {\n           require(msg.sender == tx.origin, \"Minting from smart contracts is disallowed\");\n       }\n   \n       uint256 mintPrice = getMintPrice();\n       IERC20(tokenContract).safeTransferFrom(msg.sender, address(this), mintPrice * numLands);\n       mintedPerAddress[msg.sender] += numLands;\n       emit PublicSaleMint(msg.sender, numLands, mintPrice);\n       mintLandsCommon(numLands, msg.sender);\n   }\n\n   function mintLandsCommon(uint256 numLands, address recipient) private {\n       for (uint256 i; i < numLands; ++i) {\n           _safeMint(recipient, mintIndexPublicSaleAndContributors++);\n       }\n   }\n\n   function withdraw() external onlyOwner {\n       uint256 balance = address(this).balance;\n       if(balance > 0){\n           Address.sendValue(payable(owner()), balance);\n       }\n       balance = IERC20(tokenContract).balanceOf(address(this));\n       if(balance > 0){\n           IERC20(tokenContract).safeTransfer(owner(), balance);\n       }\n   }\n\n   // Alpha/Beta Claim Methods\n   function flipClaimableState() external onlyOperator {\n       claimableActive = !claimableActive;\n       emit ClaimableStateChanged(claimableActive);\n   }\n\n   function nftOwnerClaimLand(uint256[] calldata alphaTokenIds, uint256[] calldata betaTokenIds) external whenClaimableActive {\n       require(alphaTokenIds.length > 0 || betaTokenIds.length > 0, \"Should claim at least one land\");\n       require(alphaTokenIds.length + betaTokenIds.length <= MAX_MINT_PER_BLOCK, \"Input length should be <= MAX_MINT_PER_BLOCK\");\n\n       alphaClaimLand(alphaTokenIds);\n       betaClaimLand(betaTokenIds);\n   }\n\n   function alphaClaimLand(uint256[] calldata alphaTokenIds) private {\n       for(uint256 i; i < alphaTokenIds.length; ++i){\n           uint256 alphaTokenId = alphaTokenIds[i];\n           require(!alphaClaimed[alphaTokenId], \"ALPHA NFT already claimed\");\n           require(ERC721(alphaContract).ownerOf(alphaTokenId) == msg.sender, \"Must own all of the alpha defined by alphaTokenIds\");\n           \n           alphaClaimLandByTokenId(alphaTokenId);    \n       }\n   }\n\n   function alphaClaimLandByTokenId(uint256 alphaTokenId) private {\n       alphaClaimed[alphaTokenId] = true;\n       ++alphaClaimedAmount;        \n       _safeMint(msg.sender, alphaTokenId);\n   }\n\n   function betaClaimLand(uint256[] calldata betaTokenIds) private {\n       for(uint256 i; i < betaTokenIds.length; ++i){\n           uint256 betaTokenId = betaTokenIds[i];\n           require(!betaClaimed[betaTokenId], \"BETA NFT already claimed\");\n           require(ERC721(betaContract).ownerOf(betaTokenId) == msg.sender, \"Must own all of the beta defined by betaTokenIds\");\n           \n           betaClaimLandByTokenId(betaTokenId);    \n       }\n   }\n\n   function betaClaimLandByTokenId(uint256 betaTokenId) private {\n       betaClaimed[betaTokenId] = true;\n       ++betaClaimedAmount;\n       _safeMint(msg.sender, betaNftIdCurrent++);\n   }\n\n   // Contributors Claim Methods\n   function startContributorsClaimPeriod() onlyOperator external {\n       require(!contributorsClaimActive, \"Contributors claim is already active\");\n       contributorsClaimActive = true;\n       emit ContributorsClaimStart(block.timestamp);\n   }\n\n   function stopContributorsClaimPeriod() onlyOperator external whenContributorsClaimActive {\n       contributorsClaimActive = false;\n       emit ContributorsClaimStop(block.timestamp);\n   }\n\n   function contributorsClaimLand(uint256 amount, address recipient) external onlyContributors(msg.sender) whenContributorsClaimActive {\n       require(amount > 0, \"Must mint at least one land\");\n       require(amount <= MAX_MINT_PER_BLOCK, \"amount should not exceed MAX_MINT_PER_BLOCK\");\n       mintLandsCommon(amount, recipient);\n   }\n\n   function claimUnclaimedAndUnsoldLands(address recipient) external onlyOwner {\n       claimUnclaimedAndUnsoldLandsWithAmount(recipient, MAX_MINT_PER_BLOCK);\n   }\n\n   function claimUnclaimedAndUnsoldLandsWithAmount(address recipient, uint256 maxAmount) public onlyOwner {\n       require (publicSaleStartTime > 0 && !claimableActive && !publicSaleActive && !contributorsClaimActive,\n           \"Cannot claim the unclaimed if claimable or public sale are active\");\n       require(maxAmount <= MAX_MINT_PER_BLOCK, \"maxAmount cannot exceed MAX_MINT_PER_BLOCK\");\n       require(alphaClaimedAmount < MAX_ALPHA_NFT_AMOUNT || betaClaimedAmount < MAX_BETA_NFT_AMOUNT\n                   || mintIndexPublicSaleAndContributors < MAX_LANDS, \"Max NFT amount already claimed or sold\");\n\n       uint256 totalMinted;\n       adminClaimStarted = true;\n       //claim beta\n       if(betaClaimedAmount < MAX_BETA_NFT_AMOUNT) {\n           uint256 leftToBeMinted = MAX_BETA_NFT_AMOUNT - betaClaimedAmount;\n           uint256 toMint = leftToBeMinted < maxAmount ? leftToBeMinted :\n               maxAmount; //take the min\n\n           uint256 target = betaNftIdCurrent + toMint;\n           for(; betaNftIdCurrent < target; ++betaNftIdCurrent){\n               ++betaClaimedAmount;\n               ++totalMinted;\n               _safeMint(recipient, betaNftIdCurrent);\n           }\n       }\n\n       //claim alpha\n       if(alphaClaimedAmount < MAX_ALPHA_NFT_AMOUNT) {\n           uint256 leftToBeMinted = MAX_ALPHA_NFT_AMOUNT - alphaClaimedAmount;\n           uint256 toMint = maxAmount < leftToBeMinted + totalMinted ?\n                           maxAmount :\n                           leftToBeMinted + totalMinted; //summing totalMinted avoid to use another counter\n           \n           uint256 lastAlphaNft = MAX_ALPHA_NFT_AMOUNT - 1;\n           for(uint256 i; i <= lastAlphaNft && totalMinted < toMint; ++i) {\n               if(!alphaClaimed[i]){\n                   ++alphaClaimedAmount;\n                   ++totalMinted;\n                   alphaClaimed[i] = true;\n                   _safeMint(recipient, i);\n               }\n           }\n       }\n\n       //claim unsold\n       if(mintIndexPublicSaleAndContributors < MAX_LANDS){\n           uint256 leftToBeMinted = MAX_LANDS - mintIndexPublicSaleAndContributors;\n           uint256 toMint = maxAmount < leftToBeMinted + totalMinted ?\n                           maxAmount :\n                           leftToBeMinted + totalMinted; //summing totalMinted avoid to use another counter\n\n           for(; mintIndexPublicSaleAndContributors < MAX_LANDS && totalMinted < toMint; ++mintIndexPublicSaleAndContributors) {\n                   ++totalMinted;\n                   _safeMint(recipient, mintIndexPublicSaleAndContributors);\n           }              \n       }\n   }\n\n   //future\n   function setFutureMinter(address _futureMinter) external onlyOwner {\n       futureMinter = _futureMinter;\n   }\n\n   function mintFutureLands(address recipient) external onlyFutureMinter {\n       mintFutureLandsWithAmount(recipient, MAX_MINT_PER_BLOCK);\n   }\n\n   function mintFutureLandsWithAmount(address recipient, uint256 maxAmount) public onlyFutureMinter {\n       require(maxAmount <= MAX_MINT_PER_BLOCK, \"maxAmount cannot exceed MAX_MINT_PER_BLOCK\");    \n       require(futureLandsNftIdCurrent < MAX_LANDS_WITH_FUTURE, \"All future lands were already minted\");\n       for(uint256 claimed; claimed < maxAmount && futureLandsNftIdCurrent < MAX_LANDS_WITH_FUTURE; ++claimed){\n           _safeMint(recipient, futureLandsNftIdCurrent++);\n       }\n   }\n   \n   // metadata\n   function loadLandMetadata(Metadata memory _landMetadata)\n       external onlyOperator checkMetadataRange(_landMetadata)\n       checkFirstMetadataRange(metadataHashes.length, _landMetadata.startIndex, _landMetadata.endIndex)\n   {\n       metadataHashes.push(_landMetadata);\n   }\n\n   function putLandMetadataAtIndex(uint256 index, Metadata memory _landMetadata)\n       external onlyOperator checkMetadataRange(_landMetadata)\n       checkFirstMetadataRange(index, _landMetadata.startIndex, _landMetadata.endIndex)\n   {\n       metadataHashes[index] = _landMetadata;\n   }    \n\n   // randomness\n   function requestRandomnessForPublicSaleAndContributors() external onlyOperator returns (bytes32 requestId) {\n       require(!publicSaleAndContributorsRandomnessRequested, \"Public Sale And Contributors Offset already requested\");\n       publicSaleAndContributorsRandomnessRequested = true;\n       requestId = requestRandomnessPrivate();\n       isRandomRequestForPublicSaleAndContributors[requestId] = true;\n   }\n\n   function requestRandomnessForOwnerClaim() external onlyOperator returns (bytes32 requestId) {\n       require(!ownerClaimRandomnessRequested, \"Owner Claim Offset already requested\");\n       ownerClaimRandomnessRequested = true;\n       requestId = requestRandomnessPrivate();\n       isRandomRequestForPublicSaleAndContributors[requestId] = false;\n   }\n\n   function requestRandomnessPrivate() private returns (bytes32 requestId) {\n       require(\n           LINK.balanceOf(address(this)) >= fee,\n           \"Not enough LINK\"\n       );\n       return requestRandomness(keyHash, fee);\n   }\n\n   function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n       if(isRandomRequestForPublicSaleAndContributors[requestId]){\n           publicSaleAndContributorsOffset = (randomness % (MAX_PUBLIC_SALE_AMOUNT + RESERVED_CONTRIBUTORS_AMOUNT));\n           emit StartingIndexSetPublicSale(publicSaleAndContributorsOffset);\n       } else {\n           alphaOffset = (randomness % MAX_ALPHA_NFT_AMOUNT);\n           betaOffset = (randomness % MAX_BETA_NFT_AMOUNT);\n           emit StartingIndexSetAlphaBeta(alphaOffset, betaOffset);\n       }\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Stale comments"
      },
      {
        "choice": "B",
        "answer": "Missing NatSpec"
      },
      {
        "choice": "C",
        "answer": "Minimal inlined comments"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C"
    ],
    "race": "RACE-6.md"
  },
  {
    "question": "8] Potential gas optimization(s) (after appropriate security considerations) in _InSecureumLand_ is/are",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumLand_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumLand_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n\ncontract InSecureumLand is ERC721Enumerable, Ownable, ReentrancyGuard, VRFConsumerBase {\n   using SafeERC20 for IERC20;\n\n   // attributes\n   string private baseURI;\n   address public operator;\n   bool public publicSaleActive;\n   uint256 public publicSaleStartTime;\n   uint256 public publicSalePriceLoweringDuration;\n   uint256 public publicSaleStartPrice;\n   uint256 public publicSaleEndingPrice;\n   uint256 public currentNumLandsMintedPublicSale;\n   uint256 public mintIndexPublicSaleAndContributors;\n   address public tokenContract;\n   bool private isKycCheckRequired;\n   bytes32 public kycMerkleRoot;\n   uint256 public maxMintPerTx;\n   uint256 public maxMintPerAddress;\n   mapping(address => uint256) public mintedPerAddress;\n   bool public claimableActive;\n   bool public adminClaimStarted;\n   address public alphaContract;\n   mapping(uint256 => bool) public alphaClaimed;\n   uint256 public alphaClaimedAmount;\n   address public betaContract;\n   mapping(uint256 => bool) public betaClaimed;\n   uint256 public betaClaimedAmount;\n   uint256 public betaNftIdCurrent;\n   bool public contributorsClaimActive;\n   mapping(address => uint256) public contributors;\n   uint256 public futureLandsNftIdCurrent;\n   address public futureMinter;\n   Metadata[] public metadataHashes;\n   bytes32 public keyHash;\n   uint256 public fee;\n   uint256 public publicSaleAndContributorsOffset;\n   uint256 public alphaOffset;\n   uint256 public betaOffset;\n   mapping(bytes32 => bool) public isRandomRequestForPublicSaleAndContributors;\n   bool public publicSaleAndContributorsRandomnessRequested;\n   bool public ownerClaimRandomnessRequested;\n   \n   // constants\n   uint256 immutable public MAX_LANDS;\n   uint256 immutable public MAX_LANDS_WITH_FUTURE;\n   uint256 immutable public MAX_ALPHA_NFT_AMOUNT;\n   uint256 immutable public MAX_BETA_NFT_AMOUNT;\n   uint256 immutable public MAX_PUBLIC_SALE_AMOUNT;\n   uint256 immutable public RESERVED_CONTRIBUTORS_AMOUNT;\n   uint256 immutable public MAX_FUTURE_LANDS;\n   uint256 constant public MAX_MINT_PER_BLOCK = 150;\n\n   // structs\n   struct LandAmount {\n       uint256 alpha;\n       uint256 beta;\n       uint256 publicSale;\n       uint256 future;\n   }\n\n   struct ContributorAmount {\n       address contributor;\n       uint256 amount;\n   }\n\n   struct Metadata {\n       bytes32 metadataHash;\n       bytes32 shuffledArrayHash;\n       uint256 startIndex;\n       uint256 endIndex;\n   }\n\n   struct ContractAddresses {\n       address alphaContract;\n       address betaContract;\n       address tokenContract;\n   }\n\n   // modifiers\n   modifier whenPublicSaleActive() {\n       require(publicSaleActive, \"Public sale is not active\");\n       _;\n   }\n\n   modifier whenContributorsClaimActive() {\n       require(contributorsClaimActive, \"Contributors Claim is not active\");\n       _;\n   }\n\n   modifier whenClaimableActive() {\n       require(claimableActive && !adminClaimStarted, \"Claimable state is not active\");\n       _;\n   }\n\n   modifier checkMetadataRange(Metadata memory _landMetadata){\n       require(_landMetadata.endIndex < MAX_LANDS_WITH_FUTURE, \"Range upper bound cannot exceed MAX_LANDS_WITH_FUTURE - 1\");\n       _;\n   }\n\n   modifier onlyContributors(address _contributor){\n       require(contributors[_contributor] >= 0, \"Only contributors can call this method\");\n       _;\n   }\n\n   modifier onlyOperator() {\n       require(operator == msg.sender , \"Only operator can call this method\");\n       _;\n   }\n\n   modifier onlyFutureMinter() {\n       require(futureMinter == msg.sender , \"Only futureMinter can call this method\");\n       _;\n   }\n\n   modifier checkFirstMetadataRange(uint256 index, uint256 startIndex, uint256 endIndex) {\n       if(index == 0){\n           require(startIndex == 0, \"For first metadata range lower bound should be 0\");\n           require(endIndex == MAX_LANDS - 1, \"For first metadata range upper bound should be MAX_LANDS - 1\");\n       }\n       _;\n   }\n\n   // events\n   event LandPublicSaleStart(\n       uint256 indexed _saleDuration,\n       uint256 indexed _saleStartTime\n   );\n   event LandPublicSaleStop(\n       uint256 indexed _currentPrice,\n       uint256 indexed _timeElapsed\n   );\n   event ClaimableStateChanged(bool indexed claimableActive);\n   event ContributorsClaimStart(uint256 _timestamp);\n   event ContributorsClaimStop(uint256 _timestamp);\n   event StartingIndexSetPublicSale(uint256 indexed _startingIndex);\n   event StartingIndexSetAlphaBeta(uint256 indexed _alphaOffset, uint256 indexed _betaOffset);\n   event PublicSaleMint(address indexed sender, uint256 indexed numLands, uint256 indexed mintPrice);\n\n   constructor(string memory name, string memory symbol,\n       ContractAddresses memory addresses,\n       LandAmount memory amount,\n       ContributorAmount[] memory _contributors,\n       address _vrfCoordinator, address _linkTokenAddress,\n       bytes32 _vrfKeyHash, uint256 _vrfFee,\n       address _operator\n   ) ERC721(name, symbol) VRFConsumerBase(_vrfCoordinator, _linkTokenAddress) {\n       alphaContract = addresses.alphaContract;\n       betaContract = addresses.betaContract;\n       tokenContract = addresses.tokenContract;\n\n       MAX_ALPHA_NFT_AMOUNT = amount.alpha;\n       MAX_BETA_NFT_AMOUNT = amount.beta;\n       MAX_PUBLIC_SALE_AMOUNT = amount.publicSale;\n       MAX_FUTURE_LANDS = amount.future;\n\n       betaNftIdCurrent = amount.alpha; //beta starts after alpha\n       mintIndexPublicSaleAndContributors = amount.alpha + amount.beta; //public sale starts after beta\n\n       uint256 tempSum;\n       for(uint256 i; i<_contributors.length; ++i){\n           contributors[_contributors[i].contributor] = _contributors[i].amount;\n           tempSum += _contributors[i].amount;\n       }\n       RESERVED_CONTRIBUTORS_AMOUNT = tempSum;\n       MAX_LANDS = amount.alpha + amount.beta + amount.publicSale + RESERVED_CONTRIBUTORS_AMOUNT;\n       MAX_LANDS_WITH_FUTURE = MAX_LANDS + amount.future;\n       futureLandsNftIdCurrent = MAX_LANDS; //future starts after public sale\n       keyHash  = _vrfKeyHash;\n       fee = _vrfFee;\n       operator = _operator;\n   }\n\n   function _baseURI() internal view override returns (string memory) {\n       return baseURI;\n   }\n\n   function setBaseURI(string memory uri) external onlyOperator {\n       baseURI = uri;\n   }\n\n   function setOperator(address _operator) external onlyOwner {\n       operator = _operator;\n   }\n\n   function setMaxMintPerTx(uint256 _maxMintPerTx) external onlyOperator {\n       maxMintPerTx = _maxMintPerTx;\n   }\n\n   function setMaxMintPerAddress(uint256 _maxMintPerAddress) external onlyOperator {\n       maxMintPerAddress = _maxMintPerAddress;\n   }\n\n   function setKycCheckRequired(bool _isKycCheckRequired) external onlyOperator {\n       isKycCheckRequired = _isKycCheckRequired;\n   }\n\n   function setKycMerkleRoot(bytes32 _kycMerkleRoot) external onlyOperator {\n       kycMerkleRoot = _kycMerkleRoot;\n   }\n\n   // Public Sale Methods\n   function startPublicSale(\n       uint256 _publicSalePriceLoweringDuration,\n       uint256 _publicSaleStartPrice,\n       uint256 _publicSaleEndingPrice,\n       uint256 _maxMintPerTx,\n       uint256 _maxMintPerAddress,\n       bool _isKycCheckRequired\n   ) external onlyOperator {\n       require(!publicSaleActive, \"Public sale has already begun\");\n       \n       publicSalePriceLoweringDuration = _publicSalePriceLoweringDuration;\n       publicSaleStartPrice = _publicSaleStartPrice;\n       publicSaleEndingPrice = _publicSaleEndingPrice;\n       publicSaleStartTime = block.timestamp;\n       publicSaleActive = true;\n\n       maxMintPerTx = _maxMintPerTx;\n       maxMintPerAddress = _maxMintPerAddress;\n       isKycCheckRequired = _isKycCheckRequired;\n       emit LandPublicSaleStart(publicSalePriceLoweringDuration, publicSaleStartTime);\n   }\n\n   function stopPublicSale() external onlyOperator whenPublicSaleActive {\n       emit LandPublicSaleStop(getMintPrice(), getElapsedSaleTime());\n       publicSaleActive = false;\n   }\n\n   function getElapsedSaleTime() private view returns (uint256) {\n       return publicSaleStartTime > 0 ? block.timestamp - publicSaleStartTime : 0;\n   }\n\n   function getMintPrice() public view whenPublicSaleActive returns (uint256) {\n       uint256 elapsed = getElapsedSaleTime();\n       uint256 price;\n       if(elapsed < publicSalePriceLoweringDuration) {\n           // Linear decreasing function\n           price =\n               publicSaleStartPrice -\n                   ( ( publicSaleStartPrice - publicSaleEndingPrice ) * elapsed ) / publicSalePriceLoweringDuration ;\n       } else {\n           price = publicSaleEndingPrice;\n       }\n       return price;\n   }\n\n   function mintLands(uint256 numLands, bytes32[] calldata merkleProof) external whenPublicSaleActive nonReentrant {\n       require(numLands > 0, \"Must mint at least one beta\");\n       require(currentNumLandsMintedPublicSale + numLands <= MAX_PUBLIC_SALE_AMOUNT, \"Minting would exceed max supply\");\n       require(numLands <= maxMintPerTx, \"numLands should not exceed maxMintPerTx\");\n       require(numLands + mintedPerAddress[msg.sender] <= maxMintPerAddress, \"sender address cannot mint more than maxMintPerAddress lands\");\n       if(isKycCheckRequired) {\n           require(MerkleProof.verify(merkleProof, kycMerkleRoot, keccak256(abi.encodePacked(msg.sender))), \"Sender address is not in KYC allowlist\");\n       } else {\n           require(msg.sender == tx.origin, \"Minting from smart contracts is disallowed\");\n       }\n   \n       uint256 mintPrice = getMintPrice();\n       IERC20(tokenContract).safeTransferFrom(msg.sender, address(this), mintPrice * numLands);\n       mintedPerAddress[msg.sender] += numLands;\n       emit PublicSaleMint(msg.sender, numLands, mintPrice);\n       mintLandsCommon(numLands, msg.sender);\n   }\n\n   function mintLandsCommon(uint256 numLands, address recipient) private {\n       for (uint256 i; i < numLands; ++i) {\n           _safeMint(recipient, mintIndexPublicSaleAndContributors++);\n       }\n   }\n\n   function withdraw() external onlyOwner {\n       uint256 balance = address(this).balance;\n       if(balance > 0){\n           Address.sendValue(payable(owner()), balance);\n       }\n       balance = IERC20(tokenContract).balanceOf(address(this));\n       if(balance > 0){\n           IERC20(tokenContract).safeTransfer(owner(), balance);\n       }\n   }\n\n   // Alpha/Beta Claim Methods\n   function flipClaimableState() external onlyOperator {\n       claimableActive = !claimableActive;\n       emit ClaimableStateChanged(claimableActive);\n   }\n\n   function nftOwnerClaimLand(uint256[] calldata alphaTokenIds, uint256[] calldata betaTokenIds) external whenClaimableActive {\n       require(alphaTokenIds.length > 0 || betaTokenIds.length > 0, \"Should claim at least one land\");\n       require(alphaTokenIds.length + betaTokenIds.length <= MAX_MINT_PER_BLOCK, \"Input length should be <= MAX_MINT_PER_BLOCK\");\n\n       alphaClaimLand(alphaTokenIds);\n       betaClaimLand(betaTokenIds);\n   }\n\n   function alphaClaimLand(uint256[] calldata alphaTokenIds) private {\n       for(uint256 i; i < alphaTokenIds.length; ++i){\n           uint256 alphaTokenId = alphaTokenIds[i];\n           require(!alphaClaimed[alphaTokenId], \"ALPHA NFT already claimed\");\n           require(ERC721(alphaContract).ownerOf(alphaTokenId) == msg.sender, \"Must own all of the alpha defined by alphaTokenIds\");\n           \n           alphaClaimLandByTokenId(alphaTokenId);    \n       }\n   }\n\n   function alphaClaimLandByTokenId(uint256 alphaTokenId) private {\n       alphaClaimed[alphaTokenId] = true;\n       ++alphaClaimedAmount;        \n       _safeMint(msg.sender, alphaTokenId);\n   }\n\n   function betaClaimLand(uint256[] calldata betaTokenIds) private {\n       for(uint256 i; i < betaTokenIds.length; ++i){\n           uint256 betaTokenId = betaTokenIds[i];\n           require(!betaClaimed[betaTokenId], \"BETA NFT already claimed\");\n           require(ERC721(betaContract).ownerOf(betaTokenId) == msg.sender, \"Must own all of the beta defined by betaTokenIds\");\n           \n           betaClaimLandByTokenId(betaTokenId);    \n       }\n   }\n\n   function betaClaimLandByTokenId(uint256 betaTokenId) private {\n       betaClaimed[betaTokenId] = true;\n       ++betaClaimedAmount;\n       _safeMint(msg.sender, betaNftIdCurrent++);\n   }\n\n   // Contributors Claim Methods\n   function startContributorsClaimPeriod() onlyOperator external {\n       require(!contributorsClaimActive, \"Contributors claim is already active\");\n       contributorsClaimActive = true;\n       emit ContributorsClaimStart(block.timestamp);\n   }\n\n   function stopContributorsClaimPeriod() onlyOperator external whenContributorsClaimActive {\n       contributorsClaimActive = false;\n       emit ContributorsClaimStop(block.timestamp);\n   }\n\n   function contributorsClaimLand(uint256 amount, address recipient) external onlyContributors(msg.sender) whenContributorsClaimActive {\n       require(amount > 0, \"Must mint at least one land\");\n       require(amount <= MAX_MINT_PER_BLOCK, \"amount should not exceed MAX_MINT_PER_BLOCK\");\n       mintLandsCommon(amount, recipient);\n   }\n\n   function claimUnclaimedAndUnsoldLands(address recipient) external onlyOwner {\n       claimUnclaimedAndUnsoldLandsWithAmount(recipient, MAX_MINT_PER_BLOCK);\n   }\n\n   function claimUnclaimedAndUnsoldLandsWithAmount(address recipient, uint256 maxAmount) public onlyOwner {\n       require (publicSaleStartTime > 0 && !claimableActive && !publicSaleActive && !contributorsClaimActive,\n           \"Cannot claim the unclaimed if claimable or public sale are active\");\n       require(maxAmount <= MAX_MINT_PER_BLOCK, \"maxAmount cannot exceed MAX_MINT_PER_BLOCK\");\n       require(alphaClaimedAmount < MAX_ALPHA_NFT_AMOUNT || betaClaimedAmount < MAX_BETA_NFT_AMOUNT\n                   || mintIndexPublicSaleAndContributors < MAX_LANDS, \"Max NFT amount already claimed or sold\");\n\n       uint256 totalMinted;\n       adminClaimStarted = true;\n       //claim beta\n       if(betaClaimedAmount < MAX_BETA_NFT_AMOUNT) {\n           uint256 leftToBeMinted = MAX_BETA_NFT_AMOUNT - betaClaimedAmount;\n           uint256 toMint = leftToBeMinted < maxAmount ? leftToBeMinted :\n               maxAmount; //take the min\n\n           uint256 target = betaNftIdCurrent + toMint;\n           for(; betaNftIdCurrent < target; ++betaNftIdCurrent){\n               ++betaClaimedAmount;\n               ++totalMinted;\n               _safeMint(recipient, betaNftIdCurrent);\n           }\n       }\n\n       //claim alpha\n       if(alphaClaimedAmount < MAX_ALPHA_NFT_AMOUNT) {\n           uint256 leftToBeMinted = MAX_ALPHA_NFT_AMOUNT - alphaClaimedAmount;\n           uint256 toMint = maxAmount < leftToBeMinted + totalMinted ?\n                           maxAmount :\n                           leftToBeMinted + totalMinted; //summing totalMinted avoid to use another counter\n           \n           uint256 lastAlphaNft = MAX_ALPHA_NFT_AMOUNT - 1;\n           for(uint256 i; i <= lastAlphaNft && totalMinted < toMint; ++i) {\n               if(!alphaClaimed[i]){\n                   ++alphaClaimedAmount;\n                   ++totalMinted;\n                   alphaClaimed[i] = true;\n                   _safeMint(recipient, i);\n               }\n           }\n       }\n\n       //claim unsold\n       if(mintIndexPublicSaleAndContributors < MAX_LANDS){\n           uint256 leftToBeMinted = MAX_LANDS - mintIndexPublicSaleAndContributors;\n           uint256 toMint = maxAmount < leftToBeMinted + totalMinted ?\n                           maxAmount :\n                           leftToBeMinted + totalMinted; //summing totalMinted avoid to use another counter\n\n           for(; mintIndexPublicSaleAndContributors < MAX_LANDS && totalMinted < toMint; ++mintIndexPublicSaleAndContributors) {\n                   ++totalMinted;\n                   _safeMint(recipient, mintIndexPublicSaleAndContributors);\n           }              \n       }\n   }\n\n   //future\n   function setFutureMinter(address _futureMinter) external onlyOwner {\n       futureMinter = _futureMinter;\n   }\n\n   function mintFutureLands(address recipient) external onlyFutureMinter {\n       mintFutureLandsWithAmount(recipient, MAX_MINT_PER_BLOCK);\n   }\n\n   function mintFutureLandsWithAmount(address recipient, uint256 maxAmount) public onlyFutureMinter {\n       require(maxAmount <= MAX_MINT_PER_BLOCK, \"maxAmount cannot exceed MAX_MINT_PER_BLOCK\");    \n       require(futureLandsNftIdCurrent < MAX_LANDS_WITH_FUTURE, \"All future lands were already minted\");\n       for(uint256 claimed; claimed < maxAmount && futureLandsNftIdCurrent < MAX_LANDS_WITH_FUTURE; ++claimed){\n           _safeMint(recipient, futureLandsNftIdCurrent++);\n       }\n   }\n   \n   // metadata\n   function loadLandMetadata(Metadata memory _landMetadata)\n       external onlyOperator checkMetadataRange(_landMetadata)\n       checkFirstMetadataRange(metadataHashes.length, _landMetadata.startIndex, _landMetadata.endIndex)\n   {\n       metadataHashes.push(_landMetadata);\n   }\n\n   function putLandMetadataAtIndex(uint256 index, Metadata memory _landMetadata)\n       external onlyOperator checkMetadataRange(_landMetadata)\n       checkFirstMetadataRange(index, _landMetadata.startIndex, _landMetadata.endIndex)\n   {\n       metadataHashes[index] = _landMetadata;\n   }    \n\n   // randomness\n   function requestRandomnessForPublicSaleAndContributors() external onlyOperator returns (bytes32 requestId) {\n       require(!publicSaleAndContributorsRandomnessRequested, \"Public Sale And Contributors Offset already requested\");\n       publicSaleAndContributorsRandomnessRequested = true;\n       requestId = requestRandomnessPrivate();\n       isRandomRequestForPublicSaleAndContributors[requestId] = true;\n   }\n\n   function requestRandomnessForOwnerClaim() external onlyOperator returns (bytes32 requestId) {\n       require(!ownerClaimRandomnessRequested, \"Owner Claim Offset already requested\");\n       ownerClaimRandomnessRequested = true;\n       requestId = requestRandomnessPrivate();\n       isRandomRequestForPublicSaleAndContributors[requestId] = false;\n   }\n\n   function requestRandomnessPrivate() private returns (bytes32 requestId) {\n       require(\n           LINK.balanceOf(address(this)) >= fee,\n           \"Not enough LINK\"\n       );\n       return requestRandomness(keyHash, fee);\n   }\n\n   function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n       if(isRandomRequestForPublicSaleAndContributors[requestId]){\n           publicSaleAndContributorsOffset = (randomness % (MAX_PUBLIC_SALE_AMOUNT + RESERVED_CONTRIBUTORS_AMOUNT));\n           emit StartingIndexSetPublicSale(publicSaleAndContributorsOffset);\n       } else {\n           alphaOffset = (randomness % MAX_ALPHA_NFT_AMOUNT);\n           betaOffset = (randomness % MAX_BETA_NFT_AMOUNT);\n           emit StartingIndexSetAlphaBeta(alphaOffset, betaOffset);\n       }\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Removing `nonReentrant` modifier if mint addresses are known to be EOA"
      },
      {
        "choice": "B",
        "answer": "Using `_mint` instead of `_safeMint` if mint addresses are known to be EOA"
      },
      {
        "choice": "C",
        "answer": "Using `unchecked` in for loop increments"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C"
    ],
    "race": "RACE-6.md"
  },
  {
    "question": "1] The mint price of an _InSecureumApe_ is",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumApe_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumApe_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity ^0.7.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/access/Ownable.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/token/ERC721/ERC721.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/math/SafeMath.sol\";\n\n\ncontract InSecureumApe is ERC721, Ownable {\n\n    using SafeMath for uint256;\n\n    string public IA_PROVENANCE = \"\";\n    uint256 public startingIndexBlock;\n    uint256 public startingIndex;\n    uint256 public constant apePrice = 800000000000000000; //0.08 ETH\n    uint public constant maxApePurchase = 20;\n    uint256 public MAX_APES;\n    bool public saleIsActive = false;\n    uint256 public REVEAL_TIMESTAMP;\n\n    constructor(string memory name, string memory symbol, uint256 maxNftSupply, uint256 saleStart) ERC721(name, symbol) {\n        MAX_APES = maxNftSupply;\n        REVEAL_TIMESTAMP = saleStart + (86400 * 9);\n    }\n\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }\n\n    function reserveApes() public onlyOwner {        \n        uint supply = totalSupply();\n        uint i;\n        for (i = 0; i < 30; i++) {\n            _safeMint(msg.sender, supply + i);\n        }\n    }\n\n    function setRevealTimestamp(uint256 revealTimeStamp) public onlyOwner {\n        REVEAL_TIMESTAMP = revealTimeStamp;\n    } \n\n    function setProvenanceHash(string memory provenanceHash) public onlyOwner {\n        IA_PROVENANCE = provenanceHash;\n    }\n\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        _setBaseURI(baseURI);\n    }\n\n    function flipSaleState() public onlyOwner {\n        saleIsActive = !saleIsActive;\n    }\n\n    function mintApe(uint numberOfTokens) public payable {\n        require(saleIsActive, \"Sale must be active to mint Ape\");\n        require(numberOfTokens < maxApePurchase, \"Can only mint 20 tokens at a time\");\n        require(totalSupply().add(numberOfTokens) <= MAX_APES, \"Purchase would exceed max supply of Apes\");\n        require(apePrice.mul(numberOfTokens) <= msg.value, \"Ether value sent is not correct\");\n\n        for(uint i = 0; i < numberOfTokens; i++) {\n            uint mintIndex = totalSupply();\n            if (totalSupply() < MAX_APES) {\n                _safeMint(msg.sender, mintIndex);\n            }\n        }\n\n        // If we haven't set the starting index and this is either 1) the last saleable token or 2) the first token to be sold after\n        // the end of pre-sale, set the starting index block\n        if (startingIndexBlock == 0 && (totalSupply() == MAX_APES || block.timestamp >= REVEAL_TIMESTAMP)) {\n            startingIndexBlock = block.number;\n        } \n    }\n\n    function setStartingIndex() public {\n        require(startingIndex == 0, \"Starting index is already set\");\n        require(startingIndexBlock != 0, \"Starting index block must be set\");\n\n        startingIndex = uint(blockhash(startingIndexBlock)) % MAX_APES;\n        if (block.number.sub(startingIndexBlock) > 255) {\n            startingIndex = uint(blockhash(block.number - 1)) % MAX_APES;\n        }\n        if (startingIndex == 0) {\n            startingIndex = startingIndex.add(1);\n        }\n    }\n\n    function emergencySetStartingIndexBlock() public onlyOwner {\n        require(startingIndex == 0, \"Starting index is already set\");\n        startingIndexBlock = block.number;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "0.0008 ETH"
      },
      {
        "choice": "B",
        "answer": "0.008 ETH"
      },
      {
        "choice": "C",
        "answer": "0.08 ETH"
      },
      {
        "choice": "D",
        "answer": "0.8 ETH \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-7.md"
  },
  {
    "question": "2] The security concern(s) with _InSecureumApe_ access control is/are",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumApe_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumApe_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity ^0.7.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/access/Ownable.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/token/ERC721/ERC721.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/math/SafeMath.sol\";\n\n\ncontract InSecureumApe is ERC721, Ownable {\n\n    using SafeMath for uint256;\n\n    string public IA_PROVENANCE = \"\";\n    uint256 public startingIndexBlock;\n    uint256 public startingIndex;\n    uint256 public constant apePrice = 800000000000000000; //0.08 ETH\n    uint public constant maxApePurchase = 20;\n    uint256 public MAX_APES;\n    bool public saleIsActive = false;\n    uint256 public REVEAL_TIMESTAMP;\n\n    constructor(string memory name, string memory symbol, uint256 maxNftSupply, uint256 saleStart) ERC721(name, symbol) {\n        MAX_APES = maxNftSupply;\n        REVEAL_TIMESTAMP = saleStart + (86400 * 9);\n    }\n\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }\n\n    function reserveApes() public onlyOwner {        \n        uint supply = totalSupply();\n        uint i;\n        for (i = 0; i < 30; i++) {\n            _safeMint(msg.sender, supply + i);\n        }\n    }\n\n    function setRevealTimestamp(uint256 revealTimeStamp) public onlyOwner {\n        REVEAL_TIMESTAMP = revealTimeStamp;\n    } \n\n    function setProvenanceHash(string memory provenanceHash) public onlyOwner {\n        IA_PROVENANCE = provenanceHash;\n    }\n\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        _setBaseURI(baseURI);\n    }\n\n    function flipSaleState() public onlyOwner {\n        saleIsActive = !saleIsActive;\n    }\n\n    function mintApe(uint numberOfTokens) public payable {\n        require(saleIsActive, \"Sale must be active to mint Ape\");\n        require(numberOfTokens < maxApePurchase, \"Can only mint 20 tokens at a time\");\n        require(totalSupply().add(numberOfTokens) <= MAX_APES, \"Purchase would exceed max supply of Apes\");\n        require(apePrice.mul(numberOfTokens) <= msg.value, \"Ether value sent is not correct\");\n\n        for(uint i = 0; i < numberOfTokens; i++) {\n            uint mintIndex = totalSupply();\n            if (totalSupply() < MAX_APES) {\n                _safeMint(msg.sender, mintIndex);\n            }\n        }\n\n        // If we haven't set the starting index and this is either 1) the last saleable token or 2) the first token to be sold after\n        // the end of pre-sale, set the starting index block\n        if (startingIndexBlock == 0 && (totalSupply() == MAX_APES || block.timestamp >= REVEAL_TIMESTAMP)) {\n            startingIndexBlock = block.number;\n        } \n    }\n\n    function setStartingIndex() public {\n        require(startingIndex == 0, \"Starting index is already set\");\n        require(startingIndexBlock != 0, \"Starting index block must be set\");\n\n        startingIndex = uint(blockhash(startingIndexBlock)) % MAX_APES;\n        if (block.number.sub(startingIndexBlock) > 255) {\n            startingIndex = uint(blockhash(block.number - 1)) % MAX_APES;\n        }\n        if (startingIndex == 0) {\n            startingIndex = startingIndex.add(1);\n        }\n    }\n\n    function emergencySetStartingIndexBlock() public onlyOwner {\n        require(startingIndex == 0, \"Starting index is already set\");\n        startingIndexBlock = block.number;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Owner can arbitrarily pause public minting of _InSecureumApe_"
      },
      {
        "choice": "B",
        "answer": "Owner can arbitrarily mint _InSecureumApe_"
      },
      {
        "choice": "C",
        "answer": "Single-step ownership change"
      },
      {
        "choice": "D",
        "answer": "Missing event emits in and time-delayed effects of owner functions \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C",
      "D"
    ],
    "race": "RACE-7.md"
  },
  {
    "question": "3] The security concern(s) with _InSecureumApe_ constructor is/are",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumApe_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumApe_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity ^0.7.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/access/Ownable.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/token/ERC721/ERC721.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/math/SafeMath.sol\";\n\n\ncontract InSecureumApe is ERC721, Ownable {\n\n    using SafeMath for uint256;\n\n    string public IA_PROVENANCE = \"\";\n    uint256 public startingIndexBlock;\n    uint256 public startingIndex;\n    uint256 public constant apePrice = 800000000000000000; //0.08 ETH\n    uint public constant maxApePurchase = 20;\n    uint256 public MAX_APES;\n    bool public saleIsActive = false;\n    uint256 public REVEAL_TIMESTAMP;\n\n    constructor(string memory name, string memory symbol, uint256 maxNftSupply, uint256 saleStart) ERC721(name, symbol) {\n        MAX_APES = maxNftSupply;\n        REVEAL_TIMESTAMP = saleStart + (86400 * 9);\n    }\n\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }\n\n    function reserveApes() public onlyOwner {        \n        uint supply = totalSupply();\n        uint i;\n        for (i = 0; i < 30; i++) {\n            _safeMint(msg.sender, supply + i);\n        }\n    }\n\n    function setRevealTimestamp(uint256 revealTimeStamp) public onlyOwner {\n        REVEAL_TIMESTAMP = revealTimeStamp;\n    } \n\n    function setProvenanceHash(string memory provenanceHash) public onlyOwner {\n        IA_PROVENANCE = provenanceHash;\n    }\n\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        _setBaseURI(baseURI);\n    }\n\n    function flipSaleState() public onlyOwner {\n        saleIsActive = !saleIsActive;\n    }\n\n    function mintApe(uint numberOfTokens) public payable {\n        require(saleIsActive, \"Sale must be active to mint Ape\");\n        require(numberOfTokens < maxApePurchase, \"Can only mint 20 tokens at a time\");\n        require(totalSupply().add(numberOfTokens) <= MAX_APES, \"Purchase would exceed max supply of Apes\");\n        require(apePrice.mul(numberOfTokens) <= msg.value, \"Ether value sent is not correct\");\n\n        for(uint i = 0; i < numberOfTokens; i++) {\n            uint mintIndex = totalSupply();\n            if (totalSupply() < MAX_APES) {\n                _safeMint(msg.sender, mintIndex);\n            }\n        }\n\n        // If we haven't set the starting index and this is either 1) the last saleable token or 2) the first token to be sold after\n        // the end of pre-sale, set the starting index block\n        if (startingIndexBlock == 0 && (totalSupply() == MAX_APES || block.timestamp >= REVEAL_TIMESTAMP)) {\n            startingIndexBlock = block.number;\n        } \n    }\n\n    function setStartingIndex() public {\n        require(startingIndex == 0, \"Starting index is already set\");\n        require(startingIndexBlock != 0, \"Starting index block must be set\");\n\n        startingIndex = uint(blockhash(startingIndexBlock)) % MAX_APES;\n        if (block.number.sub(startingIndexBlock) > 255) {\n            startingIndex = uint(blockhash(block.number - 1)) % MAX_APES;\n        }\n        if (startingIndex == 0) {\n            startingIndex = startingIndex.add(1);\n        }\n    }\n\n    function emergencySetStartingIndexBlock() public onlyOwner {\n        require(startingIndex == 0, \"Starting index is already set\");\n        startingIndexBlock = block.number;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Missing sanity/threshold check on `maxNftSupply`"
      },
      {
        "choice": "B",
        "answer": "Missing sanity/threshold check on `saleStart`"
      },
      {
        "choice": "C",
        "answer": "Potential integer overflow"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C"
    ],
    "race": "RACE-7.md"
  },
  {
    "question": "4] The total number of _InSecureumApe_ that can ever be minted is",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumApe_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumApe_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity ^0.7.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/access/Ownable.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/token/ERC721/ERC721.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/math/SafeMath.sol\";\n\n\ncontract InSecureumApe is ERC721, Ownable {\n\n    using SafeMath for uint256;\n\n    string public IA_PROVENANCE = \"\";\n    uint256 public startingIndexBlock;\n    uint256 public startingIndex;\n    uint256 public constant apePrice = 800000000000000000; //0.08 ETH\n    uint public constant maxApePurchase = 20;\n    uint256 public MAX_APES;\n    bool public saleIsActive = false;\n    uint256 public REVEAL_TIMESTAMP;\n\n    constructor(string memory name, string memory symbol, uint256 maxNftSupply, uint256 saleStart) ERC721(name, symbol) {\n        MAX_APES = maxNftSupply;\n        REVEAL_TIMESTAMP = saleStart + (86400 * 9);\n    }\n\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }\n\n    function reserveApes() public onlyOwner {        \n        uint supply = totalSupply();\n        uint i;\n        for (i = 0; i < 30; i++) {\n            _safeMint(msg.sender, supply + i);\n        }\n    }\n\n    function setRevealTimestamp(uint256 revealTimeStamp) public onlyOwner {\n        REVEAL_TIMESTAMP = revealTimeStamp;\n    } \n\n    function setProvenanceHash(string memory provenanceHash) public onlyOwner {\n        IA_PROVENANCE = provenanceHash;\n    }\n\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        _setBaseURI(baseURI);\n    }\n\n    function flipSaleState() public onlyOwner {\n        saleIsActive = !saleIsActive;\n    }\n\n    function mintApe(uint numberOfTokens) public payable {\n        require(saleIsActive, \"Sale must be active to mint Ape\");\n        require(numberOfTokens < maxApePurchase, \"Can only mint 20 tokens at a time\");\n        require(totalSupply().add(numberOfTokens) <= MAX_APES, \"Purchase would exceed max supply of Apes\");\n        require(apePrice.mul(numberOfTokens) <= msg.value, \"Ether value sent is not correct\");\n\n        for(uint i = 0; i < numberOfTokens; i++) {\n            uint mintIndex = totalSupply();\n            if (totalSupply() < MAX_APES) {\n                _safeMint(msg.sender, mintIndex);\n            }\n        }\n\n        // If we haven't set the starting index and this is either 1) the last saleable token or 2) the first token to be sold after\n        // the end of pre-sale, set the starting index block\n        if (startingIndexBlock == 0 && (totalSupply() == MAX_APES || block.timestamp >= REVEAL_TIMESTAMP)) {\n            startingIndexBlock = block.number;\n        } \n    }\n\n    function setStartingIndex() public {\n        require(startingIndex == 0, \"Starting index is already set\");\n        require(startingIndexBlock != 0, \"Starting index block must be set\");\n\n        startingIndex = uint(blockhash(startingIndexBlock)) % MAX_APES;\n        if (block.number.sub(startingIndexBlock) > 255) {\n            startingIndex = uint(blockhash(block.number - 1)) % MAX_APES;\n        }\n        if (startingIndex == 0) {\n            startingIndex = startingIndex.add(1);\n        }\n    }\n\n    function emergencySetStartingIndexBlock() public onlyOwner {\n        require(startingIndex == 0, \"Starting index is already set\");\n        startingIndexBlock = block.number;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "`maxApePurchase`"
      },
      {
        "choice": "B",
        "answer": "`MAX_APES`"
      },
      {
        "choice": "C",
        "answer": "`MAX_APES` + 30"
      },
      {
        "choice": "D",
        "answer": "`type(uint256).max` \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-7.md"
  },
  {
    "question": "5] The public minting of _InSecureumApe_",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumApe_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumApe_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity ^0.7.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/access/Ownable.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/token/ERC721/ERC721.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/math/SafeMath.sol\";\n\n\ncontract InSecureumApe is ERC721, Ownable {\n\n    using SafeMath for uint256;\n\n    string public IA_PROVENANCE = \"\";\n    uint256 public startingIndexBlock;\n    uint256 public startingIndex;\n    uint256 public constant apePrice = 800000000000000000; //0.08 ETH\n    uint public constant maxApePurchase = 20;\n    uint256 public MAX_APES;\n    bool public saleIsActive = false;\n    uint256 public REVEAL_TIMESTAMP;\n\n    constructor(string memory name, string memory symbol, uint256 maxNftSupply, uint256 saleStart) ERC721(name, symbol) {\n        MAX_APES = maxNftSupply;\n        REVEAL_TIMESTAMP = saleStart + (86400 * 9);\n    }\n\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }\n\n    function reserveApes() public onlyOwner {        \n        uint supply = totalSupply();\n        uint i;\n        for (i = 0; i < 30; i++) {\n            _safeMint(msg.sender, supply + i);\n        }\n    }\n\n    function setRevealTimestamp(uint256 revealTimeStamp) public onlyOwner {\n        REVEAL_TIMESTAMP = revealTimeStamp;\n    } \n\n    function setProvenanceHash(string memory provenanceHash) public onlyOwner {\n        IA_PROVENANCE = provenanceHash;\n    }\n\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        _setBaseURI(baseURI);\n    }\n\n    function flipSaleState() public onlyOwner {\n        saleIsActive = !saleIsActive;\n    }\n\n    function mintApe(uint numberOfTokens) public payable {\n        require(saleIsActive, \"Sale must be active to mint Ape\");\n        require(numberOfTokens < maxApePurchase, \"Can only mint 20 tokens at a time\");\n        require(totalSupply().add(numberOfTokens) <= MAX_APES, \"Purchase would exceed max supply of Apes\");\n        require(apePrice.mul(numberOfTokens) <= msg.value, \"Ether value sent is not correct\");\n\n        for(uint i = 0; i < numberOfTokens; i++) {\n            uint mintIndex = totalSupply();\n            if (totalSupply() < MAX_APES) {\n                _safeMint(msg.sender, mintIndex);\n            }\n        }\n\n        // If we haven't set the starting index and this is either 1) the last saleable token or 2) the first token to be sold after\n        // the end of pre-sale, set the starting index block\n        if (startingIndexBlock == 0 && (totalSupply() == MAX_APES || block.timestamp >= REVEAL_TIMESTAMP)) {\n            startingIndexBlock = block.number;\n        } \n    }\n\n    function setStartingIndex() public {\n        require(startingIndex == 0, \"Starting index is already set\");\n        require(startingIndexBlock != 0, \"Starting index block must be set\");\n\n        startingIndex = uint(blockhash(startingIndexBlock)) % MAX_APES;\n        if (block.number.sub(startingIndexBlock) > 255) {\n            startingIndex = uint(blockhash(block.number - 1)) % MAX_APES;\n        }\n        if (startingIndex == 0) {\n            startingIndex = startingIndex.add(1);\n        }\n    }\n\n    function emergencySetStartingIndexBlock() public onlyOwner {\n        require(startingIndex == 0, \"Starting index is already set\");\n        startingIndexBlock = block.number;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Must be paid the exact amount in Ether"
      },
      {
        "choice": "B",
        "answer": "May be performed 19 NFTs at a time"
      },
      {
        "choice": "C",
        "answer": "Uses `_safeMint` to prevent locked/stuck NFTs"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C"
    ],
    "race": "RACE-7.md"
  },
  {
    "question": "6] The security concern(s) with _InSecureumApe_ is/are",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumApe_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumApe_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity ^0.7.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/access/Ownable.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/token/ERC721/ERC721.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/math/SafeMath.sol\";\n\n\ncontract InSecureumApe is ERC721, Ownable {\n\n    using SafeMath for uint256;\n\n    string public IA_PROVENANCE = \"\";\n    uint256 public startingIndexBlock;\n    uint256 public startingIndex;\n    uint256 public constant apePrice = 800000000000000000; //0.08 ETH\n    uint public constant maxApePurchase = 20;\n    uint256 public MAX_APES;\n    bool public saleIsActive = false;\n    uint256 public REVEAL_TIMESTAMP;\n\n    constructor(string memory name, string memory symbol, uint256 maxNftSupply, uint256 saleStart) ERC721(name, symbol) {\n        MAX_APES = maxNftSupply;\n        REVEAL_TIMESTAMP = saleStart + (86400 * 9);\n    }\n\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }\n\n    function reserveApes() public onlyOwner {        \n        uint supply = totalSupply();\n        uint i;\n        for (i = 0; i < 30; i++) {\n            _safeMint(msg.sender, supply + i);\n        }\n    }\n\n    function setRevealTimestamp(uint256 revealTimeStamp) public onlyOwner {\n        REVEAL_TIMESTAMP = revealTimeStamp;\n    } \n\n    function setProvenanceHash(string memory provenanceHash) public onlyOwner {\n        IA_PROVENANCE = provenanceHash;\n    }\n\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        _setBaseURI(baseURI);\n    }\n\n    function flipSaleState() public onlyOwner {\n        saleIsActive = !saleIsActive;\n    }\n\n    function mintApe(uint numberOfTokens) public payable {\n        require(saleIsActive, \"Sale must be active to mint Ape\");\n        require(numberOfTokens < maxApePurchase, \"Can only mint 20 tokens at a time\");\n        require(totalSupply().add(numberOfTokens) <= MAX_APES, \"Purchase would exceed max supply of Apes\");\n        require(apePrice.mul(numberOfTokens) <= msg.value, \"Ether value sent is not correct\");\n\n        for(uint i = 0; i < numberOfTokens; i++) {\n            uint mintIndex = totalSupply();\n            if (totalSupply() < MAX_APES) {\n                _safeMint(msg.sender, mintIndex);\n            }\n        }\n\n        // If we haven't set the starting index and this is either 1) the last saleable token or 2) the first token to be sold after\n        // the end of pre-sale, set the starting index block\n        if (startingIndexBlock == 0 && (totalSupply() == MAX_APES || block.timestamp >= REVEAL_TIMESTAMP)) {\n            startingIndexBlock = block.number;\n        } \n    }\n\n    function setStartingIndex() public {\n        require(startingIndex == 0, \"Starting index is already set\");\n        require(startingIndexBlock != 0, \"Starting index block must be set\");\n\n        startingIndex = uint(blockhash(startingIndexBlock)) % MAX_APES;\n        if (block.number.sub(startingIndexBlock) > 255) {\n            startingIndex = uint(blockhash(block.number - 1)) % MAX_APES;\n        }\n        if (startingIndex == 0) {\n            startingIndex = startingIndex.add(1);\n        }\n    }\n\n    function emergencySetStartingIndexBlock() public onlyOwner {\n        require(startingIndex == 0, \"Starting index is already set\");\n        startingIndexBlock = block.number;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Use of a floating pragma and an older compiler version"
      },
      {
        "choice": "B",
        "answer": "Oracle price manipulation"
      },
      {
        "choice": "C",
        "answer": "Reentrancy allowing bypass of `maxApePurchase` check"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "C"
    ],
    "race": "RACE-7.md"
  },
  {
    "question": "7] The starting index determination",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumApe_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumApe_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity ^0.7.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/access/Ownable.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/token/ERC721/ERC721.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/math/SafeMath.sol\";\n\n\ncontract InSecureumApe is ERC721, Ownable {\n\n    using SafeMath for uint256;\n\n    string public IA_PROVENANCE = \"\";\n    uint256 public startingIndexBlock;\n    uint256 public startingIndex;\n    uint256 public constant apePrice = 800000000000000000; //0.08 ETH\n    uint public constant maxApePurchase = 20;\n    uint256 public MAX_APES;\n    bool public saleIsActive = false;\n    uint256 public REVEAL_TIMESTAMP;\n\n    constructor(string memory name, string memory symbol, uint256 maxNftSupply, uint256 saleStart) ERC721(name, symbol) {\n        MAX_APES = maxNftSupply;\n        REVEAL_TIMESTAMP = saleStart + (86400 * 9);\n    }\n\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }\n\n    function reserveApes() public onlyOwner {        \n        uint supply = totalSupply();\n        uint i;\n        for (i = 0; i < 30; i++) {\n            _safeMint(msg.sender, supply + i);\n        }\n    }\n\n    function setRevealTimestamp(uint256 revealTimeStamp) public onlyOwner {\n        REVEAL_TIMESTAMP = revealTimeStamp;\n    } \n\n    function setProvenanceHash(string memory provenanceHash) public onlyOwner {\n        IA_PROVENANCE = provenanceHash;\n    }\n\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        _setBaseURI(baseURI);\n    }\n\n    function flipSaleState() public onlyOwner {\n        saleIsActive = !saleIsActive;\n    }\n\n    function mintApe(uint numberOfTokens) public payable {\n        require(saleIsActive, \"Sale must be active to mint Ape\");\n        require(numberOfTokens < maxApePurchase, \"Can only mint 20 tokens at a time\");\n        require(totalSupply().add(numberOfTokens) <= MAX_APES, \"Purchase would exceed max supply of Apes\");\n        require(apePrice.mul(numberOfTokens) <= msg.value, \"Ether value sent is not correct\");\n\n        for(uint i = 0; i < numberOfTokens; i++) {\n            uint mintIndex = totalSupply();\n            if (totalSupply() < MAX_APES) {\n                _safeMint(msg.sender, mintIndex);\n            }\n        }\n\n        // If we haven't set the starting index and this is either 1) the last saleable token or 2) the first token to be sold after\n        // the end of pre-sale, set the starting index block\n        if (startingIndexBlock == 0 && (totalSupply() == MAX_APES || block.timestamp >= REVEAL_TIMESTAMP)) {\n            startingIndexBlock = block.number;\n        } \n    }\n\n    function setStartingIndex() public {\n        require(startingIndex == 0, \"Starting index is already set\");\n        require(startingIndexBlock != 0, \"Starting index block must be set\");\n\n        startingIndex = uint(blockhash(startingIndexBlock)) % MAX_APES;\n        if (block.number.sub(startingIndexBlock) > 255) {\n            startingIndex = uint(blockhash(block.number - 1)) % MAX_APES;\n        }\n        if (startingIndex == 0) {\n            startingIndex = startingIndex.add(1);\n        }\n    }\n\n    function emergencySetStartingIndexBlock() public onlyOwner {\n        require(startingIndex == 0, \"Starting index is already set\");\n        startingIndexBlock = block.number;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Is meant to randomize NFT reveal post-mint"
      },
      {
        "choice": "B",
        "answer": "Can be triggered by the owner at any time"
      },
      {
        "choice": "C",
        "answer": "May be triggered only 9 days after sale start"
      },
      {
        "choice": "D",
        "answer": "Accounts for the fact that EVM only stores previous 256 block hashes \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "D"
    ],
    "race": "RACE-7.md"
  },
  {
    "question": "8] Potential gas optimization(s) in _InSecureumApe_ is/are",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumApe_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumApe_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity ^0.7.0;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/access/Ownable.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/token/ERC721/ERC721.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/math/SafeMath.sol\";\n\n\ncontract InSecureumApe is ERC721, Ownable {\n\n    using SafeMath for uint256;\n\n    string public IA_PROVENANCE = \"\";\n    uint256 public startingIndexBlock;\n    uint256 public startingIndex;\n    uint256 public constant apePrice = 800000000000000000; //0.08 ETH\n    uint public constant maxApePurchase = 20;\n    uint256 public MAX_APES;\n    bool public saleIsActive = false;\n    uint256 public REVEAL_TIMESTAMP;\n\n    constructor(string memory name, string memory symbol, uint256 maxNftSupply, uint256 saleStart) ERC721(name, symbol) {\n        MAX_APES = maxNftSupply;\n        REVEAL_TIMESTAMP = saleStart + (86400 * 9);\n    }\n\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }\n\n    function reserveApes() public onlyOwner {        \n        uint supply = totalSupply();\n        uint i;\n        for (i = 0; i < 30; i++) {\n            _safeMint(msg.sender, supply + i);\n        }\n    }\n\n    function setRevealTimestamp(uint256 revealTimeStamp) public onlyOwner {\n        REVEAL_TIMESTAMP = revealTimeStamp;\n    } \n\n    function setProvenanceHash(string memory provenanceHash) public onlyOwner {\n        IA_PROVENANCE = provenanceHash;\n    }\n\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        _setBaseURI(baseURI);\n    }\n\n    function flipSaleState() public onlyOwner {\n        saleIsActive = !saleIsActive;\n    }\n\n    function mintApe(uint numberOfTokens) public payable {\n        require(saleIsActive, \"Sale must be active to mint Ape\");\n        require(numberOfTokens < maxApePurchase, \"Can only mint 20 tokens at a time\");\n        require(totalSupply().add(numberOfTokens) <= MAX_APES, \"Purchase would exceed max supply of Apes\");\n        require(apePrice.mul(numberOfTokens) <= msg.value, \"Ether value sent is not correct\");\n\n        for(uint i = 0; i < numberOfTokens; i++) {\n            uint mintIndex = totalSupply();\n            if (totalSupply() < MAX_APES) {\n                _safeMint(msg.sender, mintIndex);\n            }\n        }\n\n        // If we haven't set the starting index and this is either 1) the last saleable token or 2) the first token to be sold after\n        // the end of pre-sale, set the starting index block\n        if (startingIndexBlock == 0 && (totalSupply() == MAX_APES || block.timestamp >= REVEAL_TIMESTAMP)) {\n            startingIndexBlock = block.number;\n        } \n    }\n\n    function setStartingIndex() public {\n        require(startingIndex == 0, \"Starting index is already set\");\n        require(startingIndexBlock != 0, \"Starting index block must be set\");\n\n        startingIndex = uint(blockhash(startingIndexBlock)) % MAX_APES;\n        if (block.number.sub(startingIndexBlock) > 255) {\n            startingIndex = uint(blockhash(block.number - 1)) % MAX_APES;\n        }\n        if (startingIndex == 0) {\n            startingIndex = startingIndex.add(1);\n        }\n    }\n\n    function emergencySetStartingIndexBlock() public onlyOwner {\n        require(startingIndex == 0, \"Starting index is already set\");\n        startingIndexBlock = block.number;\n    }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Caching of storage variables"
      },
      {
        "choice": "B",
        "answer": "Avoiding initializations of variables to default values of their types"
      },
      {
        "choice": "C",
        "answer": "Use of immutables"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C"
    ],
    "race": "RACE-7.md"
  },
  {
    "question": "1] Which of the following is/are true?",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumERC721_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumERC721_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity >=0.8.0;\n\nabstract contract InSecureumERC721 {\n\n   event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n   event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n   event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n   string public name;\n\n   string public symbol;\n\n   function tokenURI(uint256 id) public view virtual returns (string memory);\n\n   mapping(uint256 => address) internal _ownerOf;\n\n   mapping(address => uint256) internal _balanceOf;\n\n   function ownerOf(uint256 id) public view virtual returns (address owner) {\n       require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n   }\n\n   function balanceOf(address owner) public view virtual returns (uint256) {\n       require(owner != address(0), \"ZERO_ADDRESS\");\n\n       return _balanceOf[owner];\n   }\n\n   mapping(uint256 => address) public getApproved;\n\n   mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n   constructor(string memory _name, string memory _symbol) {\n       name = _name;\n       symbol = _symbol;\n   }\n\n   function approve(address spender, uint256 id) public virtual {\n       address owner = _ownerOf[id];\n\n       require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n       getApproved[id] = spender;\n\n       emit Approval(owner, spender, id);\n   }\n\n   function setApprovalForAll(address operator, bool approved) public virtual {\n       isApprovedForAll[msg.sender][operator] = approved;\n\n       emit ApprovalForAll(msg.sender, operator, approved);\n   }\n\n   function transferFrom(\n       address from,\n       address to,\n       uint256 id\n   ) public virtual {\n       require(to != address(0), \"INVALID_RECIPIENT\");\n\n       require(\n           msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n           \"NOT_AUTHORIZED\"\n       );\n\n       unchecked {\n           _balanceOf[from]--;\n\n           _balanceOf[to]++;\n       }\n\n       _ownerOf[id] = to;\n\n       delete getApproved[id];\n\n       emit Transfer(from, to, id);\n   }\n\n   function safeTransferFrom(\n       address from,\n       address to,\n       uint256 id\n   ) public virtual {\n       transferFrom(from, to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function safeTransferFrom(\n       address from,\n       address to,\n       uint256 id,\n       bytes calldata data\n   ) public virtual {\n       transferFrom(from, to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n       return\n           interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n           interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n           interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n   }\n\n   function _mint(address to, uint256 id) internal virtual {\n       require(to != address(0), \"INVALID_RECIPIENT\");\n\n       require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n       unchecked {\n           _balanceOf[to]++;\n       }\n\n       _ownerOf[id] = to;\n\n       emit Transfer(address(0), to, id);\n   }\n\n   function _burn(uint256 id) external virtual {\n       address owner = _ownerOf[id];\n\n       require(owner != address(0), \"NOT_MINTED\");\n\n       unchecked {\n           _balanceOf[owner]--;\n       }\n\n       delete _ownerOf[id];\n\n       delete getApproved[id];\n\n       emit Transfer(owner, address(0), id);\n   }\n\n   function _safeMint(address to, uint256 id) internal virtual {\n       _mint(to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function _safeMint(\n       address to,\n       uint256 id,\n       bytes memory data\n   ) internal virtual {\n       _mint(to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n}\n\nabstract contract ERC721TokenReceiver {\n   function onERC721Received(\n       address,\n       address,\n       uint256,\n       bytes calldata\n   ) external virtual returns (bytes4) {\n       return ERC721TokenReceiver.onERC721Received.selector;\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "NFT ownership is tracked by `_ownerOf`"
      },
      {
        "choice": "B",
        "answer": "NFT balance is tracked by `_balanceOf`"
      },
      {
        "choice": "C",
        "answer": "NFT approvals are tracked by `getApproved`"
      },
      {
        "choice": "D",
        "answer": "NFT operator can transfer all of owners NFTs \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C",
      "D"
    ],
    "race": "RACE-8.md"
  },
  {
    "question": "2] _InSecureumERC721_ recognizes the following role(s)",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumERC721_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumERC721_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity >=0.8.0;\n\nabstract contract InSecureumERC721 {\n\n   event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n   event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n   event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n   string public name;\n\n   string public symbol;\n\n   function tokenURI(uint256 id) public view virtual returns (string memory);\n\n   mapping(uint256 => address) internal _ownerOf;\n\n   mapping(address => uint256) internal _balanceOf;\n\n   function ownerOf(uint256 id) public view virtual returns (address owner) {\n       require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n   }\n\n   function balanceOf(address owner) public view virtual returns (uint256) {\n       require(owner != address(0), \"ZERO_ADDRESS\");\n\n       return _balanceOf[owner];\n   }\n\n   mapping(uint256 => address) public getApproved;\n\n   mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n   constructor(string memory _name, string memory _symbol) {\n       name = _name;\n       symbol = _symbol;\n   }\n\n   function approve(address spender, uint256 id) public virtual {\n       address owner = _ownerOf[id];\n\n       require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n       getApproved[id] = spender;\n\n       emit Approval(owner, spender, id);\n   }\n\n   function setApprovalForAll(address operator, bool approved) public virtual {\n       isApprovedForAll[msg.sender][operator] = approved;\n\n       emit ApprovalForAll(msg.sender, operator, approved);\n   }\n\n   function transferFrom(\n       address from,\n       address to,\n       uint256 id\n   ) public virtual {\n       require(to != address(0), \"INVALID_RECIPIENT\");\n\n       require(\n           msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n           \"NOT_AUTHORIZED\"\n       );\n\n       unchecked {\n           _balanceOf[from]--;\n\n           _balanceOf[to]++;\n       }\n\n       _ownerOf[id] = to;\n\n       delete getApproved[id];\n\n       emit Transfer(from, to, id);\n   }\n\n   function safeTransferFrom(\n       address from,\n       address to,\n       uint256 id\n   ) public virtual {\n       transferFrom(from, to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function safeTransferFrom(\n       address from,\n       address to,\n       uint256 id,\n       bytes calldata data\n   ) public virtual {\n       transferFrom(from, to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n       return\n           interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n           interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n           interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n   }\n\n   function _mint(address to, uint256 id) internal virtual {\n       require(to != address(0), \"INVALID_RECIPIENT\");\n\n       require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n       unchecked {\n           _balanceOf[to]++;\n       }\n\n       _ownerOf[id] = to;\n\n       emit Transfer(address(0), to, id);\n   }\n\n   function _burn(uint256 id) external virtual {\n       address owner = _ownerOf[id];\n\n       require(owner != address(0), \"NOT_MINTED\");\n\n       unchecked {\n           _balanceOf[owner]--;\n       }\n\n       delete _ownerOf[id];\n\n       delete getApproved[id];\n\n       emit Transfer(owner, address(0), id);\n   }\n\n   function _safeMint(address to, uint256 id) internal virtual {\n       _mint(to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function _safeMint(\n       address to,\n       uint256 id,\n       bytes memory data\n   ) internal virtual {\n       _mint(to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n}\n\nabstract contract ERC721TokenReceiver {\n   function onERC721Received(\n       address,\n       address,\n       uint256,\n       bytes calldata\n   ) external virtual returns (bytes4) {\n       return ERC721TokenReceiver.onERC721Received.selector;\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Owner"
      },
      {
        "choice": "B",
        "answer": "Spender (Approved address)"
      },
      {
        "choice": "C",
        "answer": "Operator"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C"
    ],
    "race": "RACE-8.md"
  },
  {
    "question": "3] The security concern(s) addressed explicitly in `_mint` include",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumERC721_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumERC721_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity >=0.8.0;\n\nabstract contract InSecureumERC721 {\n\n   event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n   event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n   event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n   string public name;\n\n   string public symbol;\n\n   function tokenURI(uint256 id) public view virtual returns (string memory);\n\n   mapping(uint256 => address) internal _ownerOf;\n\n   mapping(address => uint256) internal _balanceOf;\n\n   function ownerOf(uint256 id) public view virtual returns (address owner) {\n       require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n   }\n\n   function balanceOf(address owner) public view virtual returns (uint256) {\n       require(owner != address(0), \"ZERO_ADDRESS\");\n\n       return _balanceOf[owner];\n   }\n\n   mapping(uint256 => address) public getApproved;\n\n   mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n   constructor(string memory _name, string memory _symbol) {\n       name = _name;\n       symbol = _symbol;\n   }\n\n   function approve(address spender, uint256 id) public virtual {\n       address owner = _ownerOf[id];\n\n       require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n       getApproved[id] = spender;\n\n       emit Approval(owner, spender, id);\n   }\n\n   function setApprovalForAll(address operator, bool approved) public virtual {\n       isApprovedForAll[msg.sender][operator] = approved;\n\n       emit ApprovalForAll(msg.sender, operator, approved);\n   }\n\n   function transferFrom(\n       address from,\n       address to,\n       uint256 id\n   ) public virtual {\n       require(to != address(0), \"INVALID_RECIPIENT\");\n\n       require(\n           msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n           \"NOT_AUTHORIZED\"\n       );\n\n       unchecked {\n           _balanceOf[from]--;\n\n           _balanceOf[to]++;\n       }\n\n       _ownerOf[id] = to;\n\n       delete getApproved[id];\n\n       emit Transfer(from, to, id);\n   }\n\n   function safeTransferFrom(\n       address from,\n       address to,\n       uint256 id\n   ) public virtual {\n       transferFrom(from, to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function safeTransferFrom(\n       address from,\n       address to,\n       uint256 id,\n       bytes calldata data\n   ) public virtual {\n       transferFrom(from, to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n       return\n           interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n           interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n           interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n   }\n\n   function _mint(address to, uint256 id) internal virtual {\n       require(to != address(0), \"INVALID_RECIPIENT\");\n\n       require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n       unchecked {\n           _balanceOf[to]++;\n       }\n\n       _ownerOf[id] = to;\n\n       emit Transfer(address(0), to, id);\n   }\n\n   function _burn(uint256 id) external virtual {\n       address owner = _ownerOf[id];\n\n       require(owner != address(0), \"NOT_MINTED\");\n\n       unchecked {\n           _balanceOf[owner]--;\n       }\n\n       delete _ownerOf[id];\n\n       delete getApproved[id];\n\n       emit Transfer(owner, address(0), id);\n   }\n\n   function _safeMint(address to, uint256 id) internal virtual {\n       _mint(to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function _safeMint(\n       address to,\n       uint256 id,\n       bytes memory data\n   ) internal virtual {\n       _mint(to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n}\n\nabstract contract ERC721TokenReceiver {\n   function onERC721Received(\n       address,\n       address,\n       uint256,\n       bytes calldata\n   ) external virtual returns (bytes4) {\n       return ERC721TokenReceiver.onERC721Received.selector;\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Prevent minting to zero address"
      },
      {
        "choice": "B",
        "answer": "Prevent reminting of NFTs"
      },
      {
        "choice": "C",
        "answer": "Transparency by emitting event"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C"
    ],
    "race": "RACE-8.md"
  },
  {
    "question": "4] The security concerns in `_burn` include",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumERC721_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumERC721_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity >=0.8.0;\n\nabstract contract InSecureumERC721 {\n\n   event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n   event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n   event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n   string public name;\n\n   string public symbol;\n\n   function tokenURI(uint256 id) public view virtual returns (string memory);\n\n   mapping(uint256 => address) internal _ownerOf;\n\n   mapping(address => uint256) internal _balanceOf;\n\n   function ownerOf(uint256 id) public view virtual returns (address owner) {\n       require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n   }\n\n   function balanceOf(address owner) public view virtual returns (uint256) {\n       require(owner != address(0), \"ZERO_ADDRESS\");\n\n       return _balanceOf[owner];\n   }\n\n   mapping(uint256 => address) public getApproved;\n\n   mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n   constructor(string memory _name, string memory _symbol) {\n       name = _name;\n       symbol = _symbol;\n   }\n\n   function approve(address spender, uint256 id) public virtual {\n       address owner = _ownerOf[id];\n\n       require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n       getApproved[id] = spender;\n\n       emit Approval(owner, spender, id);\n   }\n\n   function setApprovalForAll(address operator, bool approved) public virtual {\n       isApprovedForAll[msg.sender][operator] = approved;\n\n       emit ApprovalForAll(msg.sender, operator, approved);\n   }\n\n   function transferFrom(\n       address from,\n       address to,\n       uint256 id\n   ) public virtual {\n       require(to != address(0), \"INVALID_RECIPIENT\");\n\n       require(\n           msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n           \"NOT_AUTHORIZED\"\n       );\n\n       unchecked {\n           _balanceOf[from]--;\n\n           _balanceOf[to]++;\n       }\n\n       _ownerOf[id] = to;\n\n       delete getApproved[id];\n\n       emit Transfer(from, to, id);\n   }\n\n   function safeTransferFrom(\n       address from,\n       address to,\n       uint256 id\n   ) public virtual {\n       transferFrom(from, to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function safeTransferFrom(\n       address from,\n       address to,\n       uint256 id,\n       bytes calldata data\n   ) public virtual {\n       transferFrom(from, to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n       return\n           interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n           interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n           interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n   }\n\n   function _mint(address to, uint256 id) internal virtual {\n       require(to != address(0), \"INVALID_RECIPIENT\");\n\n       require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n       unchecked {\n           _balanceOf[to]++;\n       }\n\n       _ownerOf[id] = to;\n\n       emit Transfer(address(0), to, id);\n   }\n\n   function _burn(uint256 id) external virtual {\n       address owner = _ownerOf[id];\n\n       require(owner != address(0), \"NOT_MINTED\");\n\n       unchecked {\n           _balanceOf[owner]--;\n       }\n\n       delete _ownerOf[id];\n\n       delete getApproved[id];\n\n       emit Transfer(owner, address(0), id);\n   }\n\n   function _safeMint(address to, uint256 id) internal virtual {\n       _mint(to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function _safeMint(\n       address to,\n       uint256 id,\n       bytes memory data\n   ) internal virtual {\n       _mint(to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n}\n\nabstract contract ERC721TokenReceiver {\n   function onERC721Received(\n       address,\n       address,\n       uint256,\n       bytes calldata\n   ) external virtual returns (bytes4) {\n       return ERC721TokenReceiver.onERC721Received.selector;\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Anyone can arbitrarily burn NFTs"
      },
      {
        "choice": "B",
        "answer": "Potential integer underflow because of unchecked"
      },
      {
        "choice": "C",
        "answer": "Incorrect emission of event"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "race": "RACE-8.md"
  },
  {
    "question": "5] The security concern(s) addressed explicitly in `_safeMint` include",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumERC721_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumERC721_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity >=0.8.0;\n\nabstract contract InSecureumERC721 {\n\n   event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n   event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n   event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n   string public name;\n\n   string public symbol;\n\n   function tokenURI(uint256 id) public view virtual returns (string memory);\n\n   mapping(uint256 => address) internal _ownerOf;\n\n   mapping(address => uint256) internal _balanceOf;\n\n   function ownerOf(uint256 id) public view virtual returns (address owner) {\n       require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n   }\n\n   function balanceOf(address owner) public view virtual returns (uint256) {\n       require(owner != address(0), \"ZERO_ADDRESS\");\n\n       return _balanceOf[owner];\n   }\n\n   mapping(uint256 => address) public getApproved;\n\n   mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n   constructor(string memory _name, string memory _symbol) {\n       name = _name;\n       symbol = _symbol;\n   }\n\n   function approve(address spender, uint256 id) public virtual {\n       address owner = _ownerOf[id];\n\n       require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n       getApproved[id] = spender;\n\n       emit Approval(owner, spender, id);\n   }\n\n   function setApprovalForAll(address operator, bool approved) public virtual {\n       isApprovedForAll[msg.sender][operator] = approved;\n\n       emit ApprovalForAll(msg.sender, operator, approved);\n   }\n\n   function transferFrom(\n       address from,\n       address to,\n       uint256 id\n   ) public virtual {\n       require(to != address(0), \"INVALID_RECIPIENT\");\n\n       require(\n           msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n           \"NOT_AUTHORIZED\"\n       );\n\n       unchecked {\n           _balanceOf[from]--;\n\n           _balanceOf[to]++;\n       }\n\n       _ownerOf[id] = to;\n\n       delete getApproved[id];\n\n       emit Transfer(from, to, id);\n   }\n\n   function safeTransferFrom(\n       address from,\n       address to,\n       uint256 id\n   ) public virtual {\n       transferFrom(from, to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function safeTransferFrom(\n       address from,\n       address to,\n       uint256 id,\n       bytes calldata data\n   ) public virtual {\n       transferFrom(from, to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n       return\n           interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n           interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n           interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n   }\n\n   function _mint(address to, uint256 id) internal virtual {\n       require(to != address(0), \"INVALID_RECIPIENT\");\n\n       require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n       unchecked {\n           _balanceOf[to]++;\n       }\n\n       _ownerOf[id] = to;\n\n       emit Transfer(address(0), to, id);\n   }\n\n   function _burn(uint256 id) external virtual {\n       address owner = _ownerOf[id];\n\n       require(owner != address(0), \"NOT_MINTED\");\n\n       unchecked {\n           _balanceOf[owner]--;\n       }\n\n       delete _ownerOf[id];\n\n       delete getApproved[id];\n\n       emit Transfer(owner, address(0), id);\n   }\n\n   function _safeMint(address to, uint256 id) internal virtual {\n       _mint(to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function _safeMint(\n       address to,\n       uint256 id,\n       bytes memory data\n   ) internal virtual {\n       _mint(to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n}\n\nabstract contract ERC721TokenReceiver {\n   function onERC721Received(\n       address,\n       address,\n       uint256,\n       bytes calldata\n   ) external virtual returns (bytes4) {\n       return ERC721TokenReceiver.onERC721Received.selector;\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Validating if the recipient is an EOA"
      },
      {
        "choice": "B",
        "answer": "Ensuring that the recipient can only be an EOA"
      },
      {
        "choice": "C",
        "answer": "Validating if the recipient is an ERC721 aware contract"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "C"
    ],
    "race": "RACE-8.md"
  },
  {
    "question": "6] Function approve",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumERC721_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumERC721_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity >=0.8.0;\n\nabstract contract InSecureumERC721 {\n\n   event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n   event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n   event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n   string public name;\n\n   string public symbol;\n\n   function tokenURI(uint256 id) public view virtual returns (string memory);\n\n   mapping(uint256 => address) internal _ownerOf;\n\n   mapping(address => uint256) internal _balanceOf;\n\n   function ownerOf(uint256 id) public view virtual returns (address owner) {\n       require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n   }\n\n   function balanceOf(address owner) public view virtual returns (uint256) {\n       require(owner != address(0), \"ZERO_ADDRESS\");\n\n       return _balanceOf[owner];\n   }\n\n   mapping(uint256 => address) public getApproved;\n\n   mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n   constructor(string memory _name, string memory _symbol) {\n       name = _name;\n       symbol = _symbol;\n   }\n\n   function approve(address spender, uint256 id) public virtual {\n       address owner = _ownerOf[id];\n\n       require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n       getApproved[id] = spender;\n\n       emit Approval(owner, spender, id);\n   }\n\n   function setApprovalForAll(address operator, bool approved) public virtual {\n       isApprovedForAll[msg.sender][operator] = approved;\n\n       emit ApprovalForAll(msg.sender, operator, approved);\n   }\n\n   function transferFrom(\n       address from,\n       address to,\n       uint256 id\n   ) public virtual {\n       require(to != address(0), \"INVALID_RECIPIENT\");\n\n       require(\n           msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n           \"NOT_AUTHORIZED\"\n       );\n\n       unchecked {\n           _balanceOf[from]--;\n\n           _balanceOf[to]++;\n       }\n\n       _ownerOf[id] = to;\n\n       delete getApproved[id];\n\n       emit Transfer(from, to, id);\n   }\n\n   function safeTransferFrom(\n       address from,\n       address to,\n       uint256 id\n   ) public virtual {\n       transferFrom(from, to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function safeTransferFrom(\n       address from,\n       address to,\n       uint256 id,\n       bytes calldata data\n   ) public virtual {\n       transferFrom(from, to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n       return\n           interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n           interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n           interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n   }\n\n   function _mint(address to, uint256 id) internal virtual {\n       require(to != address(0), \"INVALID_RECIPIENT\");\n\n       require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n       unchecked {\n           _balanceOf[to]++;\n       }\n\n       _ownerOf[id] = to;\n\n       emit Transfer(address(0), to, id);\n   }\n\n   function _burn(uint256 id) external virtual {\n       address owner = _ownerOf[id];\n\n       require(owner != address(0), \"NOT_MINTED\");\n\n       unchecked {\n           _balanceOf[owner]--;\n       }\n\n       delete _ownerOf[id];\n\n       delete getApproved[id];\n\n       emit Transfer(owner, address(0), id);\n   }\n\n   function _safeMint(address to, uint256 id) internal virtual {\n       _mint(to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function _safeMint(\n       address to,\n       uint256 id,\n       bytes memory data\n   ) internal virtual {\n       _mint(to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n}\n\nabstract contract ERC721TokenReceiver {\n   function onERC721Received(\n       address,\n       address,\n       uint256,\n       bytes calldata\n   ) external virtual returns (bytes4) {\n       return ERC721TokenReceiver.onERC721Received.selector;\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Allows the NFT owner to approve a spender"
      },
      {
        "choice": "B",
        "answer": "Allows the NFT spender to approve an operator"
      },
      {
        "choice": "C",
        "answer": "Allows the NFT operator to approve a spender"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "C"
    ],
    "race": "RACE-8.md"
  },
  {
    "question": "7] Function `setApprovalForAll`",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumERC721_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumERC721_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity >=0.8.0;\n\nabstract contract InSecureumERC721 {\n\n   event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n   event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n   event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n   string public name;\n\n   string public symbol;\n\n   function tokenURI(uint256 id) public view virtual returns (string memory);\n\n   mapping(uint256 => address) internal _ownerOf;\n\n   mapping(address => uint256) internal _balanceOf;\n\n   function ownerOf(uint256 id) public view virtual returns (address owner) {\n       require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n   }\n\n   function balanceOf(address owner) public view virtual returns (uint256) {\n       require(owner != address(0), \"ZERO_ADDRESS\");\n\n       return _balanceOf[owner];\n   }\n\n   mapping(uint256 => address) public getApproved;\n\n   mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n   constructor(string memory _name, string memory _symbol) {\n       name = _name;\n       symbol = _symbol;\n   }\n\n   function approve(address spender, uint256 id) public virtual {\n       address owner = _ownerOf[id];\n\n       require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n       getApproved[id] = spender;\n\n       emit Approval(owner, spender, id);\n   }\n\n   function setApprovalForAll(address operator, bool approved) public virtual {\n       isApprovedForAll[msg.sender][operator] = approved;\n\n       emit ApprovalForAll(msg.sender, operator, approved);\n   }\n\n   function transferFrom(\n       address from,\n       address to,\n       uint256 id\n   ) public virtual {\n       require(to != address(0), \"INVALID_RECIPIENT\");\n\n       require(\n           msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n           \"NOT_AUTHORIZED\"\n       );\n\n       unchecked {\n           _balanceOf[from]--;\n\n           _balanceOf[to]++;\n       }\n\n       _ownerOf[id] = to;\n\n       delete getApproved[id];\n\n       emit Transfer(from, to, id);\n   }\n\n   function safeTransferFrom(\n       address from,\n       address to,\n       uint256 id\n   ) public virtual {\n       transferFrom(from, to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function safeTransferFrom(\n       address from,\n       address to,\n       uint256 id,\n       bytes calldata data\n   ) public virtual {\n       transferFrom(from, to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n       return\n           interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n           interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n           interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n   }\n\n   function _mint(address to, uint256 id) internal virtual {\n       require(to != address(0), \"INVALID_RECIPIENT\");\n\n       require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n       unchecked {\n           _balanceOf[to]++;\n       }\n\n       _ownerOf[id] = to;\n\n       emit Transfer(address(0), to, id);\n   }\n\n   function _burn(uint256 id) external virtual {\n       address owner = _ownerOf[id];\n\n       require(owner != address(0), \"NOT_MINTED\");\n\n       unchecked {\n           _balanceOf[owner]--;\n       }\n\n       delete _ownerOf[id];\n\n       delete getApproved[id];\n\n       emit Transfer(owner, address(0), id);\n   }\n\n   function _safeMint(address to, uint256 id) internal virtual {\n       _mint(to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function _safeMint(\n       address to,\n       uint256 id,\n       bytes memory data\n   ) internal virtual {\n       _mint(to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n}\n\nabstract contract ERC721TokenReceiver {\n   function onERC721Received(\n       address,\n       address,\n       uint256,\n       bytes calldata\n   ) external virtual returns (bytes4) {\n       return ERC721TokenReceiver.onERC721Received.selector;\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Approves `msg.sender` to manage operators NFTs"
      },
      {
        "choice": "B",
        "answer": "Gives everyone approval to manage `msg.sender`s NFTs"
      },
      {
        "choice": "C",
        "answer": "Revokes everyones approvals to manage `msg.sender`s NFTs"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-8.md"
  },
  {
    "question": "8] The security concern(s) in `transferFrom` include",
    "context": "**Note**: All 8 questions in this RACE are based on the _InSecureumERC721_ contract. This is the same contract you will see for all the 8 questions in this RACE. _InSecureumERC721_ is adapted from a well-known contract. The question is below the shown contract.\n\n```\npragma solidity >=0.8.0;\n\nabstract contract InSecureumERC721 {\n\n   event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n   event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n   event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n   string public name;\n\n   string public symbol;\n\n   function tokenURI(uint256 id) public view virtual returns (string memory);\n\n   mapping(uint256 => address) internal _ownerOf;\n\n   mapping(address => uint256) internal _balanceOf;\n\n   function ownerOf(uint256 id) public view virtual returns (address owner) {\n       require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n   }\n\n   function balanceOf(address owner) public view virtual returns (uint256) {\n       require(owner != address(0), \"ZERO_ADDRESS\");\n\n       return _balanceOf[owner];\n   }\n\n   mapping(uint256 => address) public getApproved;\n\n   mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n   constructor(string memory _name, string memory _symbol) {\n       name = _name;\n       symbol = _symbol;\n   }\n\n   function approve(address spender, uint256 id) public virtual {\n       address owner = _ownerOf[id];\n\n       require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n       getApproved[id] = spender;\n\n       emit Approval(owner, spender, id);\n   }\n\n   function setApprovalForAll(address operator, bool approved) public virtual {\n       isApprovedForAll[msg.sender][operator] = approved;\n\n       emit ApprovalForAll(msg.sender, operator, approved);\n   }\n\n   function transferFrom(\n       address from,\n       address to,\n       uint256 id\n   ) public virtual {\n       require(to != address(0), \"INVALID_RECIPIENT\");\n\n       require(\n           msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n           \"NOT_AUTHORIZED\"\n       );\n\n       unchecked {\n           _balanceOf[from]--;\n\n           _balanceOf[to]++;\n       }\n\n       _ownerOf[id] = to;\n\n       delete getApproved[id];\n\n       emit Transfer(from, to, id);\n   }\n\n   function safeTransferFrom(\n       address from,\n       address to,\n       uint256 id\n   ) public virtual {\n       transferFrom(from, to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function safeTransferFrom(\n       address from,\n       address to,\n       uint256 id,\n       bytes calldata data\n   ) public virtual {\n       transferFrom(from, to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n       return\n           interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n           interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n           interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n   }\n\n   function _mint(address to, uint256 id) internal virtual {\n       require(to != address(0), \"INVALID_RECIPIENT\");\n\n       require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n       unchecked {\n           _balanceOf[to]++;\n       }\n\n       _ownerOf[id] = to;\n\n       emit Transfer(address(0), to, id);\n   }\n\n   function _burn(uint256 id) external virtual {\n       address owner = _ownerOf[id];\n\n       require(owner != address(0), \"NOT_MINTED\");\n\n       unchecked {\n           _balanceOf[owner]--;\n       }\n\n       delete _ownerOf[id];\n\n       delete getApproved[id];\n\n       emit Transfer(owner, address(0), id);\n   }\n\n   function _safeMint(address to, uint256 id) internal virtual {\n       _mint(to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n\n   function _safeMint(\n       address to,\n       uint256 id,\n       bytes memory data\n   ) internal virtual {\n       _mint(to, id);\n\n       require(\n           to.code.length == 0 ||\n               ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n               ERC721TokenReceiver.onERC721Received.selector,\n           \"UNSAFE_RECIPIENT\"\n       );\n   }\n}\n\nabstract contract ERC721TokenReceiver {\n   function onERC721Received(\n       address,\n       address,\n       uint256,\n       bytes calldata\n   ) external virtual returns (bytes4) {\n       return ERC721TokenReceiver.onERC721Received.selector;\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Allowing the `msg.sender` to transfer any NFT"
      },
      {
        "choice": "B",
        "answer": "NFTs potentially stuck in recipient contracts"
      },
      {
        "choice": "C",
        "answer": "Potential integer underflow"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "C"
    ],
    "race": "RACE-8.md"
  },
  {
    "question": "1] The function signature is the first 4 bytes of the keccak hash which",
    "context": "**Note**: All 8 questions in this RACE are based on the below contracts. This is the same contracts you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Assume the Proxy contract was deployed and no further transactions were made afterwards.\n\ncontract Mastercopy is Ownable {\n   int256 public counter = 0;\n\n   function increase() public onlyOwner returns (int256) {\n       return ++counter;\n   }\n\n   function decrease() public onlyOwner returns (int256) {\n       return --counter;\n   }\n\n}\n\ncontract Proxy is Ownable {\n   mapping(bytes4 => address) public implementations;\n\n   constructor() {\n       Mastercopy mastercopy = new Mastercopy();\n       implementations[bytes4(keccak256(bytes(\"counter()\")))] = address(mastercopy);\n       implementations[Mastercopy.increase.selector] = address(mastercopy);\n       implementations[Mastercopy.increase.selector] = address(mastercopy);\n   }\n\n   fallback() external payable {\n       address implementation = implementations[msg.sig];\n\n       assembly {\n           // Copied without changes to the logic from OpenZeppelin's Proxy contract.\n           calldatacopy(0, 0, calldatasize())\n           let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n           returndatacopy(0, 0, returndatasize())\n           switch result\n               case 0 {\n                   revert(0, returndatasize())\n               }\n               default {\n                   return(0, returndatasize())\n               }\n       }\n   }\n\n   function setImplementationForSelector(bytes4 signature, address implementation) external onlyOwner {\n       implementations[signature] = implementation;\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Includes the function name"
      },
      {
        "choice": "B",
        "answer": "Includes a comma separated list of parameter types"
      },
      {
        "choice": "C",
        "answer": "Includes a comma separated list of return value types"
      },
      {
        "choice": "D",
        "answer": "Is generated only for public and external functions \n \n \n"
      }
    ],
    "correctAnswers": [
      "A",
      "B",
      "D"
    ],
    "race": "RACE-9.md"
  },
  {
    "question": "2] The Proxy contract is most similar to a",
    "context": "**Note**: All 8 questions in this RACE are based on the below contracts. This is the same contracts you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Assume the Proxy contract was deployed and no further transactions were made afterwards.\n\ncontract Mastercopy is Ownable {\n   int256 public counter = 0;\n\n   function increase() public onlyOwner returns (int256) {\n       return ++counter;\n   }\n\n   function decrease() public onlyOwner returns (int256) {\n       return --counter;\n   }\n\n}\n\ncontract Proxy is Ownable {\n   mapping(bytes4 => address) public implementations;\n\n   constructor() {\n       Mastercopy mastercopy = new Mastercopy();\n       implementations[bytes4(keccak256(bytes(\"counter()\")))] = address(mastercopy);\n       implementations[Mastercopy.increase.selector] = address(mastercopy);\n       implementations[Mastercopy.increase.selector] = address(mastercopy);\n   }\n\n   fallback() external payable {\n       address implementation = implementations[msg.sig];\n\n       assembly {\n           // Copied without changes to the logic from OpenZeppelin's Proxy contract.\n           calldatacopy(0, 0, calldatasize())\n           let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n           returndatacopy(0, 0, returndatasize())\n           switch result\n               case 0 {\n                   revert(0, returndatasize())\n               }\n               default {\n                   return(0, returndatasize())\n               }\n       }\n   }\n\n   function setImplementationForSelector(bytes4 signature, address implementation) external onlyOwner {\n       implementations[signature] = implementation;\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "UUPS Proxy"
      },
      {
        "choice": "B",
        "answer": "Beacon Proxy"
      },
      {
        "choice": "C",
        "answer": "Transparent Proxy"
      },
      {
        "choice": "D",
        "answer": "Metamorphic Proxy \n \n \n"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "race": "RACE-9.md"
  },
  {
    "question": "3] Gas will be saved with the following changes",
    "context": "**Note**: All 8 questions in this RACE are based on the below contracts. This is the same contracts you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Assume the Proxy contract was deployed and no further transactions were made afterwards.\n\ncontract Mastercopy is Ownable {\n   int256 public counter = 0;\n\n   function increase() public onlyOwner returns (int256) {\n       return ++counter;\n   }\n\n   function decrease() public onlyOwner returns (int256) {\n       return --counter;\n   }\n\n}\n\ncontract Proxy is Ownable {\n   mapping(bytes4 => address) public implementations;\n\n   constructor() {\n       Mastercopy mastercopy = new Mastercopy();\n       implementations[bytes4(keccak256(bytes(\"counter()\")))] = address(mastercopy);\n       implementations[Mastercopy.increase.selector] = address(mastercopy);\n       implementations[Mastercopy.increase.selector] = address(mastercopy);\n   }\n\n   fallback() external payable {\n       address implementation = implementations[msg.sig];\n\n       assembly {\n           // Copied without changes to the logic from OpenZeppelin's Proxy contract.\n           calldatacopy(0, 0, calldatasize())\n           let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n           returndatacopy(0, 0, returndatasize())\n           switch result\n               case 0 {\n                   revert(0, returndatasize())\n               }\n               default {\n                   return(0, returndatasize())\n               }\n       }\n   }\n\n   function setImplementationForSelector(bytes4 signature, address implementation) external onlyOwner {\n       implementations[signature] = implementation;\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Skipping initialization of counter variable"
      },
      {
        "choice": "B",
        "answer": "Making `increase()` function external to avoid copying from calldata to memory"
      },
      {
        "choice": "C",
        "answer": "Packing multiple implementation addresses into the same storage slot"
      },
      {
        "choice": "D",
        "answer": "Moving the calculation of the `counter()` function's signature hash to a constant \n \n \n"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "race": "RACE-9.md"
  },
  {
    "question": "4] Calling the `increase()` function on the Proxy contract",
    "context": "**Note**: All 8 questions in this RACE are based on the below contracts. This is the same contracts you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Assume the Proxy contract was deployed and no further transactions were made afterwards.\n\ncontract Mastercopy is Ownable {\n   int256 public counter = 0;\n\n   function increase() public onlyOwner returns (int256) {\n       return ++counter;\n   }\n\n   function decrease() public onlyOwner returns (int256) {\n       return --counter;\n   }\n\n}\n\ncontract Proxy is Ownable {\n   mapping(bytes4 => address) public implementations;\n\n   constructor() {\n       Mastercopy mastercopy = new Mastercopy();\n       implementations[bytes4(keccak256(bytes(\"counter()\")))] = address(mastercopy);\n       implementations[Mastercopy.increase.selector] = address(mastercopy);\n       implementations[Mastercopy.increase.selector] = address(mastercopy);\n   }\n\n   fallback() external payable {\n       address implementation = implementations[msg.sig];\n\n       assembly {\n           // Copied without changes to the logic from OpenZeppelin's Proxy contract.\n           calldatacopy(0, 0, calldatasize())\n           let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n           returndatacopy(0, 0, returndatasize())\n           switch result\n               case 0 {\n                   revert(0, returndatasize())\n               }\n               default {\n                   return(0, returndatasize())\n               }\n       }\n   }\n\n   function setImplementationForSelector(bytes4 signature, address implementation) external onlyOwner {\n       implementations[signature] = implementation;\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Will revert since the Proxy contract has no `increase()` function"
      },
      {
        "choice": "B",
        "answer": "Will revert for any other caller than the one that deployed the Proxy"
      },
      {
        "choice": "C",
        "answer": "Increases the integer value in the Proxy's storage slot located at index 1"
      },
      {
        "choice": "D",
        "answer": "Delegate-calls to the zero-address \n \n \n"
      }
    ],
    "correctAnswers": [
      "B",
      "C"
    ],
    "race": "RACE-9.md"
  },
  {
    "question": "5] Calling the `decrease()` function on the Proxy contract",
    "context": "**Note**: All 8 questions in this RACE are based on the below contracts. This is the same contracts you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Assume the Proxy contract was deployed and no further transactions were made afterwards.\n\ncontract Mastercopy is Ownable {\n   int256 public counter = 0;\n\n   function increase() public onlyOwner returns (int256) {\n       return ++counter;\n   }\n\n   function decrease() public onlyOwner returns (int256) {\n       return --counter;\n   }\n\n}\n\ncontract Proxy is Ownable {\n   mapping(bytes4 => address) public implementations;\n\n   constructor() {\n       Mastercopy mastercopy = new Mastercopy();\n       implementations[bytes4(keccak256(bytes(\"counter()\")))] = address(mastercopy);\n       implementations[Mastercopy.increase.selector] = address(mastercopy);\n       implementations[Mastercopy.increase.selector] = address(mastercopy);\n   }\n\n   fallback() external payable {\n       address implementation = implementations[msg.sig];\n\n       assembly {\n           // Copied without changes to the logic from OpenZeppelin's Proxy contract.\n           calldatacopy(0, 0, calldatasize())\n           let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n           returndatacopy(0, 0, returndatasize())\n           switch result\n               case 0 {\n                   revert(0, returndatasize())\n               }\n               default {\n                   return(0, returndatasize())\n               }\n       }\n   }\n\n   function setImplementationForSelector(bytes4 signature, address implementation) external onlyOwner {\n       implementations[signature] = implementation;\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Will revert because it was not correctly registered on the proxy"
      },
      {
        "choice": "B",
        "answer": "Will succeed and return the value of counter after it was decreased"
      },
      {
        "choice": "C",
        "answer": "Will succeed and return the value of counter before it was decreased"
      },
      {
        "choice": "D",
        "answer": "Will succeed and return nothing \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-9.md"
  },
  {
    "question": "6] Due to a storage clash between the Proxy and the Mastercopy contracts",
    "context": "**Note**: All 8 questions in this RACE are based on the below contracts. This is the same contracts you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Assume the Proxy contract was deployed and no further transactions were made afterwards.\n\ncontract Mastercopy is Ownable {\n   int256 public counter = 0;\n\n   function increase() public onlyOwner returns (int256) {\n       return ++counter;\n   }\n\n   function decrease() public onlyOwner returns (int256) {\n       return --counter;\n   }\n\n}\n\ncontract Proxy is Ownable {\n   mapping(bytes4 => address) public implementations;\n\n   constructor() {\n       Mastercopy mastercopy = new Mastercopy();\n       implementations[bytes4(keccak256(bytes(\"counter()\")))] = address(mastercopy);\n       implementations[Mastercopy.increase.selector] = address(mastercopy);\n       implementations[Mastercopy.increase.selector] = address(mastercopy);\n   }\n\n   fallback() external payable {\n       address implementation = implementations[msg.sig];\n\n       assembly {\n           // Copied without changes to the logic from OpenZeppelin's Proxy contract.\n           calldatacopy(0, 0, calldatasize())\n           let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n           returndatacopy(0, 0, returndatasize())\n           switch result\n               case 0 {\n                   revert(0, returndatasize())\n               }\n               default {\n                   return(0, returndatasize())\n               }\n       }\n   }\n\n   function setImplementationForSelector(bytes4 signature, address implementation) external onlyOwner {\n       implementations[signature] = implementation;\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Proxy's `implementations` would be overwritten by 0 during initialization of the Mastercopy"
      },
      {
        "choice": "B",
        "answer": "Proxy's `implementations` would be overwritten when the counter variable changes"
      },
      {
        "choice": "C",
        "answer": "Proxy's `implementations` variable's storage slot being overwritten causes a DoS"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "race": "RACE-9.md"
  },
  {
    "question": "7] The Proxy contract",
    "context": "**Note**: All 8 questions in this RACE are based on the below contracts. This is the same contracts you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Assume the Proxy contract was deployed and no further transactions were made afterwards.\n\ncontract Mastercopy is Ownable {\n   int256 public counter = 0;\n\n   function increase() public onlyOwner returns (int256) {\n       return ++counter;\n   }\n\n   function decrease() public onlyOwner returns (int256) {\n       return --counter;\n   }\n\n}\n\ncontract Proxy is Ownable {\n   mapping(bytes4 => address) public implementations;\n\n   constructor() {\n       Mastercopy mastercopy = new Mastercopy();\n       implementations[bytes4(keccak256(bytes(\"counter()\")))] = address(mastercopy);\n       implementations[Mastercopy.increase.selector] = address(mastercopy);\n       implementations[Mastercopy.increase.selector] = address(mastercopy);\n   }\n\n   fallback() external payable {\n       address implementation = implementations[msg.sig];\n\n       assembly {\n           // Copied without changes to the logic from OpenZeppelin's Proxy contract.\n           calldatacopy(0, 0, calldatasize())\n           let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n           returndatacopy(0, 0, returndatasize())\n           switch result\n               case 0 {\n                   revert(0, returndatasize())\n               }\n               default {\n                   return(0, returndatasize())\n               }\n       }\n   }\n\n   function setImplementationForSelector(bytes4 signature, address implementation) external onlyOwner {\n       implementations[signature] = implementation;\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Won't be able to receive any ether when `calldatasize` is 0 due to a missing `receive()`"
      },
      {
        "choice": "B",
        "answer": "Will be the owner of the Mastercopy contract"
      },
      {
        "choice": "C",
        "answer": "Has a storage clash in slot 0 which will cause issues with the current Mastercopy"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-9.md"
  },
  {
    "question": "8] The `fallback()` function's assembly block",
    "context": "**Note**: All 8 questions in this RACE are based on the below contracts. This is the same contracts you will see for all the 8 questions in this RACE. The question is below the shown contracts.\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Assume the Proxy contract was deployed and no further transactions were made afterwards.\n\ncontract Mastercopy is Ownable {\n   int256 public counter = 0;\n\n   function increase() public onlyOwner returns (int256) {\n       return ++counter;\n   }\n\n   function decrease() public onlyOwner returns (int256) {\n       return --counter;\n   }\n\n}\n\ncontract Proxy is Ownable {\n   mapping(bytes4 => address) public implementations;\n\n   constructor() {\n       Mastercopy mastercopy = new Mastercopy();\n       implementations[bytes4(keccak256(bytes(\"counter()\")))] = address(mastercopy);\n       implementations[Mastercopy.increase.selector] = address(mastercopy);\n       implementations[Mastercopy.increase.selector] = address(mastercopy);\n   }\n\n   fallback() external payable {\n       address implementation = implementations[msg.sig];\n\n       assembly {\n           // Copied without changes to the logic from OpenZeppelin's Proxy contract.\n           calldatacopy(0, 0, calldatasize())\n           let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n           returndatacopy(0, 0, returndatasize())\n           switch result\n               case 0 {\n                   revert(0, returndatasize())\n               }\n               default {\n                   return(0, returndatasize())\n               }\n       }\n   }\n\n   function setImplementationForSelector(bytes4 signature, address implementation) external onlyOwner {\n       implementations[signature] = implementation;\n   }\n}\n```\n\n",
    "possibleAnswers": [
      {
        "choice": "A",
        "answer": "Can be marked as \"memory-safe\" for gas optimizations"
      },
      {
        "choice": "B",
        "answer": "Has the result of the delegate-call overwrite the the call parameters in memory"
      },
      {
        "choice": "C",
        "answer": "Interferes with the Slot-Hash calculation for the implementations-mapping by overwriting the scratch space"
      },
      {
        "choice": "D",
        "answer": "None of the above \n \n \n"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "race": "RACE-9.md"
  }
]